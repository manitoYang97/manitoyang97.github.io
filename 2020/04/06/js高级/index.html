<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JavaScript进阶, HTML,CSS,JavaScript,JQuery,React,Vue.js,node.js,git,github,hexo">
    <meta name="description" content="专注于Web前端,分享生活,分享知识">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JavaScript进阶 | XiaoQi&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


    <body>
        <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">XiaoQi's Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">XiaoQi's Blog</div>
        <div class="logo-desc">
            
            专注于Web前端,分享生活,分享知识
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }
    
    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }
    
    .github-corner svg {
        color: #ff00cc;
        fill: #fff;
        height: 64px;
        width: 64px;
    }
    
    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }
    
    .github-corner .octo-arm {
        animation: none;
    }
    
    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

            



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/16.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JavaScript进阶</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
        
        position: absolute;
        right: 23.5vw;
        display: block;
    }

    .toc-fixed .toc-link::before{
        position: fixed!important;/*当toc的位置改为fixed时，.toc-link::before也要改为fixed*/
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JavaScript/">
                                <span class="chip bg-color">JavaScript</span>
                            </a>
                        
                            <a href="/tags/EC6/">
                                <span class="chip bg-color">EC6</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/web%E5%89%8D%E7%AB%AF/" class="post-category">
                                web前端
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-04-06
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-04-10
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    8.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    34 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="1-面向对象和类的继承"><a href="#1-面向对象和类的继承" class="headerlink" title="1.面向对象和类的继承"></a>1.面向对象和类的继承</h1><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>面向对象是把事务分解成一个一个对象，以对象来划分问题，然后对象之间分工与合作。</p>
<p>面向对象的程序思维中，每一个对象都是功能中心，具有明确的分工。</p>
<p>面向对象编程具有灵活，代码可复用、容易维护和开发大的优点，适合多人合作的大型软件项目</p>
<p>面向对象的特性：封装性、继承性、多态性</p>
<h5 id="面向对象的思维特点："><a href="#面向对象的思维特点：" class="headerlink" title="面向对象的思维特点："></a>面向对象的思维特点：</h5><p><strong><em>1.抽取（抽象）对象公用的属性和行为组织（封装）成一个类（模板）</em></strong></p>
<p><strong><em>2.对类进行实例化，获取类的对象</em></strong></p>
<p>面向对象编程我们考虑的是有哪些对象，按照面向对象的思维特点不断的创建对象，使用对象，指挥对象做事情</p>
<h2 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h2><h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>对象是一个具体的事务，在javascript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象。</p>
<p>对象是由属性和方法组成的</p>
<p>属性：事物的特征，在对象中用属性来表示（常用名词）</p>
<p>方法：事物的行为，在对象中用方法来表示（常用动词）</p>
<h5 id="类class"><a href="#类class" class="headerlink" title="类class"></a>类class</h5><p>在ES6中添加了类的概念，可以使用class关键字声明一个类，之后这个类来实例化对象。</p>
<p><strong>类抽象了对象的公共部分，它泛指某一大类（class）</strong></p>
<p><strong>对象特指某一个，通过类实例化的一个具体的对象</strong></p>
<h2 id="使用class创建自定义类"><a href="#使用class创建自定义类" class="headerlink" title="使用class创建自定义类"></a>使用class创建自定义类</h2><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><pre><code>class name{
//class body
}</code></pre><h3 id="创建实例："><a href="#创建实例：" class="headerlink" title="创建实例："></a>创建实例：</h3><pre><code>var xx = new name;</code></pre><p>注意：类必须使用new实例化对象</p>
<h3 id="类的constructor构造函数"><a href="#类的constructor构造函数" class="headerlink" title="类的constructor构造函数"></a>类的constructor构造函数</h3><p>constructor()方法是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有显示定义，类内部会自动给我们创建一个constructor()</p>
<h3 id="类添加方法"><a href="#类添加方法" class="headerlink" title="类添加方法"></a>类添加方法</h3><p>语法：</p>
<pre><code>class Person{
  constructor(name,age){
      this.name=name;
      this.age=age;
     }
say(){
   console.log(this.name+&#39;你好&#39;)；
    }
}</code></pre><h2 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h2><p>子类可以继承父类的一些属性和方法。</p>
<h3 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h3><pre><code>class Father{
}
class Son extends Father{
}</code></pre><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super关键字用于访问和调用父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数</p>
<h4 id="调用构造函数语法："><a href="#调用构造函数语法：" class="headerlink" title="调用构造函数语法："></a>调用构造函数语法：</h4><pre><code>class Person {      //父类
    constructor(surname){
        this.surname = surname;
    }
}
class Student extends Person {   //子类继承父类
    constructor(surname,firstname){
        super(surname);    //调用父类的constructor(surname)
        this.firstname = firstname;    //定义子类独有的属性
}
}</code></pre><p>注意：子类在构造函数中使用super，必须放在this前面（必须先调用父类的构造方法在使用子类构造方法）</p>
<h4 id="调用普通函数语法："><a href="#调用普通函数语法：" class="headerlink" title="调用普通函数语法："></a>调用普通函数语法：</h4><pre><code>class Father{
   say(){
      return &#39;我是爸爸&#39;;
    }
}
class Son extends Father {
   say(){
      //super.say() super调用父类方法
      return super.say()+&#39;的儿子&#39;;
   }
}
var damo = new Son();
console.log(damo.say());</code></pre><p>注意：在继承中的属性和方法查找原则是就近原则，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就执行子类的，如果没有就在父类中找有没有这个方法，如果有就执行父类的这个方法。</p>
<h2 id="四个注意点"><a href="#四个注意点" class="headerlink" title="四个注意点"></a>四个注意点</h2><p>1.在ES6中类没有变量提升，所以先定义类，再实例化对象</p>
<p>2.类里面的共用属性和方法一定要加this使用</p>
<p>3.类里面的this指向问题</p>
<p>4.constructor里面的 this指向实例化对象，方法里面的this指向这个方法的调用者</p>
<h1 id="2-构造函数和原型"><a href="#2-构造函数和原型" class="headerlink" title="2.构造函数和原型"></a>2.构造函数和原型</h1><h2 id="使用构造函数创建对象"><a href="#使用构造函数创建对象" class="headerlink" title="使用构造函数创建对象"></a>使用构造函数创建对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在ES6之前没有引入类的概念，所以对象不是基于类创建的，而是 一种称为构造函数的特殊函数来定义对象和他们的特征</p>
<p>创建对象可以通过以下三种方式：</p>
<p>1，对象字面量</p>
<p>2，new Object()</p>
<p>3,自定义构造函数</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是一种特殊的函数 ，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用，我们可以把对象中的共有属性和方法抽取出来，然后封装到这个函数里面</p>
<p>在js中使用构造函数要注意以下两点：</p>
<p>1.构造函数用于创建一类对象，其首字母要大写</p>
<p>2.构造函数要和new一起使用才有意义</p>
<h4 id="new在执行时会做四件事情："><a href="#new在执行时会做四件事情：" class="headerlink" title="new在执行时会做四件事情："></a>new在执行时会做四件事情：</h4><p>1.在内存中创建一个新的空对象</p>
<p>2.让this指向这个新的对象</p>
<p>3.执行构造函数的代码，给这个新对象添加属性和方法</p>
<p>4.返回这个新对象（所以构造函数里面不需要return）</p>
<h4 id="成员分类"><a href="#成员分类" class="headerlink" title="成员分类"></a>成员分类</h4><p>JavaScript的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this上添加。通过这两种方法添加的成员，就分别称为静态成员和实例成员</p>
<ul>
<li>静态成员：在构造函数本身上添加的成员为静态成员，只能由构造函数 本身来访问</li>
<li>实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问</li>
</ul>
<h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>构造函数的方法虽然很好用，但是存在浪费内存的问题，因为如果构造函数里面添加了方法这种复杂数据类型，我们每实例化一个对象就会开辟新的空间存放这种复杂数据类型，这样是很没有必要的，所以就有了构造函数的原型prototype</p>
<h2 id="原型的作用"><a href="#原型的作用" class="headerlink" title="原型的作用"></a>原型的作用</h2><h3 id="构造函数原型prototype"><a href="#构造函数原型prototype" class="headerlink" title="构造函数原型prototype"></a>构造函数原型prototype</h3><p>构造函数通过分配的函数是所有对象所共享的。</p>
<p>JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype就是一个对象，这个对象的所有属性和方法都会被构造函数所拥有。</p>
<pre><code>        function Star(uname, age) {
            this.uname = uname;
            this.age = age;
            // this.sing = function() {
            //     console.log(&#39;我会唱歌&#39;);
            // }
        }
        Star.prototype.sing = function() {
            console.log(&#39;我会唱歌&#39;);
        }
        var ldh = new Star(&#39;刘德华&#39;, 18);
        var zxy = new Star(&#39;张学友&#39;, 19);
        console.log(ldh.sing === zxy.sing);
        ldh.sing();
        zxy.sing();
        //  一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上</code></pre><p>我们可以把一些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。</p>
<p><strong>问答</strong></p>
<p>1.原型是什么？</p>
<p>一个对象，我们也称为原型对象</p>
<p>2.原型的作用是什么？</p>
<p>共享方法</p>
<h3 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型 proto"></a>对象原型 <strong>proto</strong></h3><p>对象都有一个属性<strong>proto</strong>指向构造函数的原型对象prototype，之所以我们对象可以使用构造函数prototype原型对象的方法和属性，就是因为对象有<strong>proto</strong>原型存在。</p>
<pre><code>      function Star(uname, age) {
            this.uname = uname;
            this.age = age;
        }
        Star.prototype.sing = function() {
            console.log(&#39;我会唱歌&#39;);
        }
        var ldh = new Star(&#39;刘德华&#39;, 18);
        var zxy = new Star(&#39;张学友&#39;, 19);
        ldh.sing();
        console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype
        console.log(ldh.__proto__ === Star.prototype);
        // 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing
        // 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法</code></pre><ul>
<li>对象原型<strong>proto</strong>和原型对象prototype是等价的</li>
<li><strong>proto</strong>对象原型大的意义在于为对象的查找机制提供了一个方向，或者说是一条路线，但是它是一个非标准属性，因此在实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype</li>
</ul>
<h3 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h3><p>对象原型__proto __和构造函数原型对象prototype里面都有一个属性constructor属性，constructor我们称为构造函数，因为它指回构造函数本身。</p>
<pre><code>           function Star(uname, age) {
            this.uname = uname;
            this.age = age;
        }
        Star.prototype = {
     // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数
            constructor: Star,
            sing: function() {
                console.log(&#39;我会唱歌&#39;);
            },
            movie: function() {
                console.log(&#39;我会演电影&#39;);
            }
        }
        var ldh = new Star(&#39;刘德华&#39;, 18);
        var zxy = new Star(&#39;张学友&#39;, 19);
        console.log(Star.prototype);
        console.log(ldh.__proto__);
        console.log(Star.prototype.constructor);
        console.log(ldh.__proto__.constructor);</code></pre><p>constructor主要用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数</p>
<h3 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a>构造函数、实例、原型对象三者之间的关系</h3><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><pre><code>        function Star(uname, age) {
            this.uname = uname;
            this.age = age;
        }
        Star.prototype.sing = function() {
            console.log(&#39;我会唱歌&#39;);
        }
        var ldh = new Star(&#39;刘德华&#39;, 18);
        // 1. 只要是对象就有__proto__ 原型, 指向原型对象
        console.log(Star.prototype);
        console.log(Star.prototype.__proto__ === Object.prototype);
        // 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototype
        console.log(Object.prototype.__proto__);
        // 3. 我们Object.prototype原型对象里面的__proto__原型  指向为 null</code></pre><img src="C:\Users\一别两宽\Desktop\前端开发\typora笔记\2.JPG" style="zoom:67%;" />

<h3 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h3><p>可以通过原型对象，对原来内置对象进行扩展自定义的方法，比如给数组增加自定义求偶数和的功能。</p>
<p>注意：数组和字符内置对象不能给原型对象覆盖操作Array.prototype = {},只能是Array.prototype.xxx = function(){}的方式</p>
<pre><code>        Array.prototype.sum = function() {
            var sum = 0;
            for (var i = 0; i &lt; this.length; i++) {
                sum += this[i];
            }
            return sum;
        };
        var arr = [1, 2, 3];
        console.log(arr.sum());
        console.log(Array.prototype);
        var arr1 = new Array(11, 22, 33);
        console.log(arr1.sum());</code></pre><h2 id="访问对象成员的规则"><a href="#访问对象成员的规则" class="headerlink" title="访问对象成员的规则"></a>访问对象成员的规则</h2><p>JavaScript成员查找机制</p>
<p>1.当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</p>
<p>2.如果没有就查找它的原型（也就是<strong>proto</strong>指向的prototype原型对象）</p>
<p>3.如果还没有就查找原型对象的原型（Object的原型对象）</p>
<p>4.依次类推一直到找到Object为止（null）</p>
<p>5.<strong>proto</strong>对象原型的意义在于为对象成员查找机制提供了一个方向，或者说是一条线路</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>ES6之前并没有给我们提供extends继承，我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承</p>
<h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p>调用这个函数，并且修改函数运行时的this指向</p>
<pre><code>fun.call(thisArg,arg1,arg2,……)</code></pre><p>thisArg：当前调用函数this的指向函数</p>
<p>arg1，arg2：传递的其他参数</p>
<pre><code>function fn(x, y) {
            console.log(&#39;我想喝手磨咖啡&#39;);
            console.log(this);
            console.log(x + y);
        }
        var o = {
            name: &#39;andy&#39;
        };
        // 1. call() 可以调用函数
         fn.call();
        // 2. call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象
        fn.call(o, 1, 2);</code></pre><pre><code>         function Father(uname, age) {
            // this 指向父构造函数的对象实例
            this.uname = uname;
            this.age = age;
        }
        function Son(uname, age, score) {
            // this 指向子构造函数的对象实例
            Father.call(this, uname, age);// 借用父构造函数继承属性
            this.score = score;
        }
        Son.prototype = new Father();  //借用原型对象继承方法 
        // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数
        Son.prototype.constructor = Son;
        // 这个是子构造函数专门的方法
        Son.prototype.exam = function() {
            console.log(&#39;孩子要考试&#39;);
        }
        var son = new Son(&#39;刘德华&#39;, 18, 100);
        console.log(son);</code></pre><h2 id="ES5新增的一些方法"><a href="#ES5新增的一些方法" class="headerlink" title="ES5新增的一些方法"></a>ES5新增的一些方法</h2><p>数组方法</p>
<p>迭代（遍历）方法：forEach()、map()、filter()、some()、every()</p>
<pre><code>array.forEach(function(currenValue,index,arr))</code></pre><p>currentValue:相当于当前项的值</p>
<p>index：数组当前项的索引</p>
<p>arr：数组对象本身</p>
<pre><code>// forEach 迭代(遍历) 数组
        var arr = [1, 2, 3];
        var sum = 0;
        arr.forEach(function(value, index, array) {
            console.log(&#39;每个数组元素&#39; + value);
            console.log(&#39;每个数组元素的索引号&#39; + index);
            console.log(&#39;数组本身&#39; + array);
            sum += value;
        })
        console.log(sum);</code></pre><pre><code>array.filter(function(currenValue,index,arr))</code></pre><p>filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组，它直接返回一个新的数组。</p>
<pre><code>  // filter 筛选数组
        var arr = [12, 66, 4, 88, 3, 7];
        var newArr = arr.filter(function(value, index) {
            // return value &gt;= 20;
            return value % 2 === 0;
        });
        console.log(newArr);</code></pre><pre><code>array.some(function(currenValue,index,arr))</code></pre><p>some()方法用于检测数组中的元素是否满足指定条件，就是查找数组中是否有满足条件大的元素，它返回值是布尔值，如果查找这个元素就返回true，找不到就返回false</p>
<pre><code>       var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];
         // 如果查询数组中唯一的元素, 用some方法更合适,
        arr.some(function(value) {
            if (value == &#39;green&#39;) {
                console.log(&#39;找到了该元素&#39;);
                return true; //  在some 里面 遇到 return true 就是终止遍历 迭代效率更高
            }
            console.log(11);
        });</code></pre><p>字符串方法</p>
<p>trim()方法会从一个字符串的两端删除空白字符</p>
<pre><code>str.trim()</code></pre><p>trim()方法并不影响原字符串本身，它返回的是一个新的字符串。</p>
<p>对象方法</p>
<p>Object.keys()用于获取对象自身的所有属性</p>
<pre><code>Object.keys(obj)</code></pre><p>效果类似for…in</p>
<p>返回一个由属性名组成的数组</p>
<pre><code>// 用于获取对象自身所有的属性
        var obj = {
            id: 1,
            pname: &#39;小米&#39;,
            price: 1999,
            num: 2000
        };
        var arr = Object.keys(obj);
        console.log(arr);
        arr.forEach(function(value) {
            console.log(value);

        })</code></pre><p>Object.defineProperty()定义新属性或修改原有的属性</p>
<pre><code>Object.defineProperty(obj,prop,descriptor)</code></pre><p>Object.defineProperty()第三个参数descriptor说明：以对象形式{}书写</p>
<p> value：设置属性的值 默认为undefined</p>
<p>writable：值是否可以重写。true|false 默认为false</p>
<p>enumerable：目标属性是否可以被枚举。true|false 默认false</p>
<p>configurable：目标属性是否可以被删除或是否可以再次修改特性true|false 默认是false</p>
<h1 id="3-函数进阶"><a href="#3-函数进阶" class="headerlink" title="3.函数进阶"></a>3.函数进阶</h1><h2 id="说出函数的多种定义和调用方式"><a href="#说出函数的多种定义和调用方式" class="headerlink" title="说出函数的多种定义和调用方式"></a>说出函数的多种定义和调用方式</h2><h3 id="函数的定义方式"><a href="#函数的定义方式" class="headerlink" title="函数的定义方式"></a>函数的定义方式</h3><p>1.函数声明方式function关键字（命名函数）</p>
<pre><code>function fn(){};</code></pre><p>2.函数表达式（匿名函数)</p>
<pre><code>var fun = function(){};</code></pre><p>3.new Function()</p>
<pre><code>var fn = new Function(&#39;参数1&#39;，&#39;参数2&#39;……,&#39;函数体&#39;)</code></pre><ul>
<li>Function里面的参数必须是字符串格式</li>
<li>这种方式执行效率低，也不方便使用，因此使用较少</li>
<li>所有的函数都是Function的实例（对象）</li>
<li>函数也属于对象</li>
</ul>
<h3 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h3><p>1.普通函数</p>
<pre><code>        function fn() {
            console.log(&#39;这是一个普通函数&#39;);
        }
        fn();
        fn.call();</code></pre><p>2.对象的方法</p>
<pre><code>        var o = {
            sayHi: function() {
                console.log(&#39;这是对象的方法&#39;);
            }
        }
        o.sayHi();</code></pre><p>3.构造函数</p>
<pre><code>        function Star() {
            console.log(&#39;这是一个大写的构造函数&#39;);
        }
        new Star();</code></pre><p>4.绑定事件函数</p>
<pre><code>       var btn = document.querySelector(&#39;button&#39;);
        btn.onclick = function() {
            console.log(&#39;这是一个绑定事件函数&#39;);
        }</code></pre><p>5.定时器函数</p>
<pre><code>       setTimeout(function() {
            console.log(&#39;这是定时器函数&#39;)
        }, 1000);</code></pre><p>6.立即执行函数</p>
<pre><code>     (function() {
            console.log(&#39;这是一个立即执行函数&#39;);
        })()</code></pre><h2 id="说出和改变函数内部this的指向"><a href="#说出和改变函数内部this的指向" class="headerlink" title="说出和改变函数内部this的指向"></a>说出和改变函数内部this的指向</h2><h3 id="函数内的this指向"><a href="#函数内的this指向" class="headerlink" title="函数内的this指向"></a>函数内的this指向</h3><p>this的指向是当我们调用函数时确定的，调用的方式不同决定了this的指向不同，一般指向调用者。</p>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>this指向</th>
</tr>
</thead>
<tbody><tr>
<td>普通函数调用</td>
<td>window</td>
</tr>
<tr>
<td>构造函数调用</td>
<td>实例对象，原型对象里的方法也指向实例对象</td>
</tr>
<tr>
<td>对象的方法对象</td>
<td>该方法所属的对象</td>
</tr>
<tr>
<td>事件绑定方法</td>
<td>绑定的事件对象</td>
</tr>
<tr>
<td>定时器函数</td>
<td>window</td>
</tr>
<tr>
<td>立即执行函数</td>
<td>window</td>
</tr>
</tbody></table>
<h3 id="改变函数内部的this指向"><a href="#改变函数内部的this指向" class="headerlink" title="改变函数内部的this指向"></a>改变函数内部的this指向</h3><p>JavaScript提供了函数和方法帮助我们改变函数内部this的指向，常用的有bind() call()  apply()</p>
<h4 id="call-1"><a href="#call-1" class="headerlink" title="call()"></a>call()</h4><pre><code>        var o = {
            name: &#39;andy&#39;
        }

        function fn(a, b) {
            console.log(this);
            console.log(a + b);
        }
        fn.call(o, 1, 23)  //可以调用函数，可以改变this指向，可以传递普通参数</code></pre><pre><code> //主要应用于继承
        function Father(uname, age, sex) {
            this.uname = uname;
            this.age = age;
            this.sex = sex;
        }
        function Son(uname, age, sex) {
            Father.call(this, uname, age, sex);
        }
        var son = new Son(&#39;刘德华&#39;, 12, &#39;男&#39;)
        console.log(son);</code></pre><h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><pre><code>     var o = {
            uname: &#39;andy &#39;
        }
        function fn(arr) {
            console.log(this);
            console.log(arr);
        }
        fn.apply(o, [&#39;hello&#39;]);//可以调用函数，可以改变this指向，但是第二个参数必须是数组</code></pre><pre><code>        //apply主要应用于用数学内置函数求数组最大最小值
        var arr = [12, 33, 77, 1, 0]
        var max = Math.max.apply(Math, arr)
        var min = Math.min.apply(Math, arr)
        console.log(max, min);</code></pre><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><pre><code>        var o = {
            name: &#39;andy&#39;
        };
        function fn(a, b) {
            console.log(this);
            console.log(a + b);
        };
        var f = fn.bind(o, 1, 2);  //不会调用函数 ，可以改变this的指向，返回的时改变后的新函数
        f();</code></pre><pre><code>// bind()的主要应用：函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind
// 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮
        var btn = document.querySelectorAll(&#39;button&#39;);
        for (var i = 0; i &lt; btn.length; i++) {
            btn[i].onclick = function() {
                this.disabled = true;
                setTimeout(function() {
                    this.disabled = false;
                }.bind(this), 2000)
            }
        }</code></pre><h2 id="说出严格模式的特点"><a href="#说出严格模式的特点" class="headerlink" title="说出严格模式的特点"></a>说出严格模式的特点</h2><p>严格模式（strict modes）JavaScript变体的一种方式，即在严格的条件下运行js代码，它对正常的js语义做了一些更改：</p>
<ol>
<li>消除了JavaScript语法的一些不合理，不谨慎之处，减少了一些怪异行为</li>
<li>消除了代码运行的不安全之处，保证了代码运行的安全</li>
<li>提高编译器效率，增加运行速度</li>
<li>禁用了ECMAScript的未来版本中可能会定义的一些语法，为未来的JavaScript做好了铺垫。</li>
</ol>
<h3 id="开启严格模式"><a href="#开启严格模式" class="headerlink" title="开启严格模式"></a>开启严格模式</h3><p>严格模式可以应用到整个脚本或个别函数中，因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。</p>
<h4 id="为脚本开启严格模式"><a href="#为脚本开启严格模式" class="headerlink" title="为脚本开启严格模式"></a>为脚本开启严格模式</h4><pre><code>&lt;scprit&gt;
  &#39;use strict&#39;;
  console,log(&quot;这是严格模式&quot;);
 &lt;/scprit&gt;  //不常用，影响文件合成</code></pre><h4 id="为函数开启严格模式"><a href="#为函数开启严格模式" class="headerlink" title="为函数开启严格模式"></a>为函数开启严格模式</h4><pre><code>    &lt;script&gt;
        (function() {
            &#39;use strict&#39;;
        })();
    &lt;/script&gt;</code></pre><h3 id="严格模式中的变化"><a href="#严格模式中的变化" class="headerlink" title="严格模式中的变化"></a>严格模式中的变化</h3><h4 id="变量的变化"><a href="#变量的变化" class="headerlink" title="变量的变化"></a>变量的变化</h4><ul>
<li>在正常模式下如果一个变量未声明就赋值默认是全局变量，在严格模式下禁止这样使用变量必须先用var声明再使用。</li>
<li>严禁删除已声明的变量</li>
</ul>
<h4 id="严格模式下this的指向问题"><a href="#严格模式下this的指向问题" class="headerlink" title="严格模式下this的指向问题"></a>严格模式下this的指向问题</h4><ul>
<li>以前全局作用域函数this指向window，严格模式下全局作用域的函数this指向undefined</li>
<li>以前构造函数不加new调用当成普通函数调用且this指向window，严格模式下会报错</li>
<li>new实例化的构造函数还是指向创建的对象实例</li>
<li>定时器this还是指向window</li>
<li>事件、对象还是指向调用者</li>
</ul>
<h4 id="函数的变化"><a href="#函数的变化" class="headerlink" title="函数的变化"></a>函数的变化</h4><ul>
<li>函数不能有重名的参数</li>
<li>函数必须声明在顶层，不能声明在for if 之类的里面</li>
</ul>
<h2 id="把函数作为参数和返回值传递"><a href="#把函数作为参数和返回值传递" class="headerlink" title="把函数作为参数和返回值传递"></a>把函数作为参数和返回值传递</h2><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出</p>
<pre><code>        function fn(a, b, callback) {
            console.log(a + b);
            callback &amp;&amp; callback();
        }
        fn(1, 2, function() {
            console.log(&#39;我是最后调用的&#39;);
        });</code></pre><pre><code>function fn(){
    return function() {}; 
}
fn();</code></pre><h2 id="说出闭包的的作用"><a href="#说出闭包的的作用" class="headerlink" title="说出闭包的的作用"></a>说出闭包的的作用</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。简单说就是一个作用域可以访问另一个函数内部的局部变量。</p>
<h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><p>闭包的主要作用：延伸了变量的作用范围</p>
<h3 id="闭包案例"><a href="#闭包案例" class="headerlink" title="闭包案例"></a>闭包案例</h3><p>循环注册点击事件</p>
<pre><code>   var lis = document.querySelectorAll(&#39;li&#39;);
        for (var i = 0; i &lt; lis.length; i++) {
            (function(i) {
                lis[i].onclick = function() {
                    console.log(i);
                }
            })(i);
        }</code></pre><p>循环中的setTimeout()</p>
<pre><code> //3秒钟后打印所有的li
        var lis = document.querySelector(&#39;.nav&#39;).querySelectorAll(&#39;li&#39;);
        for (var i = 0; i &lt; lis.length; i++) {
            (function(i) {
                setTimeout(function() {
                    console.log(lis[i].innerHTML);
                }, 3000)
            })(i)
        }</code></pre><p>计算打车价格</p>
<h2 id="说出递归的两个条件"><a href="#说出递归的两个条件" class="headerlink" title="说出递归的两个条件"></a>说出递归的两个条件</h2><p>什么是递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数，简单的说就是一个函数自己调用自己就是递归函数。递归函数的作用和循环时一样的。由于递归函数很容易发生“栈溢出”错误（stack overflow），所以必须加退出条件return。</p>
<p>递归的两个条件：一自身调用，二退出条件</p>
<pre><code>        //利用递归求1-n的阶乘
        function fn(n) {
            if (n == 1) {
                return 1;
            }
            return n * fn(n - 1);
        }
        console.log(fn(4));</code></pre><pre><code>//利用递归求斐波拉及数
        function fun(i) {
            if (i == 1 || i == 2) {
                return 1;
            }
            return fun(i - 1) + fun(i - 2);
        }
        console.log(fun(4));</code></pre><h2 id="说出深拷贝和浅拷贝的区别"><a href="#说出深拷贝和浅拷贝的区别" class="headerlink" title="说出深拷贝和浅拷贝的区别"></a>说出深拷贝和浅拷贝的区别</h2><p>1.浅拷贝只拷贝一层，更深层次对象级别的只拷贝引用</p>
<p>Object.assign(target,…sources) es6新增的方法可以实现浅拷贝</p>
<pre><code>        var obj = {
            id: 1,
            name: &#39;andy&#39;,
            msg: {
                age: 18
            }
        };
        var o = {};
        for (var k in obj) {
            //k是属性名，obg[k]是属性值
            o[k] = obj[k];
        }
        console.log(o);
        o.msg.age = 20;//这种复杂数据类型拷贝的是地址额，当一个改变原来的也会改变
        console.log(obj);</code></pre><pre><code>        Object.assign(o, obj);</code></pre><p>2.深拷贝拷贝多层，每一次的数据都会拷贝</p>
<pre><code>        var obj = {
            id: 1,
            name: &#39;andy&#39;,
            msg: {
                age: 18
            },
            color: [&#39;pink&#39;, &#39;red&#39;]
        };
        var o = {};
        //封装函数
           function deepCopy(newobj, oldobj) {
            for (k in oldobj) {
                var item = oldobj[k];
                //判断数据类型
                if (item instanceof Array) {
                    newobj[k] = [];
                    deepCopy(newobj[k], item);
                } else if (item instanceof Object) {
                    newobj[k] = {};
                    deepCopy(newobj, item);
                } else {
                    newobj[k] = item;
                }
            }
        }
        deepCopy(o, obj);
        o.msg.age = 90;//修改拷贝过的对象里的方法，原对象不会有影响
        console.log(o);
        console.log(obj);</code></pre><h1 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4.正则表达式"></a>4.正则表达式</h1><h2 id="说出正则表达式的作用"><a href="#说出正则表达式的作用" class="headerlink" title="说出正则表达式的作用"></a>说出正则表达式的作用</h2><h3 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h3><p>正则表达式是用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象</p>
<h3 id="正则表达式的作用"><a href="#正则表达式的作用" class="headerlink" title="正则表达式的作用"></a>正则表达式的作用</h3><p>正则表达式通常用检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名，表单只能输入英文字母，数字或下划线，昵称可以输入中文（匹配）；此外，正则表达式还常用于过滤页面中内容的一些敏感词（替换）；或从字符串中提取我们想要的特定部分（提取）。</p>
<h3 id="正则表达式的特点"><a href="#正则表达式的特点" class="headerlink" title="正则表达式的特点"></a>正则表达式的特点</h3><ol>
<li>灵活性、逻辑性和功能性非常强</li>
<li>可以迅速的用极为简单的方法达对字符串的复杂控制</li>
<li>对于刚接触的人可能比较晦涩难懂</li>
<li>实际开发一般都是直接复制写好的正则表达式，但是要求我们能看懂并且根据需求修改</li>
</ol>
<h2 id="写出简单的正则表达式"><a href="#写出简单的正则表达式" class="headerlink" title="写出简单的正则表达式"></a>写出简单的正则表达式</h2><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><p>1.通过RegExp对象的构造寒素创建</p>
<pre><code>var 变量名 = new RegExp(/表达式/)</code></pre><p>2.通过字面量创建</p>
<pre><code>var 变量名 = /表达式/;</code></pre><h3 id="测试正则表达式text"><a href="#测试正则表达式text" class="headerlink" title="测试正则表达式text"></a>测试正则表达式text</h3><p>text()正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，其参数式测试字符串</p>
<pre><code>regexobj.text(str)</code></pre><ol>
<li>regexobj是写的正则表达式</li>
<li>str是我们要测试的文本</li>
<li>作用是检测str文本是否符合我们写的正则表达式</li>
</ol>
<h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h3><p>一个正则表达式可以由简答的字符组成，比如/abc/，也可以是简单和特殊字符的组合，比如/ab*c/，其中特殊字符也被称为原字符，在正则表达式中具有特殊意义的符号，如^,$,+等。</p>
<h4 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h4><p>正则表达式中的边界符（位置符）用来提示字符所处的位置，主要由两个字符，</p>
<table>
<thead>
<tr>
<th>边界符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>表示匹配行首大的文本（从谁开始）</td>
</tr>
<tr>
<td>$</td>
<td>表示匹配行尾的文本（以谁结束）</td>
</tr>
</tbody></table>
<h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h4><p>字符类有一系列的字符可供选择，只要匹配其中一个就可以了，所有可供选择的字符都放在方括号中就可以了。[a-z]表示从a到z。方括号里面可以使用字符组合如：[a-zA-Z0-9]；方括号中的^是取反符[^]。</p>
<h4 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h4><p>量词符用来设定某个模式出现的次数</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>？</td>
<td>重复一次或零次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<h4 id="括号总结"><a href="#括号总结" class="headerlink" title="括号总结"></a>括号总结</h4><ol>
<li>大括号 量词符 里面重复的次数</li>
<li>中括号 字符集合 匹配方括号中的任意字符</li>
<li>小括号 表示优先级</li>
</ol>
<h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3><p>预定义类表示的是常见模式的简写方式</p>
<table>
<thead>
<tr>
<th>预定类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>匹配0-9之间的任意一个数字，相当于[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>匹配所有0-9之外的字符，相当于 [ ^ 0-9 ]</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任意字母数字下划线，相当于[a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>匹配所有字母数字下划线以外的字符，相当于[ ^a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空格 换行符制表符空格符等</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空格字符</td>
</tr>
</tbody></table>
<h2 id="使用正则表达式对表单进行验证"><a href="#使用正则表达式对表单进行验证" class="headerlink" title="使用正则表达式对表单进行验证"></a>使用正则表达式对表单进行验证</h2><h2 id="使用正则表达式替换内容"><a href="#使用正则表达式替换内容" class="headerlink" title="使用正则表达式替换内容"></a>使用正则表达式替换内容</h2><h3 id="raplace"><a href="#raplace" class="headerlink" title="raplace()"></a>raplace()</h3><p>raplace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式</p>
<pre><code>stringObject.replace(regexp/substr,replacement)</code></pre><ol>
<li>第一个参数：被替换的字符串或者正则表达式</li>
<li>第二个参数：替换为大的字符串</li>
<li>返回值十一和替换完毕的新字符串</li>
</ol>
<h3 id="正则表达式参数"><a href="#正则表达式参数" class="headerlink" title="正则表达式参数"></a>正则表达式参数</h3><pre><code>/表达式/[switch]</code></pre><p>switch（也称为修饰符）按照什么样的模式匹配，有三种值</p>
<ul>
<li>g：全局匹配</li>
<li>i：忽略大小写</li>
<li>gi：全局匹配+忽略大小写</li>
</ul>
<h1 id="5-ES6"><a href="#5-ES6" class="headerlink" title="5.ES6"></a>5.ES6</h1><h2 id="ES6概述"><a href="#ES6概述" class="headerlink" title="ES6概述"></a>ES6概述</h2><h3 id="什么是ES6"><a href="#什么是ES6" class="headerlink" title="什么是ES6"></a>什么是ES6</h3><p>ES的全ECMAScript，它是由ECMA国际标准化组织制度的一项脚本语言的标准化规范，2015年的版本叫做ES2015，2016年的版本叫做ES2016……所以ES6实际上是泛指ES2015及后续的版本。</p>
<h3 id="为什么要使用ES6"><a href="#为什么要使用ES6" class="headerlink" title="为什么要使用ES6"></a>为什么要使用ES6</h3><p>每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript本身有一些让人不满意的地方。比如变量的提升特性增加了程序运行的不可预测性，语法过于松散，实现相同的功能不同的人可能写出不同的代码……</p>
<h2 id="变量let"><a href="#变量let" class="headerlink" title="变量let"></a>变量let</h2><p>ES6中新增的声明变量的关键字</p>
<h4 id="let的特点"><a href="#let的特点" class="headerlink" title="let的特点"></a>let的特点</h4><p>特点1：let声明的变量只在处于块级有效（大括号中定义的，只在大括号中有效）</p>
<pre><code>if(true){
     let a =10;
}
console.log(a);  //a is not defined</code></pre><p>注意：let声明的变量只在块级作用域下有效，但是var声明的变量不具有块级作用域的特性。</p>
<p>特点2：不存在变量提升（不能先用再声明）</p>
<pre><code>console.log(a); //a is not defined
let a = 10 ;</code></pre><p>特点3：暂时性死区</p>
<pre><code>        var num = 10
        if (true) {
            console.log(num);
            //因为在块级作用域有let关键字，所以var定义的全局不起作用，let在后面定义前面打印就会出错。
            let num = 20;
        }</code></pre><h4 id="let的经典面试题"><a href="#let的经典面试题" class="headerlink" title="let的经典面试题"></a>let的经典面试题</h4><pre><code>        var arr = [];
        for (var i = 0; i &lt; 2; i++) {
            arr[i] = function() {
                console.log(i);
            }
        }
        arr[0](); //2
        arr[1](); //2
        //关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值</code></pre><pre><code>        let arr = [];
        for (let i = 0; i &lt; 2; i++) {
            arr[i] = function() {
                console.log(i);
            }
        }
        arr[0](); //0
        arr[1](); //1
        //关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上           一级（循环每次产生的块级作用域）作用域下的i值</code></pre><h2 id="常量const"><a href="#常量const" class="headerlink" title="常量const"></a>常量const</h2><p>作用：声明常量，常量就是值（内存地址）不会发生变化的量</p>
<p>特点1：具有块级作用域</p>
<pre><code>if(true) {
   const a=10;
}
console.log(a);  //a is not defined</code></pre><p>特点2：声明常量必须赋值</p>
<pre><code>conts PI; //错误，PI没有赋初值</code></pre><p>特点3：常量赋值后，值不能修改</p>
<pre><code>        const PI = 3.14;
        PI = 100; //错误：Assignment to constant variable.</code></pre><pre><code>        const ary = [100, 200];
        ary[0] = &#39;a&#39;;
        ary[1] = &#39;b&#39;;
        console.log(ary);   //[&#39;a&#39; ,&#39;b&#39;] 
        ary = [&#39;a&#39;, &#39;b&#39;];   // 错误 Assignment to constant variable.</code></pre><h2 id="let、const、var的区别"><a href="#let、const、var的区别" class="headerlink" title="let、const、var的区别"></a>let、const、var的区别</h2><table>
<thead>
<tr>
<th>var</th>
<th>let</th>
<th>const</th>
</tr>
</thead>
<tbody><tr>
<td>函数级作用域</td>
<td>块级作用域</td>
<td>块级作用域</td>
</tr>
<tr>
<td>变量提升</td>
<td>不存在变量提升</td>
<td>不存在变量提升</td>
</tr>
<tr>
<td>值可更改</td>
<td>值可更改</td>
<td>值不可更改</td>
</tr>
</tbody></table>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ES6中允许从数组中提取值，按照对应的位置对变量赋值，对象也可以实现解构。</p>
<h3 id="数据解构"><a href="#数据解构" class="headerlink" title="数据解构"></a>数据解构</h3><p>数组解构允许我们按照一一对应的关系从数组中提取值然后将值赋给变量。</p>
<pre><code>        let [a, b, c] = [1, 2, 3];
        console.log(a); //1
        console.log(b); //2 
        console.log(c); //3</code></pre><p>当数组中的值和变量不是一一对应关系，变量的值就是undefined</p>
<pre><code>        let [foot] = []; 
        let [foo, bar] = [11]; 
        console.log(foot, foo, bar); //undefined 11 undefined</code></pre><h3 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a>对象结构</h3><pre><code>let person = {
            name: &#39;张三&#39;,
            age: 20
        };
        let {name,age} = person
        console.log(name); //张三
        console.log(age);  //20</code></pre><pre><code>        let {name: myName} = person; //也可以使用别名获取
        console.log(myName);</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES中新增的定义函数的方式</p>
<pre><code>        () =&gt; {}
        //如下
        const fn = () =&gt; {
            console.log(123);
        }
        fn();</code></pre><pre><code>        //如果函数体中只有一句代码并且代码的执行结果就是函数的返回值，函数体大括号可以省略
        const sum = (n1, n2) =&gt; {
            return n1 + n2;
        }
        //可简写为：
        const sum = (n1, n2) =&gt; n1 + n2;
        console.log(sum(1, 2));</code></pre><pre><code>        //如果形参只有一个参数可省略小括号
        const fun = (v) =&gt; {
            alert(v);
        }       
        //可简写为
        const fun = v =&gt; {
            alert(v)
        }
        fun(7);</code></pre><p>箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this</p>
<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>剩余函数允许我们将不定数量的参数表示为一个数组</p>
<pre><code>        function sum(first, ...args) {
            console.log(first); //10
            console.log(args); //[20,30,40]
        }
        sum(10, 20, 30, 40);</code></pre><p>剩余参数配合解构使用</p>
<pre><code>        let ary = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];
        let [s1, ...s2] = ary;
        console.log(s1); //&#39;a&#39;
        console.log(s2); //[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]</code></pre><h2 id="Array的扩展方法"><a href="#Array的扩展方法" class="headerlink" title="Array的扩展方法"></a>Array的扩展方法</h2><h3 id="扩展运算符（展开语法）"><a href="#扩展运算符（展开语法）" class="headerlink" title="扩展运算符（展开语法）"></a>扩展运算符（展开语法）</h3><p>1.扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。</p>
<pre><code>        let ary = [1, 2, 3];
        console.log(...ary);   //1 2 3  注意这里逗号被当成了log的分隔符</code></pre><p>2.扩展运算符可以应用于合并数组</p>
<pre><code>        let ary1 = [1, 2, 3];
        let ary2 = [3, 4, 5];
        let ary3 = [...ary1, ...ary2];
        console.log(ary3);   //[1,2,3,4,5,6] 
        ary1.push(...ary2);
        console.log(ary1);   //[1,2,3,4,5,6]</code></pre><p>3.扩展运算符可以将类数组或可遍历的对象转换为真正的数组，以便调用数组的方法</p>
<pre><code>        let divs = document.querySelectorAll(&#39;div&#39;);
        let oDivs = [...divs];
        oDivs.push(&#39;abc&#39;) 
        console.log(oDivs);  //[div, div, div, div, div, &quot;abc&quot;]</code></pre><h3 id="构造函数的方法：Array-from"><a href="#构造函数的方法：Array-from" class="headerlink" title="构造函数的方法：Array.from()"></a>构造函数的方法：Array.from()</h3><p>1.将类数组或可遍历的数组转换为真正的数组</p>
<pre><code>        let arrLike = {
            &#39;0&#39;: &#39;a&#39;,
            &#39;1&#39;: &#39;b&#39;,
            &#39;2&#39;: &#39;c&#39;,
            length: 3
        };
        let arr = Array.from(arrLike);
        console.log(arr); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre><p>2.这个方法还可以接受第二个参数，作用类似于数组map方法，用于对每个元素进行处理，将处理后的值放入数组。</p>
<pre><code>        let arrLike = {
            &#39;0&#39;: &#39;2&#39;,
            &#39;1&#39;: &#39;3&#39;,
            &#39;2&#39;: &#39;4&#39;,
            length: 3
        };
        let arr = Array.from(arrLike, item =&gt; item * 2);
        console.log(arr); //[4, 6, 8]</code></pre><h3 id="实例方法-find"><a href="#实例方法-find" class="headerlink" title="实例方法:find()"></a>实例方法:find()</h3><p>用于找出第一个符合条件的数组成员，如果没有找回就返回undefined</p>
<pre><code>        let ary = [{
            id: 2,
            name: &quot;张三&quot;
        }, {
            id: 2,
            name: &quot;李四&quot;
        }];
        let target = ary.find(item =&gt; item.id == 2);
        console.log(target);    //{id: 2, name: &quot;张三&quot;}</code></pre><h3 id="实例方法-findIndex"><a href="#实例方法-findIndex" class="headerlink" title="实例方法:findIndex()"></a>实例方法:findIndex()</h3><p>用于找到第一个符合条件的数组成员的位置，如果没有找到返回-1</p>
<pre><code>        let ary = [1, 5, 10, 15];
        let index = ary.findIndex(value =&gt; value &gt; 9);
        console.log(index);  //2</code></pre><h3 id="实例方法-includes"><a href="#实例方法-includes" class="headerlink" title="实例方法:includes()"></a>实例方法:includes()</h3><p>表示某个数组是否包含给定值，返回的是布尔值</p>
<pre><code>[1,2,3].includes(2)   //true</code></pre><h2 id="String的扩展方法"><a href="#String的扩展方法" class="headerlink" title="String的扩展方法"></a>String的扩展方法</h2><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>ES6新增的创建字符串的方式，使用反引号定义</p>
<pre><code>        let name = `zhangsan`;</code></pre><p>模板字符串可以解析变量</p>
<pre><code>        let name = `zhangsan`;
        let sayHello = `hello my name is ${name}`;
        console.log(sayHello);</code></pre><p>模板字符串可以换行</p>
<pre><code>        let res = {
            name: &#39;张三&#39;,
            age: 12
        }
        let html = `
        &lt;div&gt;
            &lt;span&gt;${res.name}&lt;/span&gt;
            &lt;span&gt;${res.age}&lt;/span&gt;
        &lt;/div&gt;`;
        console.log(html);</code></pre><p>模板字符串可以调用函数</p>
<pre><code>        const fn = () =&gt; &#39;我是fn函数&#39;
        let html = `我是模板字符串 ${fn()}`;
        console.log(html)</code></pre><h3 id="实例方法：starsWith-和endsWith"><a href="#实例方法：starsWith-和endsWith" class="headerlink" title="实例方法：starsWith()和endsWith()"></a>实例方法：starsWith()和endsWith()</h3><ul>
<li>starsWith():表示参数字符串是否在原字符串的头部，返回布尔值</li>
<li>endsWith():表示参数字符串是否在原字符串的尾部，返回布尔值</li>
</ul>
<pre><code>        let str = &#39;Hello ECMAScript 2015&#39;;
        let r1 = str.startsWith(&#39;Hello&#39;);  //true
        console.log(r1);
        let r2 = str.endsWith(&#39;2016&#39;);  //false
        console.log(r2)</code></pre><h3 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h3><p>表示将原字符重复n次返回一个新字符串</p>
<pre><code>        console.log(&quot;y&quot;.repeat(5)) //yyyyy</code></pre><h2 id="set数据结构"><a href="#set数据结构" class="headerlink" title="set数据结构"></a>set数据结构</h2><p>ES6提供了新的数据结构Set，它类似于数组，但成员的值都是唯一的，没有重复的。</p>
<p>Set本身是一个构造函数，用来生成Set数据结构。</p>
<pre><code>const s = new Set();</code></pre><p>Set 函数可以接受一个数组作为参数，用来初始化。</p>
<pre><code>const set = new Set([1,2,3,4,4]);</code></pre><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li>add(Value):添加某个值，返回Set结构本身</li>
<li>delete(value):删除一个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value):返回一个布尔值，表示该值是否为Set的成员</li>
<li>clear():清除所有成员，没有返回值</li>
</ul>
<pre><code>const s = new Set();
s.add(1).add(2);  //向set结构中添加值
s.delete(2);  //删除set结构中的2值
s.has(1)   //表示set结构中是否有这个值，返回布尔值
s.clear()  //清除s中的所有值</code></pre><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>Set结构的实例与数组一样，也有forEach方法，用于对每个成员执行某种操作，没有返回值</p>
<pre><code>s.forEach(value =&gt; console.log(value))</code></pre>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.iamys.club" rel="external nofollow noreferrer">XiaoQi</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.iamys.club/2020/04/06/js%E9%AB%98%E7%BA%A7/">https://www.iamys.club/2020/04/06/js%E9%AB%98%E7%BA%A7/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://www.iamys.club" target="_blank">XiaoQi</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JavaScript/">
                                    <span class="chip bg-color">JavaScript</span>
                                </a>
                            
                                <a href="/tags/EC6/">
                                    <span class="chip bg-color">EC6</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC80OTU0Mi8yNjAzMw==">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    
	
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/04/10/jQuery/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="初识jQuery">
                        
                        <span class="card-title">初识jQuery</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            初始jQuery什么是jQueryjQuery是一个快速、简洁的javascript库，它里面封装了JavaScript常用大的功能代码，优化了DOM操作、事件处理、动画设计和Ajax交互，学习jQuery的本质就是学习调用这些函数（方法）
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-04-10
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/web%E5%89%8D%E7%AB%AF/" class="post-category">
                                    web前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/jQuery/">
                        <span class="chip bg-color">jQuery</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2020/04/06/js%E9%AB%98%E7%BA%A7/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="JavaScript进阶">
                        
                        <span class="card-title">JavaScript进阶</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1.面向对象和类的继承什么是面向对象面向对象是把事务分解成一个一个对象，以对象来划分问题，然后对象之间分工与合作。
面向对象的程序思维中，每一个对象都是功能中心，具有明确的分工。
面向对象编程具有灵活，代码可复用、容易维护和开发大的优点，适
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-04-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/web%E5%89%8D%E7%AB%AF/" class="post-category">
                                    web前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JavaScript/">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                    <a href="/tags/EC6/">
                        <span class="chip bg-color">EC6</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: XiaoQi&#39;s Blog<br />'
            + '文章作者: XiaoQi<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



                <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://www.iamys.club" target="_blank">XiaoQi</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">58.7k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "4";
                    var startDate = "6";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/manitoYang97" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1678271576@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1678271576" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1678271576" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


                    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
                        <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


                            <script src="/libs/materialize/materialize.min.js"></script>
                            <script src="/libs/masonry/masonry.pkgd.min.js"></script>
                            <script src="/libs/aos/aos.js"></script>
                            <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
                            <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
                            <script src="/js/matery.js"></script>


                            <!-- Baidu Analytics -->

                                <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

                                    
                                        <script src="/libs/others/clicklove.js" async="async"></script>
                                        
                                            
                                                <script async src="/libs/others/busuanzi.pure.mini.js"></script>
                                                

                                                    

                                                            

                                                                    
                                                                        <script type="text/javascript" color="0,0,255" pointColor="0,0,255" opacity='0.7' zIndex="-1" count="99" src="/libs/background/canvas-nest.js"></script>
                                                                        

                                                                            
                                                                                
                                                                                    <script type="text/javascript" size="150" alpha='0.6' zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
                                                                                    

                                                                                        

                                                                                                
                                                                                                    <script src="/libs/instantpage/instantpage.js" type="module"></script>
                                                                                                    

    </body>

</html>