{"meta":{"title":"XiaoQi's Blog","subtitle":"Serious life.","description":"专注于Web前端,分享生活,分享知识","author":"XiaoQi","url":"https://www.iamys.club","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T12:58:58.164Z","comments":true,"path":"about/index.html","permalink":"https://www.iamys.club/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T13:00:58.441Z","comments":true,"path":"contact/index.html","permalink":"https://www.iamys.club/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-04-08T13:02:15.797Z","comments":true,"path":"friends/index.html","permalink":"https://www.iamys.club/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T12:59:50.241Z","comments":true,"path":"categories/index.html","permalink":"https://www.iamys.club/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-04-08T12:54:45.821Z","comments":true,"path":"tags/index.html","permalink":"https://www.iamys.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"对房天下西安站二手房源数据进行数据探索","slug":"大数据2020","date":"2020-06-19T16:00:00.000Z","updated":"2020-06-20T02:51:00.039Z","comments":true,"path":"2020/06/20/大数据2020/","link":"","permalink":"https://www.iamys.club/2020/06/20/%E5%A4%A7%E6%95%B0%E6%8D%AE2020/","excerpt":"","text":"项目分析利用大数据实验环境完成一个真实的项目。以房天下西安站二手房源数据为分析对象，使用用Numpy + Pandas库对数据进行探索性分析。首先通过Pandas对象将其从Excel电子表格中导入到数据框中。然后，对房源数据进行清洗。最后，对各关键字段字段进行相应的可视化处理。 首先导入要使用的科学计算包numpy,pandas,可视化matplotlib,seaborn,以及机器学习包sklearn。 import pandas as pd import numpy as np import seaborn as sns import matplotlib as mpl import matplotlib.pyplot as plt from IPython.display import display plt.style.use(&quot;fivethirtyeight&quot;) sns.set_style({&#39;font.sans-serif&#39;:[&#39;simhei&#39;,&#39;Arial&#39;]}) %matplotlib inline # 检查Python版本 from sys import version_info if version_info.major != 3: raise Exception(&#39;请使用Python 3 来完成此项目&#39;) 复制代码然后导入数据，并进行初步的观察，这些观察包括了解数据特征的缺失值，异常值，以及大概的描述性统计。 # 导入链家二手房数据 lianjia_df = pd.read_csv(&#39;lianjia.csv&#39;) display(lianjia_df.head(n=2)) 复制代码 初步观察到一共有11个特征变量，Price 在这里是我们的目标变量，然后我们继续深入观察一下。 # 检查缺失值情况 lianjia_df.info() 发现了数据集一共有23677条数据，其中Elevator特征有明显的缺失值。 lianjia_df.describe() 上面结果给出了特征值是数值的一些统计值，包括平均数，标准差，中位数，最小值，最大值，25%分位数，75%分位数。这些统计结果简单直接，对于初始了解一个特征好坏非常有用，比如我们观察到 Size 特征 的最大值为1019平米，最小值为2平米，那么我们就要思考这个在实际中是不是存在的，如果不存在没有意义，那么这个数据就是一个异常值，会严重影响模型的性能。 当然，这只是初步观察，后续我们会用数据可视化来清晰的展示，并证实我们的猜测。 # 添加新特征房屋均价 df = lianjia_df.copy() df[&#39;PerPrice&#39;] = lianjia_df[&#39;Price&#39;]/lianjia_df[&#39;Size&#39;] # 重新摆放列位置 columns = [&#39;Region&#39;, &#39;District&#39;, &#39;Garden&#39;, &#39;Layout&#39;, &#39;Floor&#39;, &#39;Year&#39;, &#39;Size&#39;, &#39;Elevator&#39;, &#39;Direction&#39;, &#39;Renovation&#39;, &#39;PerPrice&#39;, &#39;Price&#39;] df = pd.DataFrame(df, columns = columns) # 重新审视数据集 display(df.head(n=2))我们发现Id特征其实没有什么实际意义，所以将其移除。由于房屋单价分析起来比较方便，简单的使用总价/面积就可得到，所以增加一个新的特征 PerPrice（只用于分析，不是预测特征）。另外，特征的顺序也被调整了一下，看起来比较舒服。 数据可视化分析Region特征分析对于区域特征，我们可以分析不同区域房价和数量的对比。 # 对二手房区域分组对比二手房数量和每平米房价 df_house_count = df.groupby(&#39;Region&#39;)[&#39;Price&#39;].count().sort_values(ascending=False).to_frame().reset_index() df_house_mean = df.groupby(&#39;Region&#39;)[&#39;PerPrice&#39;].mean().sort_values(ascending=False).to_frame().reset_index() f, [ax1,ax2,ax3] = plt.subplots(3,1,figsize=(20,15)) sns.barplot(x=&#39;Region&#39;, y=&#39;PerPrice&#39;, palette=&quot;Blues_d&quot;, data=df_house_mean, ax=ax1) ax1.set_title(&#39;北京各大区二手房每平米单价对比&#39;,fontsize=15) ax1.set_xlabel(&#39;区域&#39;) ax1.set_ylabel(&#39;每平米单价&#39;) sns.barplot(x=&#39;Region&#39;, y=&#39;Price&#39;, palette=&quot;Greens_d&quot;, data=df_house_count, ax=ax2) ax2.set_title(&#39;北京各大区二手房数量对比&#39;,fontsize=15) ax2.set_xlabel(&#39;区域&#39;) ax2.set_ylabel(&#39;数量&#39;) sns.boxplot(x=&#39;Region&#39;, y=&#39;Price&#39;, data=df, ax=ax3) ax3.set_title(&#39;北京各大区二手房房屋总价&#39;,fontsize=15) ax3.set_xlabel(&#39;区域&#39;) ax3.set_ylabel(&#39;房屋总价&#39;) plt.show() 复制代码 使用了pandas的网络透视功能groupby分组排序。区域特征可视化直接采用 seaborn完成，颜色使用调色板palette 参数，颜色渐变，越浅说明越少，反之越多。 可以观察到： 二手房均价：西城区的房价最贵均价大约11万/平，因为西城在二环以里，且是热门学区房的聚集地。其次是东城大约10万/平，然后是海淀大约8.5万/平，其它均低于8万/平。 二手房房数量：从数量统计上来看，目前二手房市场上比较火热的区域。海淀区和朝阳区二手房数量最多，差不多都接近3000套，毕竟大区，需求量也大。然后是丰台区，近几年正在改造建设，有赶超之势。 二手房总价：通过箱型图看到，各大区域房屋总价中位数都都在1000万以下，且房屋总价离散值较高，西城最高达到了6000万，说明房屋价格特征不是理想的正太分布。 Size特征分析f, [ax1,ax2] = plt.subplots(1, 2, figsize=(15, 5)) # 建房时间的分布情况 sns.distplot(df[&#39;Size&#39;], bins=20, ax=ax1, color=&#39;r&#39;) sns.kdeplot(df[&#39;Size&#39;], shade=True, ax=ax1) # 建房时间和出售价格的关系 sns.regplot(x=&#39;Size&#39;, y=&#39;Price&#39;, data=df, ax=ax2) plt.show() 复制代码 Size 分布： 通过 distplot 和 kdeplot 绘制柱状图观察 Size 特征的分布情况，属于长尾类型的分布，这说明了有很多面积很大且超出正常范围的二手房。 Size 与 Price 的关系： 通过 regplot 绘制了 Size 和 Price 之间的散点图，发现 Size 特征基本与Price呈现线性关系，符合基本常识，面积越大，价格越高。但是有两组明显的异常点：1. 面积不到10平米，但是价格超出10000万；2. 一个点面积超过了1000平米，价格很低，需要查看是什么情况。 df.loc[df[&#39;Size&#39;]&lt; 10] 复制代码 经过查看发现这组数据是别墅，出现异常的原因是由于别墅结构比较特殊（无朝向无电梯），字段定义与二手商品房不太一样导致爬虫爬取数据错位。也因别墅类型二手房不在我们的考虑范围之内，故将其移除再次观察Size分布和Price关系。 df.loc[df[&#39;Size&#39;]&gt;1000] 复制代码 经观察这个异常点不是普通的民用二手房，很可能是商用房，所以才有1房间0厅确有如此大超过1000平米的面积，这里选择移除。 df = df[(df[&#39;Layout&#39;]!=&#39;叠拼别墅&#39;)&amp;(df[&#39;Size&#39;]&lt;1000)] 复制代码 重新进行可视化发现就没有明显的异常点了。 Layout特征分析f, ax1= plt.subplots(figsize=(20,20)) sns.countplot(y=&#39;Layout&#39;, data=df, ax=ax1) ax1.set_title(&#39;房屋户型&#39;,fontsize=15) ax1.set_xlabel(&#39;数量&#39;) ax1.set_ylabel(&#39;户型&#39;) plt.show() 复制代码 这个特征真是不看不知道，各种厅室组合搭配，竟然还有9室3厅，4室0厅等奇怪的结构。其中，2室一厅占绝大部分，其次是3室一厅，2室2厅，3室两厅。但是仔细观察特征分类下有很多不规则的命名，比如2室一厅与2房间1卫，还有别墅，没有统一的叫法。这样的特征肯定是不能作为机器学习模型的数据输入的，需要使用特征工程进行相应的处理。 Renovation 特征分析df[&#39;Renovation&#39;].value_counts() 复制代码精装 11345 简装 8497 其他 3239 毛坯 576 南北` `20Name: Renovation, dtype: int64 发现Renovation装修特征中竟然有南北，它属于朝向的类型，可能是因为爬虫过程中一些信息位置为空，导致“Direction”朝向特征出现在这里，所以需要清除或替换掉。 # 去掉错误数据“南北”，因为爬虫过程中一些信息位置为空，导致“Direction”的特征出现在这里，需要清除或替换 df[&#39;Renovation&#39;] = df.loc[(df[&#39;Renovation&#39;] != &#39;南北&#39;), &#39;Renovation&#39;] # 画幅设置 f, [ax1,ax2,ax3] = plt.subplots(1, 3, figsize=(20, 5)) sns.countplot(df[&#39;Renovation&#39;], ax=ax1) sns.barplot(x=&#39;Renovation&#39;, y=&#39;Price&#39;, data=df, ax=ax2) sns.boxplot(x=&#39;Renovation&#39;, y=&#39;Price&#39;, data=df, ax=ax3) plt.show() 复制代码 观察到，精装修的二手房数量最多，简装其次，也是我们平日常见的。而对于价格来说，毛坯类型却是最高，其次是精装修。 Elevator 特征分析初探数据的时候，我们发现 Elevator 特征是有大量缺失值的，这对于我们是十分不利的，首先我们先看看有多少缺失值： misn = len(df.loc[(df[&#39;Elevator&#39;].isnull()), &#39;Elevator&#39;]) print(&#39;Elevator缺失值数量为：&#39;+ str(misn)) 复制代码Elevator 缺失值数量为：8237 这么多的缺失值怎么办呢？这个需要根据实际情况考虑，常用的方法有平均值/中位数填补法，直接移除，或者根据其他特征建模预测等。 这里我们考虑填补法，但是有无电梯不是数值，不存在平均值和中位数，怎么填补呢？这里给大家提供一种思路：就是根据楼层 Floor 来判断有无电梯，一般的楼层大于6的都有电梯，而小于等于6层的一般都没有电梯。有了这个标准，那么剩下的就简单了。 # 由于存在个别类型错误，如简装和精装，特征值错位，故需要移除 df[&#39;Elevator&#39;] = df.loc[(df[&#39;Elevator&#39;] == &#39;有电梯&#39;)|(df[&#39;Elevator&#39;] == &#39;无电梯&#39;), &#39;Elevator&#39;] # 填补Elevator缺失值 df.loc[(df[&#39;Floor&#39;]&gt;6)&amp;(df[&#39;Elevator&#39;].isnull()), &#39;Elevator&#39;] = &#39;有电梯&#39; df.loc[(df[&#39;Floor&#39;]&lt;=6)&amp;(df[&#39;Elevator&#39;].isnull()), &#39;Elevator&#39;] = &#39;无电梯&#39; f, [ax1,ax2] = plt.subplots(1, 2, figsize=(20, 10)) sns.countplot(df[&#39;Elevator&#39;], ax=ax1) ax1.set_title(&#39;有无电梯数量对比&#39;,fontsize=15) ax1.set_xlabel(&#39;是否有电梯&#39;) ax1.set_ylabel(&#39;数量&#39;) sns.barplot(x=&#39;Elevator&#39;, y=&#39;Price&#39;, data=df, ax=ax2) ax2.set_title(&#39;有无电梯房价对比&#39;,fontsize=15) ax2.set_xlabel(&#39;是否有电梯&#39;) ax2.set_ylabel(&#39;总价&#39;) plt.show() 复制代码 结果观察到，有电梯的二手房数量居多一些，毕竟高层土地利用率比较高，适合北京庞大的人群需要，而高层就需要电梯。相应的，有电梯二手房房价较高，因为电梯前期装修费和后期维护费包含内了（但这个价格比较只是一个平均的概念，比如无电梯的6层豪华小区当然价格更高了）。 Year 特征分析grid = sns.FacetGrid(df, row=&#39;Elevator&#39;, col=&#39;Renovation&#39;, palette=&#39;seismic&#39;,size=4) grid.map(plt.scatter, &#39;Year&#39;, &#39;Price&#39;) grid.add_legend() 复制代码 在Renovation和Elevator的分类条件下，使用 FaceGrid 分析 Year 特征，观察结果如下： 整个二手房房价趋势是随着时间增长而增长的； 2000年以后建造的二手房房价相较于2000年以前有很明显的价格上涨； 1980年之前几乎不存在有电梯二手房数据，说明1980年之前还没有大面积安装电梯； 1980年之前无电梯二手房中，简装二手房占绝大多数，精装反而很少； Floor 特征分析f, ax1= plt.subplots(figsize=(20,5)) sns.countplot(x=&#39;Floor&#39;, data=df, ax=ax1) ax1.set_title(&#39;房屋户型&#39;,fontsize=15) ax1.set_xlabel(&#39;数量&#39;) ax1.set_ylabel(&#39;户型&#39;) plt.show() 复制代码 可以看到，6层二手房数量最多，但是单独的楼层特征没有什么意义，因为每个小区住房的总楼层数都不一样，我们需要知道楼层的相对意义。另外，楼层与文化也有很重要联系，比如中国文化七上八下，七层可能受欢迎，房价也贵，而一般也不会有4层或18层。当然，正常情况下中间楼层是比较受欢迎的，价格也高，底层和顶层受欢迎度较低，价格也相对较低。所以楼层是一个非常复杂的特征，对房价影响也比较大。 总结存在问题： 解决爬虫获取的数据源准确度问题； 需要爬取或者寻找更多好的售房特征； 需要做更多地特征工程工作，比如数据清洗，特征选择和筛选； 使用统计模型建立回归模型进行价格预测；","categories":[{"name":"大数据","slug":"大数据","permalink":"https://www.iamys.club/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据 python爬虫","slug":"大数据-python爬虫","permalink":"https://www.iamys.club/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE-python%E7%88%AC%E8%99%AB/"}]},{"title":"以链家对西安二手房源数据进行数据探索","slug":"大数据","date":"2020-06-19T16:00:00.000Z","updated":"2020-06-20T02:51:33.019Z","comments":true,"path":"2020/06/20/大数据/","link":"","permalink":"https://www.iamys.club/2020/06/20/%E5%A4%A7%E6%95%B0%E6%8D%AE/","excerpt":"","text":"项目简介利用大数据实验环境完成一个真实的项目。以房天下西安站二手房源数据为分析对象，使用用Numpy + Pandas库对数据进行探索性分析。首先通过Pandas对象将其从Excel电子表格中导入到数据框中。然后，对房源数据进行清洗。最后，对各关键字段字段进行相应的可视化处理。 项目完整流程（1）项目目的本项目旨在解决以下三个问题： （a）西安市所辖六区范围内，二手房房源的整体特点是什么？ （b）影响西安市所辖六区范围内的二手房价格的主要因素有哪些？ （c）在西安市所辖六区范围内，容易受到人们青睐的二手房具有什么样的特点？ （2）数据的采集在采集的过程中，由于房天下默认只显示3000条数据，为了采集到所有的目标数据，笔者是在房天下开始页面上设置了筛选条件后，用八爪鱼采集器分批次对房天下上所有的目标数据进行的采集，最终一共采集到了20027条数据。 （3）数据的预处理笔者是用Excel 2010这个工具对八爪鱼采集器采集到的脏数据进行的清洗，为避免在数据清洗的过程出现对数据的误操作，笔者分批次对采集到的数据进行了清洗，最后再对数据进行汇总。清洗过程中，主要用到了Excel的分列、筛选、删除重复项、查找与替换等功能，逻辑函数if，文本函数clean、trim、len、right、left等以及数组公式。清洗结束后，还剩下17709条数据。 （4）对数据的分析这一过程中用到的工具是Python，涉及到Numpy、matplotlib、pandas、seaborn等Python库，个别地方用到了scipy库。同时，流程中的所有代码都运行于jupyter notebook。 分析流程如下： # 导入整个分析过程中可能要用到的库 %matplotlib notebook import numpy as np import pandas as pd import matplotlib import matplotlib.pyplot as plt import seaborn as sns sns.set_style() # 恢复seaborn包绘图的默认主题# 导入二手房数据 data = pd.read_excel(&#39;二手房数据.xlsx&#39;,&#39;Sheet1&#39;,encoding=&#39;UTF8&#39;) data.info() # 查看data的信息data的信息如下图所示： new_data = data.dropna(axis=0, how=&#39;any&#39;, inplace=False) # 删除含有缺失值的行 new_data.info() #查看new_data的信息new_data的信息如下图所示 new_data.head() # 查看new_data中的前五条数据new_data的前五条数据如下图所示： 1）二手房源房源整体特点分析：# 防止绘制的图形中出现中文乱码问题,进行如下设置 from pylab import mpl mpl.rcParams[&#39;font.sans-serif&#39;] = [&#39;FangSong&#39;] # 指定默认字体 mpl.rcParams[&#39;axes.unicode_minus&#39;] = False # 解决保存图像是负号&#39;-&#39;显示为方块的问题 # 构造一个自动绘制并保存饼形图的函数： def pie_plot(data,title,x): # pie_plot函数参数说明 # data是绘制饼图的数据,title是饼图的标题,x是保存饼图图片时图片的名字 fig,axes=plt.subplots(2,2) data[0].plot(kind=&#39;pie&#39;,ax=axes[0,0],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) data[1].plot(kind=&#39;pie&#39;,ax=axes[0,1],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) data[2].plot(kind=&#39;pie&#39;,ax=axes[1,0],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) data[3].plot(kind=&#39;pie&#39;,ax=axes[1,1],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) # autopct参数的作用是指定饼形图中数据标签的显示方式 # &#39;%.1f%%&#39;表示数据标签的格式是保留一位小数的百分数 # startangle=90表示饼图的起始绘制角度是偏离x轴90度，并按逆时针绘制 # label=&#39;&#39;后，饼形图的左边便不会再显示Series对象的名字 axes[0,0].set_aspect(&#39;equal&#39;) # 设置饼图1的纵横比相等 axes[0,0].set_title(&#39;{}&#39;.format(title[0])) # 设置饼图1的标题 axes[0,1].set_aspect(&#39;equal&#39;) # 设置饼图2的纵横比相等 axes[0,1].set_title(&#39;{}&#39;.format(title[1])) # 设置饼图2的标题 axes[1,0].set_aspect(&#39;equal&#39;) # 设置饼图3的纵横比相等 axes[1,0].set_title(&#39;{}&#39;.format(title[2])) # 设置饼图3的标题 axes[1,1].set_aspect(&#39;equal&#39;) # 设置饼图4的纵横比相等 axes[1,1].set_title(&#39;{}&#39;.format(title[3])) # 设置饼图4的标题 plt.subplots_adjust(wspace=0.2,hspace=0.2) # 设置figure对象中子图的间距 plt.rc(&#39;figure&#39;, figsize=(8, 6)) # 设置图片的大小 plt.savefig(&#39;{}.png&#39;.format(x)) # 保存图片分别统计二手房 的所在区域、户型、朝向、装修情况： # 处理不同区域的房屋数据: count_by_region = new_data[&#39;所在区&#39;].groupby(new_data[&#39;所在区&#39;]).count() # 对不同区域中的房屋进行分组统计： # 处理房屋的户型数据: count_by_house_type = new_data[&#39;户型&#39;].groupby(new_data[&#39;户型&#39;]).count()# 对不同户型的房屋进行分组统计： count_by_house_type.sort_values(ascending=False,inplace=True) # 将不同户型房屋的计数结果按降序排序 # 将总数在800以下的户型统一归为其他类: new_count_by_house_type = count_by_house_type[count_by_house_type &gt; 800] new_count_by_house_type[&#39;其他&#39;] = count_by_house_type[count_by_house_type &lt; 800].sum() # 处理房屋的朝向数据： count_by_orientation = data[&#39;朝向&#39;].groupby(data[&#39;朝向&#39;]).count() # 对不同朝向的房屋进行分组统计： count_by_orientation.sort_values(ascending=False,inplace=True) # 将不同朝向房屋的计数结果按降序排序 # 将总数在500以下的朝向统一归类为其他： new_count_by_orientation = count_by_orientation[count_by_orientation &gt; 500] new_count_by_orientation[&#39;其他&#39;] = count_by_orientation[count_by_orientation &lt; 500].sum() # 处理房屋装修情况的数据： count_by_decoration = new_data[&#39;装修&#39;].groupby(new_data[&#39;装修&#39;]).count() # 对不同装修的房屋进行分组统计： count_by_decoration.sort_values(ascending=False,inplace=True) # 将不同装修房屋的计数结果按降序排序 # 调用pie_plot函数绘制不同区域、不同户型、不同朝向和不同装修的饼形图： d1 = [count_by_region,new_count_by_house_type,new_count_by_orientation,count_by_decoration] t1 = [&#39;不同区域房屋占比饼形图&#39;,&#39;不同户型房屋占比饼形图&#39;,&#39;不同朝向房屋占比饼形图&#39;,&#39;不同装修房屋占比饼形图&#39;] x1 = &#39;p1&#39; pie_plot(d1,t1,x1)结果如下图所示： 从此图中我们可以看到： （1）在西安市所辖的六个区中，工业园区的房源数量最多接近30%，其次便是占比24%的姑苏区和占比接近22%的吴中区，而吴江区的房源数量最少，仅占不到3%。 （2）在所有的户型中，三室两厅的户型占比最多达到38%，其次是两室两厅达到了21%。 （3）所有房源里，房屋朝向为南北朝向的房子占据了90%以上，由此可见相比其他朝向，人们更加喜欢南北朝向的房子。 （4）在所有清晰表明了装修情况的二手房中，超过一半的二手房是精装修的，毛坯房与简装房的占比则相差不多，都在7%左右。 分别统计二手房的楼层位置和电梯安装情况： # 处理房屋的楼层位置数据： count_by_floor_position = new_data[&#39;楼层&#39;].groupby(new_data[&#39;楼层&#39;]).count() # 对位于不同楼层的房屋数量进行分组统计 # 处理房屋电梯安装情况的数据： count_by_elevator = new_data[&#39;电梯&#39;].groupby(new_data[&#39;电梯&#39;]).count() # 对电梯安装情况不同的房屋进行分组统计 # 绘制处于不同楼层位置和电梯安装情况不同的房屋占比饼形图： fig,axes = plt.subplots(1,2) count_by_floor_position.plot(kind=&#39;pie&#39;,ax=axes[0],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) count_by_elevator.plot(kind=&#39;pie&#39;,ax=axes[1],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) # autopct参数的作用是指定饼形图中数据标签的显示方式 # &#39;%.1f%%&#39;表示数据标签的格式是保留一位小数的百分数 # startangle=90表示饼图的起始绘制角度是偏离x轴90度，并按逆时针绘制 # label=&#39;&#39;后，饼形图的左边便不会再显示Series对象的名字 axes[0].set_aspect(&#39;equal&#39;) # 设置饼形图的纵横比相等 axes[0].set_title(&#39;位于不同楼层的房屋占比饼形图&#39;) # 设置饼形图的标题 axes[1].set_aspect(&#39;equal&#39;) axes[1].set_title(&#39;电梯安装情况不同的房屋占比饼形图&#39;) plt.savefig(&#39;p2.png&#39;) # 保存图片结果如下图所示： 从此图我们可以看到： （1）位于高楼层的二手房数量最多达到了43%，其次是中楼层有32%，位于低楼层二手房数量最少为25%，但三者差别不是特别大. （2）在所有的二手房中，安装了电梯的二手房数量接近没安装电梯的二手房数量的两倍。 统计靠近地铁站的二手房占比情况： # 处理房屋是否近地铁的数据： count_by_subway = new_data[&#39;近地铁&#39;].groupby(new_data[&#39;近地铁&#39;]).count() # 对房屋是否靠近地铁站进行分组统计 # 绘制靠近地铁站的房屋占比饼形图： fig,axes = plt.subplots(figsize=(6,4)) # figsize参数指定生成图片的大小 count_by_subway.plot(kind=&#39;pie&#39;,ax=axes,autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) # autopct参数的作用是指定饼形图中数据标签的显示方式 # &#39;%.1f%%&#39;表示数据标签的格式是保留一位小数的百分数 # startangle=90表示饼图的起始绘制角度是偏离x轴90度，并按逆时针绘制 # label=&#39;&#39;后，饼形图的左边便不会再显示Series对象的名字 axes.set_aspect(&#39;equal&#39;) # 设置饼形图的纵横比相等 axes.set_title(&#39;靠近地铁站的房屋占比饼形图&#39;) # 设置饼形图的标题 plt.savefig(&#39;p3.png&#39;) # 保存图片 结果如下图所示： 统计二手房所在楼总楼层数的分布情况： # 处理房源所在楼总楼层位置数据： count_by_floor_number = new_data[&#39;总楼层数&#39;].groupby(new_data[&#39;总楼层数&#39;]).count() # 根据不同总楼层数进行分组计数 count_by_floor_number.sort_index(inplace=True) # 按照索引值的大小将分组计数的结果升序排序 # 根据count_by_floor_number的索引值将数据分成11层以下、11-20层、20-30层和30层以上四组，并分组计数 count_by_floor_number1 = count_by_floor_number.loc[1:10].sum() count_by_floor_number2 = count_by_floor_number.loc[10:20].sum() count_by_floor_number3 = count_by_floor_number.loc[20:30].sum() count_by_floor_number4 = count_by_floor_number.loc[30:].sum() new_count_by_floor_number = pd.Series([count_by_floor_number1,count_by_floor_number2, count_by_floor_number3,count_by_floor_number4], index=[&#39;11层以下&#39;,&#39;11-20层&#39;,&#39;21-30层&#39;,&#39;30层以上&#39;]) # 绘制房源所在楼不同楼层总数占比饼形图和不同楼层总数频数分布条形图： # 绘制条形图 fig,axes = plt.subplots(1,2) new_count_by_floor_number.plot.barh(ax=axes[0],alpha=0.7) # alpha参数指定图像的透明度 axes[0].set(xlabel=&#39;频数&#39;,ylabel=&#39;总楼层数&#39;,title=&#39;楼层总数频数分布条形图&#39;) # 设置条形图的标题和坐标轴标签 # 给条形图添加数值标签 x = np.arange(len(new_count_by_floor_number)) y = new_count_by_floor_number.values for a,b in zip(x,y): axes[0].text(x=b-1000,y=a,s=b,ha=&#39;center&#39;, va= &#39;center&#39;) # ha参数和va参数分别指定数值标签水平对齐与垂直对齐的方式 # 绘制饼形图 new_count_by_floor_number.plot(kind=&#39;pie&#39;,ax=axes[1],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) # autopct参数的作用是指定饼形图中数据标签的显示方式 # &#39;%.1f%%&#39;表示数据标签的格式是保留一位小数的百分数 # startangle=90表示饼图的起始绘制角度是偏离x轴90度，并按逆时针绘制 # label=&#39;&#39;后，饼形图的左边便不会再显示Series对象的名字 axes[1].set_title(&#39;不同楼层总数占比饼形图&#39;) # 设置饼图的标题 axes[1].set_aspect(&#39;equal&#39;) # 设置饼形图的纵横比相等 plt.savefig(&#39;p4.png&#39;) # 保存图片结果如下图所示： 从此图我们可以看到，在所有的二手房中，有接近50%的房子所在楼的总楼层数是11层以下，其次是11层-20层之间，占比24%，而所在楼的楼层总数超过20层的二手房占比大约28%。 绘制二手房的数量随其建造时间变化的折线图，并统计二手房建造时间的分布： new_data[&#39;建造时间&#39;].unique() # 查看房屋建造时间中的非重复值 # 输出结果： # array([2013., 2014., 2010., 2006., 2018., 2017., 2002., 2015., 2004., # 2011., 2005., 2016., 2001., 2007., 2012., 1995., 1998., 2008., # 2003., 2009., 2000., 1993., 1999., 1996., 1997., 1994., 1992., # 1988., 1990., 1991., 1989., 1980., 1986., 1982., 1985., 1983., # 1978., 1984., 1979., 1981., 1987., 1972.])# 处理房屋的建造时间数据： count_by_create_time = new_data[&#39;建造时间&#39;].groupby(new_data[&#39;建造时间&#39;]).count() # 对不同时间建造的房屋进行分组统计 # 将房屋建造时间分成2000年及以前、2001-2005年、2006-2010年、2011-2015年、2016年及以后这五组数据,并分组计数 count_by_create_time1 = count_by_create_time.loc[:2000].sum() count_by_create_time2 = count_by_create_time.loc[2001:2005].sum() count_by_create_time3 = count_by_create_time.loc[2006:2010].sum() count_by_create_time4 = count_by_create_time.loc[2011:2015].sum() count_by_create_time5 = count_by_create_time.loc[2016:].sum() new_count_by_create_time = pd.Series([count_by_create_time1,count_by_create_time2,count_by_create_time3, count_by_create_time4,count_by_create_time5], index=[&#39;2000年及以前&#39;,&#39;2001-2005年&#39;,&#39;2006-2010年&#39;,&#39;2011-2015年&#39;,&#39;2016年及以后&#39;]) # 绘制房屋的数量随着建造时间变化而变化的折线图和不同建造时间范围内房屋占比饼形图： # 绘制折线图 fig,axes = plt.subplots(1,2) count_by_create_time.plot(kind=&#39;line&#39;,ax=axes[0]) axes[0].set(xlabel=&#39;房屋建造时间/年&#39;,ylabel=&#39;二手房数量/套&#39;, title=&#39;二手房数量随房屋建造时间变化折线图&#39;, xticks=[1970,1980,1990,2000,2010,2018]) # 设置折线图标题、坐标轴标签和x轴上的数值标签 # 绘制饼形图 new_count_by_create_time.plot(kind=&#39;pie&#39;,ax=axes[1],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) # autopct参数的作用是指定饼形图中数据标签的显示方式 # &#39;%.1f%%&#39;表示数据标签的格式是保留一位小数的百分数 # startangle=90表示饼图的起始绘制角度是偏离x轴90度，并按逆时针绘制 # label=&#39;&#39;后，饼形图的左边便不会再显示Series对象的名字 axes[1].set_title(&#39;不同建造时间范围内房屋占比饼形图&#39;) # 设置饼形图的标题 axes[1].set_aspect(&#39;equal&#39;) # 设置饼形图的纵横比相等 plt.subplots_adjust(wspace=0.3) # 设置figure对象中子图的间距 plt.savefig(&#39;p5.png&#39;) # 保存图片结果如下图所示： 由此图我们可以看到： （1）总体趋势上，随着建造时间距离现在越来越近，二手房的数量逐年增加。 （2）在所有的二手房中，建造时间在2011-2015年这个范围内的二手房占比最大，达到了34%，其次便是2006-2010年。70%左右的二手房的建造时间距今不超过12年。 查看二手房面积的分布特点： new_data[&#39;面积&#39;].describe() # 查看房屋面积的统计信息 # 输出结果为： # count 16548.000000 # mean 108.057752 # std 41.223922 # min 15.600000 # 25% 83.600000 # 50% 100.440000 # 75% 130.115000 # max 611.000000 # Name: 面积, dtype: float64# 绘制整体房源面积的频率分布直方图： from scipy.stats import norm fig,axes = plt.subplots() sns.distplot(new_data[&#39;面积&#39;],bins=50,kde=False,fit=norm,ax=axes) # fit=norm意味着用正态分布密度函数拟合频率分布直方图 axes.set(xlabel=&#39;面积/平米&#39;,ylabel=&#39;概率密度&#39;,title=&#39;二手房面积频率分布直方图&#39;) # 设置直方图的x轴标签、y轴标签以及直方图的标题 plt.savefig(&#39;p6.png&#39;) # 指定图片的分辨率并保存图片结果如下图所示： 从此图上我们可以看到，二手房的面积分布大致符合正态分布。根据经验法则，对于具有钟形分布的数据，大约有%68的数据值与平均数的距离在一个标准差以内， 据此可计算这%68数据值的范围： min_area = new_data[&#39;面积&#39;].mean() - new_data[&#39;面积&#39;].std() max_area = new_data[&#39;面积&#39;].mean() + new_data[&#39;面积&#39;].std() print(min_area,max_area) # 输出结果为： # 66.83382998449979 149.2816740038976由此可以大概推断，西安市所辖六区范围内，70%上的二手房房屋面积在50-150平米之间，30%以下的二手房房屋面积小于50平米或者大于150平米。 new_data[&#39;售价&#39;].describe() # 查看二手房售价的统计信息 # 输出结果为： # count 16548.000000 # mean 271.881526 # std 141.929135 # min 30.000000 # 25% 178.000000 # 50% 245.000000 # 75% 337.000000 # max 1350.000000 # Name: 售价, dtype: float64 new_data[&#39;单价&#39;].describe() # 查看二手房单价的统计信息 # 输出结果为： # count 16548.000000 # mean 24870.346447 # std 8945.916620 # min 6742.000000 # 25% 18939.750000 # 50% 22265.000000 # 75% 28961.500000 # max 81250.000000 # Name: 单价, dtype: float64# 绘制整体房源的售价分布直方图和单价分布直方图： fig,axes = plt.subplots(1,2) sns.distplot(new_data[&#39;售价&#39;],bins=50,kde=False,fit=norm,ax=axes[0]) sns.distplot(new_data[&#39;单价&#39;],bins=50,kde=False,fit=norm,ax=axes[1]) # 设置直方图的x轴标签、y轴标签以及直方图的标题 axes[0].set(xlabel=&#39;售价/万&#39;,ylabel=&#39;概率密度&#39;) axes[1].set(xlabel=&#39;单价/元每平米&#39;,ylabel=&#39;概率密度&#39;) fig.suptitle(&#39;二手房的售价和单价频率分布直方图&#39;) plt.subplots_adjust(wspace=0.4) # 设置figure对象中两子图的间距 plt.savefig(&#39;p7.png&#39;) # 保存图片结果如下图所示： 同样，从此图上我们可以看到，二手房的售价分布和单价分布大致符合正态分布。根据经验法则，对于具有钟形分布的数据，大约有%68的数据值与平均数的距离在一个标准差以内， 据此可计算这%68数据值的范围 min_price = new_data[&#39;售价&#39;].mean() - new_data[&#39;售价&#39;].std() max_price = new_data[&#39;售价&#39;].mean() + new_data[&#39;售价&#39;].std() print(min_price,max_price) # 输出结果为： # 129.95239171070799 413.8106612262028 min_average_price = new_data[&#39;单价&#39;].mean() - new_data[&#39;单价&#39;].std() max_average_price = new_data[&#39;单价&#39;].mean() + new_data[&#39;单价&#39;].std() print(min_average_price,max_average_price) # 输出结果为： # 15924.429826650296 33816.26306675072由此可以推断，苏州市所辖六区范围内70%以上的二手房的售价在100-450万之间，30%以下的二手房售价在小于100万或者大于450万，65%以上的二手房的单价在15000-35000每平米之间，35%以下的二手房的单价小于15000每平米或者大于35000每平米。 2）探究影响二手房价格的主要因素有哪些？查看房源所处地区对其价格的影响： 首先比较不同区域内二手房的售价： fig,axes = plt.subplots(figsize=(6,4)) sns.boxplot(x=&#39;所在区&#39;,y=&#39;售价&#39;,data=new_data,orient=&#39;v&#39;,ax=axes) axes.set(ylabel=&#39;售价/万&#39;,title=&#39;不同区内二手房售价箱形图&#39;) plt.savefig(&#39;p8.png&#39;) # 保存图片结果如下图所示： 由此图我们可以看到，六区中，工业园区的二手房售价明显比其他五个区的高，除此之外，除了工业园区，其他五区中二手房的售价都出现了高出正常值范围的异常值，相城区还出现了售价过低的二手房。 再比较不同区域内二手房的单价： fig,axes = plt.subplots(figsize=(6,4)) sns.boxplot(x=&#39;所在区&#39;,y=&#39;单价&#39;,data=new_data,orient=&#39;v&#39;,ax=axes) axes.set(ylabel=&#39;单价/元没平米&#39;,title=&#39;不同区内二手房单价箱形图&#39;) plt.savefig(&#39;p9.png&#39;) # 保存图片结果如下图所示： 从此图中我们可以看到工业园区内的二手房单价明显比其他五个区的高，吴江区整体上的二手房单价在六个区中是最低的。在所有的六个区中，都出现了单价过高或者过低的二手房。 下面用另一幅更具体的图来描述各区之间二手房价格的差异： # 计算处于不同区的二手房售价的均值： average_price_grouped_by_region = new_data[&#39;售价&#39;].groupby(new_data[&#39;所在区&#39;]).mean() # 计算处于不同区的二手房售价的均值 average_price_grouped_by_region.sort_values(ascending=True,inplace=True) # 将计算结果按照升序排序 # 计算处于不同区的二手房单价的均值： average_unit_price_grouped_by_region = new_data[&#39;单价&#39;].groupby(new_data[&#39;所在区&#39;]).mean() # 计算处于不同区的二手房售价的均值 average_unit_price_grouped_by_region.sort_values(ascending=True,inplace=True) # 将计算结果按照升序排序 # 绘制不同区的二手房售价均值和单价均值条形图： fig,axes = plt.subplots(1,2) # 绘制售价均值条形图1 average_price_grouped_by_region.plot.bar(ax=axes[0],alpha=0.7) axes[0].set(ylabel=&#39;售价均值/万&#39;) # 给条形图1添加数值标签 x1 = np.arange(len(average_price_grouped_by_region)) y1 = average_price_grouped_by_region.values for a,b in zip(x1,y1): axes[0].text(x=a,y=b+5,s=&#39;%.f&#39;%b,ha=&#39;center&#39;, va= &#39;center&#39;) # ha参数和va参数分别指定数值标签水平对齐与垂直对齐的方式 # 绘制单价均值条形图2 average_unit_price_grouped_by_region.plot.bar(ax=axes[1],alpha=0.7) axes[1].set(ylabel=&#39;单价均值/元每平米&#39;) # 给条形图2添加数值标签 x2 = np.arange(len(average_unit_price_grouped_by_region)) y2 = average_unit_price_grouped_by_region.values for c,d in zip(x2,y2): axes[1].text(x=c,y=d+500,s=&#39;%.f&#39;%d,ha=&#39;center&#39;, va= &#39;center&#39;) fig.suptitle(&#39;不同区内二手房售价均值和单价均值条形图&#39;) plt.subplots_adjust(wspace=0.4) # 设置figure对象中两子图的间距 plt.savefig(&#39;p10.png&#39;,dpi=300) # 指定生成图片的分辨率并保存图片结果如下图所示： 从上图我们可以看到工业园区的二手房，其售价比其他区的二手房都要高100万左右，而单价则比其他区的二手房要高10000元左右。 接下来，找出六区范围内房价最高的前十个具体地段与工业园区范围内房价最高的前十个具体地段，然后对两者进行比较： # 找出六个区范围内二手房单价均值最高的前十个地段 ten_highest_unit_price_all = new_data[&#39;单价&#39;].groupby(new_data[&#39;大概位置&#39;]).mean().sort_values(ascending=False).iloc[:10] # 找出工业园区范围内二手房单价最高的前是个地段 changed_data = new_data.set_index([&#39;所在区&#39;]) # 将new_data中的所在区这一列指定为新数据的索引 data_of_gongyeyuanqu = changed_data.loc[&#39;工业园区&#39;] # 筛选出工业园区的数据 # 筛选出房价最高的前是个地段 ten_highest_unit_price_gongyeyuanqu = data_of_gongyeyuanqu[&#39;单价&#39;].groupby(data_of_gongyeyuanqu[&#39;大概位置&#39;]).mean().sort_values(ascending=False).iloc[:10] print(list(ten_highest_unit_price_all.index)) print(list(ten_highest_unit_price_gongyeyuanqu.index)) # 输出结果为： # [&#39;玲珑&#39;, &#39;白塘&#39;, &#39;湖西CBD&#39;, &#39;双湖&#39;, &#39;东沙湖&#39;, &#39;湖东&#39;, &#39;湖东CBD&#39;, &#39;独墅湖高教区&#39;, &#39;平江路&#39;, &#39;十全街&#39;] # [&#39;玲珑&#39;, &#39;白塘&#39;, &#39;湖西CBD&#39;, &#39;双湖&#39;, &#39;东沙湖&#39;, &#39;湖东&#39;, &#39;湖东CBD&#39;, &#39;独墅湖高教区&#39;, &#39;斜塘&#39;, &#39;青剑湖&#39;]从输出结果我们可以发现，在所有区范围内找出的二手房单价均值最高的前十个地段，其中前八个地段是位于工业园区的。 查看具体地段对价格的影响： 先看具体地段对售价的影响： count_by_location = new_data[&#39;大概位置&#39;].groupby(new_data[&#39;大概位置&#39;]).count() # 按照房源所处地段进行分组计数 count_by_location.sort_values(ascending=True,inplace=True) # 把计数结果按照升序排序 new_count_by_location = count_by_location[count_by_location &gt; 400] # 选出房源数量在400套以上的大概位置数据 # 计算不同地段二手房售价的均值 locations1 = list(new_count_by_location.index) # locations1代表的是房源数量在400套以上的地段 average_price_grouped_by_location = new_data[&#39;售价&#39;].groupby(new_data[&#39;大概位置&#39;]).mean() # 计算不同位置的二手房售价的平均值 new_average_price_grouped_by_location = average_price_grouped_by_location[locations1] # 筛选出数量在400套以上的房屋售价的均值 new_average_price_grouped_by_location.sort_values(ascending=True,inplace=True) # 将筛选出来的数据按照升序排序 # 绘制不同地段二手房售价均值的条形分布图： fig,axes = plt.subplots(figsize=(7,5) new_average_price_grouped_by_location.plot.barh(ax=axes,alpha=0.7) axes.set(xlabel=&#39;售价均值/万&#39;,ylabel=&#39;所处地段&#39;,title=&#39;不同地段二手房售价均值条形图&#39;, xticks=[0,50,100,150,200,250,300,350,400,450]) # 给条形图添加数值标签 x = np.arange(len(new_average_price_grouped_by_location)) y = new_average_price_grouped_by_location.values for a,b in zip(x,y): axes.text(x=b+15,y=a,s=&#39;%.2f&#39;%b,ha=&#39;center&#39;, va= &#39;center&#39;) # ha参数和va参数分别指定数值标签水平对齐与垂直对齐的方式 plt.savefig(&#39;p11.png&#39;) # 保存图片结果如下图所示： # 计算不同地段二手房单价的均值： average_unit_price_grouped_by_location = new_data[&#39;单价&#39;].groupby(new_data[&#39;大概位置&#39;]).mean() # 计算不同位置的二手房单价的平均值 new_average_unit_price_grouped_by_location = average_unit_price_grouped_by_location[locations1] # 筛选出数量在400套以上的房屋单价的均值 new_average_unit_price_grouped_by_location.sort_values(ascending=True,inplace=True) # 将筛选出来的数据按照升序排序 # 绘制不同地段二手房单价均值的条形图： fig,axes = plt.subplots(figsize=(7,5)) new_average_unit_price_grouped_by_location.plot.barh(ax=axes,alpha=0.7) axes.set(xlabel=&#39;单价均值/元每平米&#39;,ylabel=&#39;所处地段&#39;,title=&#39;不同地段二手房单价均值条形图&#39;, xticks=[0,5000,10000,15000,20000,25000,30000,35000,40000]) # 设置条形图的标题、坐标轴标签和x轴上的数值标记 # 给条形图添加数值标签 x = np.arange(len(new_average_unit_price_grouped_by_location)) y = new_average_unit_price_grouped_by_location.values for a,b in zip(x,y): axes.text(x=b+1000,y=a,s=&#39;%.f&#39;%b,ha=&#39;center&#39;, va= &#39;center&#39;) # ha参数和va参数分别指定数值标签水平对齐与垂直对齐的方式 plt.savefig(&#39;p12.png&#39;) # 保存图片结果如下图所示： 从上面两幅图中可以看到，在房源数量较多的十个地段中，湖东、湖东CBD和东沙湖这三个地段上二手房的售价和单价，明显比其他七个地段上的要高。 查看房屋朝向对价格的影响： new_count_by_orientation # 输出结果为： # 朝向 # 南 13379 # 南北 2259 # 其他 994 # Name: 朝向, dtype: int64 由上文中不同朝向房屋占比饼形图可知，朝向为南北的房屋占据了所分析数据集的90%以上， 而其他朝向的房屋数量太少。因此，此处不做房屋朝向对房屋价格影响分析。 查看房屋的装修情况对价格的影响： average_price_grouped_by_decoration = new_data[&#39;售价&#39;].groupby(new_data[&#39;装修&#39;]).mean() # 计算不同装修二手房的售价均值 average_price_grouped_by_decoration.sort_values(ascending=False,inplace=True) average_unit_price_grouped_by_decoration = new_data[&#39;单价&#39;].groupby(new_data[&#39;装修&#39;]).mean() # 计算不同装修二手房的单价均值 average_unit_price_grouped_by_decoration.sort_values(ascending=False,inplace=True) # 绘制不同装修情况房屋售价均值与单价均值的条形图： fig,axes = plt.subplots(1,2) # 绘制售价均值条形图 average_price_grouped_by_decoration.plot.bar(ax=axes[0],alpha=0.7,rot=0) axes[0].set(ylabel=&#39;售价均值/万&#39;) # 绘制单价均值条形分布图 average_unit_price_grouped_by_decoration.plot.bar(ax=axes[1],alpha=0.7,rot=0) axes[1].set(ylabel=&#39;单价均值/元每平米&#39;) # 写一个给条形图添加数据标签的函数 def add_data_label(data_name,axes): x = np.arange(len(data_name)) y = data_name.values for a,b in zip(x,y): axes.text(x=a,y=b,s=&#39;%.f&#39;%b,ha=&#39;center&#39;,va= &#39;bottom&#39;) # ha和va参数分别指定数据标签的水平对齐和垂直对其方式 # 给条形图添加数据标签 add_data_label(average_price_grouped_by_decoration,axes[0]) add_data_label(average_unit_price_grouped_by_decoration,axes[1]) fig.suptitle(&#39;不同装修情况下二手房的售价均值和单价均值条形图&#39;) plt.subplots_adjust(wspace=0.4) # 设置figure对象中两子图的间距 plt.savefig(&#39;p13.png&#39;) # 保存图片结果如下图所示： 上图中出现了奇怪的现象：毛坯房的售价均值竟然比精装房和简装房还要高，且毛坯房的单价均值高于简装房的单价均值。 对于毛坯房售价均值大于精装房和简装房售价均值的现象，做出如下猜测：一是数据集中位于好地段的毛坯房占比相对较大；二是数据集中所有毛坯房的面积均值相对较大；三是数据集中建造时间离现在较近的毛坯房的占比相对较大；四是数据集中靠近地铁的毛坯房的占比相对较大。 对于毛坯房的单价均值高于简装房的单价均值，做如下猜测： 一是数据集中位于好地段的毛坯房占比相对较大； 二是数据集中建造时间离现在较近的毛坯房的占比相对较大； 三数据集中靠近地铁的毛坯房的占比相对较大。 下面对上述猜测进行检验： count_by_region_and_decoration = new_data.pivot_table(&#39;售价&#39;,index=&#39;所在区&#39;,columns=&#39;装修&#39;,aggfunc=&#39;count&#39;) data1 = count_by_region_and_decoration # 分别统计工业园区和高新区内毛坯房、简装房和精装房的数量 roughcast_gongyeyuan_gaoxin = data1.loc[&#39;工业园区&#39;][&#39;毛坯&#39;] + data1.loc[&#39;高新区&#39;][&#39;毛坯&#39;] # 统计工业园区和高新区内毛坯房的数量 brief_gongyeyuan_gaoxin = data1.loc[&#39;工业园区&#39;][&#39;简装&#39;] + data1.loc[&#39;高新区&#39;][&#39;简装&#39;] # 统计工业园区和高新区内简装房的数量 refined_gongyeyuan_gaoxin = data1.loc[&#39;工业园区&#39;][&#39;精装&#39;] + data1.loc[&#39;高新区&#39;][&#39;精装&#39;] # 统计工业园区和高新区内精装房的数量 #分别统计除了工业园区和高新区之外其他四区内毛坯房、简装房和精装房的数量 roughcast_other = data1[&#39;毛坯&#39;].sum() - roughcast_gongyeyuan_gaoxin brief_other = data1[&#39;简装&#39;].sum() - brief_gongyeyuan_gaoxin refined_other = data1[&#39;精装&#39;].sum() - refined_gongyeyuan_gaoxin count_by_subway_and_decoration = new_data.pivot_table(&#39;售价&#39;,index=&#39;近地铁&#39;,columns=&#39;装修&#39;,aggfunc=&#39;count&#39;) data2 = count_by_subway_and_decoration # 分别统计毛坯房、简装房和精装房中近地铁与不近地铁的房子的数量 roughcast_near_subway = data2.loc[&#39;是&#39;][&#39;毛坯&#39;] # 近地铁的毛坯房的数量 roughcast_away_from_subway = data2.loc[&#39;否&#39;][&#39;毛坯&#39;] # 不近地铁的毛坯房的数量 brief_near_subway = data2.loc[&#39;是&#39;][&#39;简装&#39;] # 近地铁的简装房的数量 brief_away_from_subway = data2.loc[&#39;否&#39;][&#39;简装&#39;] # 不近地铁的简装房的数量 refined_near_subway = data2.loc[&#39;是&#39;][&#39;精装&#39;] # 近地铁的精装房的数量 refined_away_from_subway = data2.loc[&#39;否&#39;][&#39;精装&#39;] # 不地铁的简装房的数量 # 绘制不同情况下的饼形图 fig,axes = plt.subplots(2,3) # 分别绘制毛坯房、简装房和精装房中位于不同区域的房子的占比饼形图 labels1 = [&#39;工业园和高新区&#39;,&#39;其他四区&#39;] axes[0,0].pie([roughcast_gongyeyuan_gaoxin,roughcast_other],labels=labels1,autopct=&#39;%1.1f%%&#39;,startangle=90) axes[0,1].pie([brief_gongyeyuan_gaoxin,brief_other],labels=labels1,autopct=&#39;%1.1f%%&#39;,startangle=90) axes[0,2].pie([refined_gongyeyuan_gaoxin,refined_other],labels=labels1,autopct=&#39;%1.1f%%&#39;,startangle=90) # 分别绘制毛坯房、简装房和精装房中与地铁站距离不同的房子的占比饼形图 labels2 = [&#39;近地铁&#39;,&#39;不近地铁&#39;] axes[1,0].pie([roughcast_near_subway,roughcast_away_from_subway],labels=labels2,autopct=&#39;%1.1f%%&#39;,startangle=90) axes[1,1].pie([brief_near_subway,brief_away_from_subway],labels=labels2,autopct=&#39;%1.1f%%&#39;,startangle=90) axes[1,2].pie([refined_near_subway,refined_away_from_subway],labels=labels2,autopct=&#39;%1.1f%%&#39;,startangle=90) # 分别设置子图的标题以及子图中的饼图的纵横比相等 axes[0,0].set(title=&#39;毛坯房&#39;,aspect=&#39;equal&#39;) axes[0,1].set(title=&#39;简装房&#39;,aspect=&#39;equal&#39;) axes[0,2].set(title=&#39;精装房&#39;,aspect=&#39;equal&#39;) axes[1,0].set(title=&#39;毛坯房&#39;,aspect=&#39;equal&#39;) axes[1,1].set(title=&#39;简装房&#39;,aspect=&#39;equal&#39;) axes[1,2].set(title=&#39;精装房&#39;,aspect=&#39;equal&#39;) plt.subplots_adjust(wspace=0.6,hspace=0) # 设置figure对象中子图的间距 fig.suptitle(&#39;不同类型房屋占比饼形图&#39;) # 设置figure对象的标题 plt.savefig(&#39;p14.png&#39;) # 保存图片结果如下图所示： # 绘制毛坯房、简装房和精装房的面积均值条形图 # 准备数据 average_area_grouped_by_decoration1 = new_data[&#39;面积&#39;].groupby(new_data[&#39;装修&#39;]).mean() average_area_grouped_by_decoration2 = average_area_grouped_by_decoration1[1:] # 筛选出毛坯房、简装房和精装房这三者的数据 average_area_grouped_by_decoration3 = average_area_grouped_by_decoration2.sort_values(ascending=False) # 将筛选出来的数据按照降序排序 new_average_area_grouped_by_decoration = average_area_grouped_by_decoration3 # 绘制条形图 fig,axes = plt.subplots(figsize=(7,5) new_average_area_grouped_by_decoration.plot.bar(ax=axes,alpha=0.8,rot=0) axes.set(ylabel=&#39;面积/平米&#39;,title=&#39;不同装修情况下的二手房的平均面积&#39;) # 调用add_data_label函数给条形图添加数据标签 add_data_label(new_average_area_grouped_by_decoration,axes) plt.savefig(&#39;p15.png&#39;) # 保存图片结果如下图所示： 由以上信息可以判断，与精装房相比，处于房价较高区域的毛坯房占总体的比例和靠近地铁的毛坯房占总体的比例，都小于精装房中相对应的比例；但是毛坯房的整体平均面积要比精装房的整体平均面积大 17平米。这可以合理的解释为什么毛坯房的售价均值稍稍大于精装房，但其单价均值却小于精装房。 与简装房相比，处于房价较高区域的毛坯房占总体的比例略小于简装房中对应的比例，而且靠近地铁站的毛坯房占总体的比例也明显小于简装房中对应的比例，但是为什么毛坯房的售价均值和单价均值都要比简装房的大呢？ 我们已经知道，毛坯房的整体平均面积超出简装房的整体平均面积30平米以上，因此毛坯房的单价均值比简装房的单价均值大一定会导致毛坯房的售价均值比简装房的售价均值大。对于毛坯房的单价均值大于简装房的单价均值，进一步猜测是因为建造时间离现在较近的毛坯房占总体的比例高于简装房中对应的比例，从而导致毛坯房的单价均值高于简装房的单价均值。 接下来对上述猜测结果做进一步检验： decoration_and_create_time1 = new_data.pivot_table(&#39;售价&#39;,index=&#39;建造时间&#39;,columns=&#39;装修&#39;,aggfunc=&#39;count&#39;) decoration_and_create_time2 = decoration_and_create_time1.sort_index(ascending=False) # 按照索引对decoration_and_create_time2进行降序排序 decoration_and_create_time2.fillna(0,inplace=True) # 将数据中的NAN值替换为0 decoration_and_create_time3 = decoration_and_create_time2[[&#39;毛坯&#39;,&#39;简装&#39;]] # 筛选出毛坯房与简装房的数据 decoration_and_create_time4 = decoration_and_create_time3.cumsum(axis=0) # 对new_decoration_and_create_time4中的每列数据进行累计求和操作 decoration_and_create_time4 N1 = decoration_and_create_time4[&#39;毛坯&#39;][2010] # N1是建造时间为2010年以后的毛坯二手房的数量(包括2010年) N2 = decoration_and_create_time4[&#39;毛坯&#39;][1972] - N1 # N2是建造时间为2010年以前的毛坯二手房的数量 N3 = decoration_and_create_time4[&#39;简装&#39;][2010] # N3是建造时间为2010年以后的简装二手房的数量(包括2010年) N4 = decoration_and_create_time4[&#39;简装&#39;][1972] - N3 # N4是建造时间为2010年以前的简装二手房的数量 roughcast_grouped_by_create_time = pd.Series([N1,N2],index=[&#39;2010年以后建造&#39;,&#39;2010年以前建造&#39;]) brief_outfit_grouped_by_create_time = pd.Series([N3,N4],index=[&#39;2010年以后建造&#39;,&#39;2010年以前建造&#39;]) # 分别绘制毛坯房与简装房在不同建造时间范围内的占比图 fig,axes = plt.subplots(1,2) roughcast_grouped_by_create_time.plot(kind=&#39;pie&#39;,ax=axes[0],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) brief_outfit_grouped_by_create_time.plot(kind=&#39;pie&#39;,ax=axes[1],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) # autopct参数的作用是指定饼形图中数据标签的显示方式 # &#39;%.1f%%&#39;表示数据标签的格式是保留一位小数的百分数 # startangle=90表示饼图的起始绘制角度是偏离x轴90度，并按逆时针绘制 # label=&#39;&#39;后，饼形图的左边便不会再显示Series对象的名字 axes[0].set_title(&#39;毛坯房&#39;) axes[0].set_aspect(&#39;equal&#39;) # 设置饼图的纵横比相等 axes[1].set_title(&#39;简装房&#39;) axes[1].set_aspect(&#39;equal&#39;) fig.suptitle(&#39;毛坯房和简装房中建造时间不同的房屋占比饼形图&#39;) plt.subplots_adjust(wspace=0.4) # 设置figure对象中两子图的间距 plt.savefig(&#39;p16.png&#39;) # 保存图片结果如下图所示： 从上图中可以发现，毛坯房中大约80%的房子是2010年以后建造的，而简装房中有大约70%的房子是2010年以前建造的。因此，可以判断毛坯房的单价均值之所以比简装房的单价均值高，很大可能是因为与简装房相比，数据集中的毛坯房大部分都是比较新的房子，在一定程度上提高了其单价均值。 查看电梯安装情况和房源是否靠近地铁站对二手房价格的影响： # 电梯安装情况对二手房价格的影响 average_price_grouped_by_elevator = new_data[&#39;售价&#39;].groupby(new_data[&#39;电梯&#39;]).mean() average_unit_price_grouped_by_elevator = new_data[&#39;单价&#39;].groupby(new_data[&#39;电梯&#39;]).mean() # 房源是否靠近地铁对价格的影响 average_price_grouped_by_subway = new_data[&#39;售价&#39;].groupby(new_data[&#39;近地铁&#39;]).mean() average_unit_price_grouped_by_subway = new_data[&#39;单价&#39;].groupby(new_data[&#39;近地铁&#39;]).mean() # 绘制描述电梯房源所在楼的安装情况与房源是否靠近地铁对房价影响的价格分布条形图 fig,axes = plt.subplots(2,2) # 绘制关于电梯安装情况的房价条形分布图 average_price_grouped_by_elevator.plot.bar(ax=axes[0,0],alpha=0.7,rot=0) average_unit_price_grouped_by_elevator.plot.bar(ax=axes[0,1],alpha=0.7,rot=0) axes[0,0].set(xlabel=&#39;电梯安装情况&#39;,ylabel=&#39;售价均值/万&#39;,yticks=[0,50,100,150,200,250,300,350]) axes[0,1].set(xlabel=&#39;电梯安装情况&#39;,ylabel=&#39;单价均值/元每平米&#39;,yticks=[0,5000,10000,15000,25000,30000]) # 绘制关于房源是否靠近地铁的房价条形分布图 average_price_grouped_by_subway.plot.bar(ax=axes[1,0],alpha=0.7,rot=0) average_unit_price_grouped_by_subway.plot.bar(ax=axes[1,1],alpha=0.7,rot=0) axes[1,0].set(xlabel=&#39;是否靠近地铁&#39;,ylabel=&#39;售价均值/万&#39;,yticks=[0,50,100,150,200,250,300]) axes[1,1].set(xlabel=&#39;是否靠近地铁&#39;,ylabel=&#39;单价均值/元每平米&#39;,yticks=[0,5000,10000,15000,20000,25000,30000]) # 依次给四个条形图添加上数据标签 add_data_label(average_price_grouped_by_elevator,axes[0,0]) add_data_label(average_unit_price_grouped_by_elevator,axes[0,1]) add_data_label(average_price_grouped_by_subway,axes[1,0]) add_data_label(average_unit_price_grouped_by_subway,axes[1,1]) fig.suptitle(&#39;不同情况下二手房价格条形图&#39;) plt.subplots_adjust(wspace=0.3,hspace=0.5) # 设置子图的间距 plt.savefig(&#39;p17.png&#39;) # 保存图片结果如下图所示： 上图表明与不靠近地铁站的二手房相比，靠近地铁站的二手房其单价均值要高1382。一套100平米的二手房，在其他条件相同的情况下，是否靠近地铁站会造成二手房的价格相差10万以上。而从不同电梯安装情况下的二手房价格条形图中可以看到，对于安装了电梯的房子，其售价均值上比没有安装电梯的房子要贵65万左右，单价均值比没有安装电梯的房子每平米要贵5000左右。为什么一部电梯会对房子的价格产生这么大的影响？ 对于有无安装电梯的房子，猜测两者售价均值出现较大差异的原因如下：猜测一：有电梯的房子的平均面积较大；猜测一：有电梯的房子中处于房价较高的区的比较多，而没电梯的房子中只有少部分处于房价较高的区；猜测三：有电梯的房子中靠近地铁站的比较多，而没电梯的房子中只有少部分靠近地铁站；猜测四：有电梯的房子中建造时间离现在比较近的房子占总体的比例较大。 对于有无安装电梯房子，猜测两者单价均值出现较大差异的原因如下：猜测一：有电梯的房子中处于房价较高的区域的比较多，而没电梯的房子中只有少部分处于房价较高的区；猜测二：有电梯的房子中靠近地铁站的比较多，而没电梯的房子中只有少部分靠近地铁站；猜测三：有电梯的房子中建造时间离现在比较近的房子占总体的比例较大。 下面对上述猜测进行检验： #绘制不同电梯安装情况下二手房的面积均值条形图 # 准备数据 average_area_grouped_by_elevator = new_data[&#39;面积&#39;].groupby(new_data[&#39;电梯&#39;]).mean() # 绘制条形图 fig,axes = plt.subplots(figsize=(7,5)) average_area_grouped_by_elevator.plot.bar(ax=axes,alpha=0.7,rot=0) axes.set(ylabel=&#39;面积均值/平米&#39;,title=&#39;不同电梯安装情况下二手房的面积均值条形图&#39;) # 调用add_data_label函数给条形图添加数据标签 add_data_label(average_area_grouped_by_elevator,axes) plt.savefig(&#39;p18.png&#39;)结果如下图所示： 由上图可以看出，面积不是造成有无电梯的二手房售价出现巨大差异的主要原因。 count_by_region_and_elevator = new_data.pivot_table(&#39;售价&#39;,index=&#39;所在区&#39;,columns=&#39;电梯&#39;,aggfunc=&#39;count&#39;) count_by_subway_and_elevator = new_data.pivot_table(&#39;售价&#39;,index=&#39;近地铁&#39;,columns=&#39;电梯&#39;,aggfunc=&#39;count&#39;) count_by_create_time_and_elevator = new_data.pivot_table(&#39;售价&#39;,index=&#39;建造时间&#39;,columns=&#39;电梯&#39;,aggfunc=&#39;count&#39;) # 分别统计不同分类标准下，有电梯和无电梯的二手房中属于不同类别的房子的数量： # 因为工业园区与高新区单位房价较高，所以无论是装有电梯的二手房还是没装电梯的二手房都被分成位于工业园区或高新区和位于其他四区这两类 # 以房子所在区为分类标准 # 工业园区和高新区中装有电梯的二手房数量 gongyeyuan_gaoxin_with_elevator = count_by_region_and_elevator.loc[&#39;工业园区&#39;][&#39;有&#39;] + count_by_region_and_elevator.loc[&#39;高新区&#39;][&#39;有&#39;] # 其他四区中装有电梯的二手房数量 other_region_with_elevator = count_by_region_and_elevator[&#39;有&#39;].sum() - gongyeyuan_gaoxin_with_elevator # 工业园区和高新区中没装电梯的二手房数量 gongyeyuan_gaoxin_without_elevator = count_by_region_and_elevator.loc[&#39;工业园区&#39;][&#39;无&#39;] + count_by_region_and_elevator.loc[&#39;高新区&#39;][&#39;无&#39;] # 其他四区中没装电梯的二手房数量 other_region_without_elevator = count_by_region_and_elevator[&#39;无&#39;].sum() - gongyeyuan_gaoxin_without_elevator # 以房源是否靠近地铁为分类标准 near_subway_with_elevator = count_by_subway_and_elevator.loc[&#39;是&#39;][&#39;有&#39;] # 装有电梯的二手房中靠近地铁站的房子数量 far_from_subway_with_elevator = count_by_subway_and_elevator.loc[&#39;否&#39;][&#39;有&#39;] # 装有电梯的二手房中远离地铁站的房子数量 near_subway_without_elevator = count_by_subway_and_elevator.loc[&#39;是&#39;][&#39;无&#39;] # 没装电梯的二手房中靠近地铁站的房子数量 far_from_subway_without_elevator = count_by_subway_and_elevator.loc[&#39;否&#39;][&#39;无&#39;] # 没装电梯的二手房中远离地铁站的房子数量 # 绘制以所在区和是否靠近地铁为分类标准的饼形图 fig,axes = plt.subplots(2,2) labels1 = [&#39;工业园区和高新区&#39;,&#39;其他四区&#39;] # 饼图的标签 axes[0,0].pie([gongyeyuan_gaoxin_with_elevator,other_region_with_elevator],labels=labels1,autopct=&#39;%1.1f%%&#39;,startangle=90) axes[0,1].pie([gongyeyuan_gaoxin_without_elevator,other_region_without_elevator],labels=labels1,autopct=&#39;%1.1f%%&#39;,startangle=90) labels2 = [&#39;靠近地铁站&#39;,&#39;不靠近地铁站&#39;] # 饼图的标签 axes[1,0].pie([near_subway_with_elevator,far_from_subway_with_elevator],labels=labels2,autopct=&#39;%1.1f%%&#39;,startangle=90) axes[1,1].pie([near_subway_without_elevator,far_from_subway_without_elevator],labels=labels2,autopct=&#39;%1.1f%%&#39;,startangle=90) # 设置子图的标题，并设置饼图的纵横比相等 axes[0,0].set(title=&#39;装有电梯&#39;,aspect=&#39;equal&#39;) axes[0,1].set(title=&#39;没装电梯&#39;,aspect=&#39;equal&#39;) axes[1,0].set(title=&#39;装有电梯&#39;,aspect=&#39;equal&#39;) axes[1,1].set(title=&#39;没装电梯&#39;,aspect=&#39;equal&#39;) fig.suptitle(&#39;不同分类标准下各类二手房占比饼形图&#39;) # 设置figure对象的标题 plt.savefig(&#39;p19.png&#39;) # 保存图片结果如下图所示： 上图表明装有电梯二手房中，位于房价较高的区域的比例远高于没装电梯的二手房中对应的比例。而装有电梯的二手房中，靠近地铁站的房子的占比明显低于没装电梯的二手房中对应的比例。 # 绘制建造时间为分类标准的饼形图 # 准备数据 before_2010_with_elevator = count_by_create_time_and_elevator.loc[:2010][&#39;有&#39;].sum() # 装有电梯的房子中建造时间在2010年以前的数量 after_2010_with_elevator = count_by_create_time_and_elevator.loc[2011:][&#39;有&#39;].sum() # 装有电梯的房子中建造时间在2010年以后的数量 before_2010_without_elevator = count_by_create_time_and_elevator.loc[:2010][&#39;无&#39;].sum() # 没装电梯的房子中建造时间在2010年以前的数量 after_2010_without_elevator = count_by_create_time_and_elevator.loc[2011:][&#39;无&#39;].sum() # 没装电梯的房子中建造时间在2010年以后的数量 # 绘制饼形图 fig,axes = plt.subplots(1,2,figsize=(8,6)) labels3 = [&#39;2010年以前建造&#39;,&#39;2010年以后建造&#39;] # 指定饼图标签 axes[0].pie([before_2010_with_elevator,after_2010_with_elevator],labels=labels3,autopct=&#39;%1.1f%%&#39;,startangle=90) axes[1].pie([before_2010_without_elevator,after_2010_without_elevator],labels=labels3,autopct=&#39;%1.1f%%&#39;,startangle=90) # 设置子图的标题，并设置饼图的纵横比相等 axes[0].set(title=&#39;装有电梯&#39;,aspect=&#39;equal&#39;) axes[1].set(title=&#39;没装电梯&#39;,aspect=&#39;equal&#39;) fig.suptitle(&#39;电梯房和非电梯房中建造时间不同的房子占比饼形图&#39;) # 设置figure对象的标题 plt.savefig(&#39;p20.png&#39;) # 保存图片结果如下图所示： 由以上信息，判断装有电梯的二手房之所以比没装电梯的二手房售价要高出65万左右，很大可能是因为装有电梯的二手房中，位于房价较高区域的房子的占比和建造时间距离现在不超过八年的房子的占比都比没装电梯的二手房中对应的比例要高。 查看房屋所处的楼层位置对价格的影响： average_price_groued_by_floor_location = new_data[&#39;售价&#39;].groupby(new_data[&#39;楼层&#39;]).mean() # 计算位于不同楼层的二手房的售价均值 average_price_groued_by_floor_location.sort_values(ascending=False,inplace=True) average_unit_price_groued_by_floor_location = new_data[&#39;单价&#39;].groupby(new_data[&#39;楼层&#39;]).mean() # 房屋所处的楼层位置对价格的影响 average_unit_price_groued_by_floor_location.sort_values(ascending=False,inplace=True) # 绘制处于不同楼层的二手房价格的条形分布图 fig,axes = plt.subplots(1,2,figsize=(7,5)) average_price_groued_by_floor_location.plot.bar(ax=axes[0],alpha=0.7,rot=0) average_unit_price_groued_by_floor_location.plot.bar(ax=axes[1],alpha=0.7,rot=0) axes[0].set(xlabel=&#39;楼层位置&#39;,ylabel=&#39;售价均值/万&#39;) axes[1].set(xlabel=&#39;楼层位置&#39;,ylabel=&#39;单价均值/元每平米&#39;) # 调用add_data_label函数给条形图添加数据标签 add_data_label(average_price_groued_by_floor_location,axes[0]) add_data_label(average_unit_price_groued_by_floor_location,axes[1]) fig.suptitle(&#39;不同楼层的二手房价格条形图&#39;) # 设置figure对象的标题 plt.subplots_adjust(wspace=0.4) # 设置figure对象中子图的间距 plt.savefig(&#39;p21.png&#39;) # 保存图片结果如下图所示： 上图表明，对于位于低楼层的二手房，其售价和单价都比位于高楼层和低楼层的二手房明显要高。 查看房屋的面积对价格的影响： 先看整体范围内，二手房面积与价格的关系： # 绘制六个区汇总后的房屋面积——售价散点图 fig,axes = plt.subplots(figsize=(7,5)) sns.scatterplot(x=&#39;面积&#39;,y=&#39;售价&#39;,hue=&#39;所在区&#39;,data=new_data,ax=axes) axes.set(xlabel=&#39;面积/平米&#39;,ylabel=&#39;售价/万&#39;,title=&#39;二手房售价—面积散点图&#39;) plt.savefig(&#39;p22.png&#39;) # 保存图片结果如下图所示： # 计算所有区范围内，二手房售价/单价与面积的相关系数 # 计算售价和面积的相关系数 correlation_coefficient_between_price_and_area = new_data[&#39;售价&#39;].corr(new_data[&#39;面积&#39;]) # 计算单价和面积的相关系数 correlation_coefficient_between_price_and_unit_area = new_data[&#39;单价&#39;].corr(new_data[&#39;面积&#39;]) print(correlation_coefficient_between_price_and_area,correlation_coefficient_between_price_and_unit_area) # 输出结果为： # 0.6854439843669617 0.08523861458401118由以上信息可知整体范围内二手房的售价与面积的相关性为较强，达到了0.685，整体来说，随着的单面积的增加，二手房的售价也随之增加；而二手房的单价与面积几乎不相关。 再看每个区内，二手房售价与面积的关系： # 分别绘制六个区内二手房售价——面积散点图 df = new_data.set_index([&#39;所在区&#39;]) # 将new_data中的所在区这一列指定为索引 # 根据索引筛选出六个不同区的售价与面积数据 gongyeyuanqu = df.loc[&#39;工业园区&#39;][[&#39;售价&#39;,&#39;单价&#39;,&#39;面积&#39;]] gaoxinqu = df.loc[&#39;高新区&#39;][[&#39;售价&#39;,&#39;单价&#39;,&#39;面积&#39;]] gusuqu = df.loc[&#39;姑苏区&#39;][[&#39;售价&#39;,&#39;单价&#39;,&#39;面积&#39;]] wuzhongqu = df.loc[&#39;吴中区&#39;][[&#39;售价&#39;,&#39;单价&#39;,&#39;面积&#39;]] xiangchengqu = df.loc[&#39;相城区&#39;][[&#39;售价&#39;,&#39;单价&#39;,&#39;面积&#39;]] wujiangqu = df.loc[&#39;吴江区&#39;][[&#39;售价&#39;,&#39;单价&#39;,&#39;面积&#39;]] # 绘制售价——面积散点图 fig,axes = plt.subplots(2,3) sns.scatterplot(x=&#39;面积&#39;,y=&#39;售价&#39;,data=gongyeyuanqu,ax=axes[0,0]) sns.scatterplot(x=&#39;面积&#39;,y=&#39;售价&#39;,data=gaoxinqu,ax=axes[0,1]) sns.scatterplot(x=&#39;面积&#39;,y=&#39;售价&#39;,data=gusuqu,ax=axes[0,2]) sns.scatterplot(x=&#39;面积&#39;,y=&#39;售价&#39;,data=wuzhongqu,ax=axes[1,0]) sns.scatterplot(x=&#39;面积&#39;,y=&#39;售价&#39;,data=xiangchengqu,ax=axes[1,1]) sns.scatterplot(x=&#39;面积&#39;,y=&#39;售价&#39;,data=wujiangqu,ax=axes[1,2]) fig.suptitle(&#39;不同区内二手房售价—面积散点图&#39;) # 设置figure对象的标题 # 设置子图的坐标轴标签和标题 axes[0,0].set(xlabel=&#39;&#39;,ylabel=&#39;售价/万&#39;,title=&#39;工业园区&#39;) axes[0,1].set(xlabel=&#39;&#39;,ylabel=&#39;&#39;,title=&#39;高新区&#39;) axes[0,2].set(xlabel=&#39;&#39;,ylabel=&#39;&#39;,title=&#39;姑苏区&#39;) axes[1,0].set(xlabel=&#39;面积/平米&#39;,ylabel=&#39;售价/万&#39;,title=&#39;吴中区&#39;) axes[1,1].set(xlabel=&#39;面积/平米&#39;,ylabel=&#39;&#39;,title=&#39;相城区&#39;) axes[1,2].set(xlabel=&#39;面积/平米&#39;,ylabel=&#39;&#39;,title=&#39;吴江区&#39;) plt.subplots_adjust(wspace=0.4,hspace=0.4) # 设置figure对象中子图的间距 plt.savefig(&#39;p23.png&#39;) # 保存图片结果如下图所示： 计算各区内二手房售价与面积的相关系数： # 分别计算不同区内二手房售价/单价与面积的相关系数 gongyeyuanqu_correlation_coefficient_between_price_and_area = gongyeyuanqu[&#39;售价&#39;].corr(gongyeyuanqu[&#39;面积&#39;]) gaoxinqu_correlation_coefficient_between_price_and_area = gaoxinqu[&#39;售价&#39;].corr(gaoxinqu[&#39;面积&#39;]) gusuqu_correlation_coefficient_between_price_and_area = gusuqu[&#39;售价&#39;].corr(gusuqu[&#39;面积&#39;]) wuzhongqu_correlation_coefficient_between_price_and_area = wuzhongqu[&#39;售价&#39;].corr(wuzhongqu[&#39;面积&#39;]) xiangchengqu_correlation_coefficient_between_price_and_area = xiangchengqu[&#39;售价&#39;].corr(xiangchengqu[&#39;面积&#39;]) wujiangqu_correlation_coefficient_between_price_and_area = wujiangqu[&#39;售价&#39;].corr(wujiangqu[&#39;面积&#39;]) corr1 = gongyeyuanqu_correlation_coefficient_between_price_and_area corr2 = gaoxinqu_correlation_coefficient_between_price_and_area corr3 = gusuqu_correlation_coefficient_between_price_and_area corr4 = wuzhongqu_correlation_coefficient_between_price_and_area corr5 = xiangchengqu_correlation_coefficient_between_price_and_area corr6 = wujiangqu_correlation_coefficient_between_price_and_area print(corr1,corr2,corr3,corr4,corr5,corr6) # 输出结果为： # 0.6841568087167097 0.7454465461851735 0.8464407898530029 0.8390072605746044 0.829712023546309 0.8608067483548217由以上信息可知：工业园区和高新区内二手房的售价与面积的相关系数明显比其他四区内的小。这说明，工业园区和高新区内二手房的售价受其他因素的影响比其他区内二手房售价受其他因素的影响更大。 查看房屋的建造时间对价格的影响： # 绘制二手房价格随建造时间变化的折线图 fig,axes = plt.subplots(1,2,figsize=(7,5)) average_price_affected_by_create_time = new_data[&#39;售价&#39;].groupby(new_data[&#39;建造时间&#39;]).mean() average_unit_price_affected_by_create_time = new_data[&#39;单价&#39;].groupby(new_data[&#39;建造时间&#39;]).mean() average_price_affected_by_create_time.plot(kind=&#39;line&#39;,ax=axes[0]) average_unit_price_affected_by_create_time.plot(kind=&#39;line&#39;,ax=axes[1]) axes[0].set(ylabel=&#39;售价均值/万&#39;) axes[1].set(ylabel=&#39;单价均值/元每平米&#39;) fig.suptitle(&#39;二手房价格随建造时间变化折线图&#39;) plt.subplots_adjust(wspace=0.5) # 设置figure对象中子图的间距 plt.savefig(&#39;p24&#39;) # 保存图片结果如下图所示： 从上图可以看到，随着建造时间的接近，无论是二手房的售价还是单价，整体上都呈上升趋势。而在建造时间的局部范围内，二手房的售价和单价都有上下波动的现象。 3）探究更容易受到人们青睐的二手房具有什么特点？updated_data = new_data.copy() # 深度复制一份new_data数据,copy中的deep参数默认是True。 # 将分别加一后房源的关注人数和带看次数做乘积，用以表示房源的受欢迎程度，简记为受欢迎度 updated_data[&#39;受欢迎度&#39;]= (updated_data[&#39;关注人数&#39;] + 1) * (updated_data[&#39;带看次数&#39;] + 1) updated_data.head() # 查看updated_data的前五条数据输出结果如下图所示： # 按找房源的受欢迎程度对所有房源进行降序排序，并提取出排名前500的房源信息 sort_by_popularity = updated_data.sort_values(by=&#39;受欢迎度&#39;,ascending=False) new_sort_by_popularity = sort_by_popularity[:500] new_sort_by_popularity.head() # 查看new_sort_by_popularity的前五条数据输出结果如下图所示： 分析这500套房子有什么特点： # 区域分布数据 count_by_region_500_one = new_sort_by_popularity[&#39;所在区&#39;].groupby(new_sort_by_popularity[&#39;所在区&#39;]).count() count_by_region_500_two =count_by_region_500_one[count_by_region_500_one &gt; 50] count_by_region_500_two[&#39;其他区&#39;] = count_by_region_500_one[count_by_region_500_one &lt; 51].sum() new_count_by_region_500 = count_by_region_500_two.sort_values(ascending=False) # 户型分布数据 # 对不同户型的房子进行统计计数 count_by_house_type_500_one = new_sort_by_popularity[&#39;户型&#39;].groupby(new_sort_by_popularity[&#39;户型&#39;]).count() # 筛选出总数大于50套的户型 count_by_house_type_500_two = count_by_house_type_500_one[count_by_house_type_500_one &gt; 60] # 将总数小于50套的户型统一归为其他类 count_by_house_type_500_two[&#39;其他&#39;] = count_by_house_type_500_one[count_by_house_type_500_one &lt; 60].sum() new_count_by_house_type_500 = count_by_house_type_500_two.sort_values(ascending=False) # 装修情况分布数据 count_by_decoration_500 = new_sort_by_popularity[&#39;装修&#39;].groupby(new_sort_by_popularity[&#39;装修&#39;]).count() # count_by_decoration_500_two = count_by_decoration_500_one[[&#39;毛坯&#39;,&#39;简装&#39;,&#39;精装&#39;]] new_count_by_decoration_500 = count_by_decoration_500.sort_values(ascending=False) # 电梯安装情况分布数据 count_by_elevator_500 = new_sort_by_popularity[&#39;电梯&#39;].groupby(new_sort_by_popularity[&#39;电梯&#39;]).count() new_count_by_elevator_500 = count_by_elevator_500.sort_values(ascending=False) # 距离地铁站远近情况分布数据 count_by_subway_500 = new_sort_by_popularity[&#39;近地铁&#39;].groupby(new_sort_by_popularity[&#39;近地铁&#39;]).count() new_count_by_subway_500 = count_by_subway_500.sort_values(ascending=False) # 建造时间分布数据 # 先对不同时间建造的房屋进行分组统计 count_by_create_time_500 = new_sort_by_popularity[&#39;建造时间&#39;].groupby(new_sort_by_popularity[&#39;建造时间&#39;]).count() # 将房屋建造时间分成2000年及以前、2001-2005年、2006-2010年、2011-2015年、2016年及以后这五组数据,并分组计数 count_by_create_time1_500 = count_by_create_time_500.loc[:2005].sum() count_by_create_time2_500 = count_by_create_time_500.loc[2006:2010].sum() count_by_create_time3_500 = count_by_create_time_500.loc[2011:2015].sum() count_by_create_time4_500 = count_by_create_time_500.loc[2016:].sum() # 创建一个Series对象用于存储不同建造时间建造的二手房的数据 new_count_by_create_time_500 = pd.Series([count_by_create_time1_500,count_by_create_time2_500,count_by_create_time3_500, count_by_create_time4_500], index=[&#39;2005年及以前&#39;,&#39;2006-2010年&#39;,&#39;2011-2015年&#39;,&#39;2016年及以后&#39;]) # 绘制饼形图 fig,axes = plt.subplots(2,3,figsize=(8,6)) new_count_by_region_500.plot(kind=&#39;pie&#39;,ax=axes[0,0],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) new_count_by_house_type_500.plot(kind=&#39;pie&#39;,ax=axes[0,1],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) new_count_by_decoration_500.plot(kind=&#39;pie&#39;,ax=axes[0,2],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) new_count_by_elevator_500.plot(kind=&#39;pie&#39;,ax=axes[1,0],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) new_count_by_subway_500.plot(kind=&#39;pie&#39;,ax=axes[1,1],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) new_count_by_create_time_500.plot(kind=&#39;pie&#39;,ax=axes[1,2],autopct=&#39;%.1f%%&#39;,startangle=90,label=&#39;&#39;) # autopct参数的作用是指定饼形图中数据标签的显示方式 # &#39;%.1f%%&#39;表示数据标签的格式是保留一位小数的百分数 # startangle=90表示饼图的起始绘制角度是偏离x轴90度，并按逆时针绘制 # label=&#39;&#39;后，饼形图的左边便不会再显示Series对象的名字 # 设置子图的标题以及设置饼形图的纵横比相等 axes[0,0].set(title=&#39;区域分布&#39;,aspect=&#39;equal&#39;) axes[0,1].set(title=&#39;户型分布&#39;,aspect=&#39;equal&#39;) axes[0,2].set(title=&#39;装修情况&#39;,aspect=&#39;equal&#39;) axes[1,0].set(title=&#39;电梯安装情况&#39;,aspect=&#39;equal&#39;) axes[1,1].set(title=&#39;近地铁&#39;,aspect=&#39;equal&#39;) axes[1,2].set(title=&#39;建造时间&#39;,aspect=&#39;equal&#39;) plt.subplots_adjust(wspace=0.6) fig.suptitle(&#39;最受欢迎二手房特征分布饼形图&#39;) # 设置figure对象的标题 plt.savefig(&#39;p25.png&#39;) # 保存图片结果如下图所示： 查看这500套二手房面积的分布特点： fig,axes = plt.subplots(figsize=(7,5)) new_sort_by_popularity[&#39;面积&#39;].hist(ax=axes,bins=10) axes.set(xlabel=&#39;面积/平米&#39;,ylabel=&#39;数量/套&#39;,title=&#39;500套最受欢迎二手房面积频数分布直方图&#39;) plt.savefig(&#39;p26.png&#39;) # 保存图片结果如下图所示： 接下来查看这500套二手房的售价与单价的分布特点： fig,axes = plt.subplots(1,2,figsize=(9,6)) new_sort_by_popularity[&#39;售价&#39;].hist(ax=axes[0],bins=10) axes[0].set(xlabel=&#39;售价/万&#39;,ylabel=&#39;频数&#39;,title=&#39;售价频数分布直方图&#39;,xticks=[100,200,300,400,500,600,700,800]) new_sort_by_popularity[&#39;单价&#39;].hist(ax=axes[1],bins=10) axes[1].set(xlabel=&#39;单价/元每平米&#39;,ylabel=&#39;频数&#39;,title=&#39;单价频数分布直方图&#39;) plt.suptitle(&#39;500套最受欢迎二手房售价与单价频数分布直方图&#39;) plt.savefig(&#39;p27.png&#39;) # 保存图片结果如下图所示： （5）项目总结至此，可以回答在项目初期确立的三个问题。 （a）西安市所辖六区范围内的二手房中：户型方面，占比最多的户型是三室两厅接近40%，其次是两室两厅达到了21%，也就是说这两种户型的房子的需求量最大；值得注意的是，在房屋朝向方面，90%以上的二手房的朝向都是南北朝向；装修方面，在所有清晰表明装修情况的二手房中，精装房的占比超过了60%；楼层位置方面，位于高中低三种不同楼层位置的二手房占比差别不是太大；不过总楼层数方面，将近50%的二手房位于总楼层数不超过10层的楼；电梯方面，60%的二手房都安装了电梯；交通方面，接近40%的二手房靠近地铁站；建造时间方面，随着建造时间距离现在越来越近，二手房的数量整体呈增加趋势，具体来说，2011年及其以后建造的二手房占比接近50%；面积方面，70%以上的二手房的面积在50-150平米之间，30%以下的二手房的面积小于50平米或者大于150平米。价格方面，70%以上的二手房的售价在100-450万之间，30%以下的二手房售价在小于100万或者大于450万。同时，65%以上的二手房的单价在15000-35000每平米之间，35%以下的二手房的单价小于15000每平米或者大于35000每平米。 （b）影响二手房价格最主要的因素是房源的地理位置，具体来说就是房源所处的区域、房源是否靠近地铁站，其他影响较大的因素还包括二手房的装修情况、建造时间以及楼层位置。 （c）更容易受到人们青睐的二手房具有如下特点：一方面，房源位于工业园区、户型为三室两厅或者两室两厅、装有电梯且建造时间离现在较近；另一方面，面积大致在75-100平米这个范围内、售价在150-250万这个范围内。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://www.iamys.club/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据 python爬虫","slug":"大数据-python爬虫","permalink":"https://www.iamys.club/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE-python%E7%88%AC%E8%99%AB/"}]},{"title":"Ajax","slug":"Ajax","date":"2020-05-07T16:00:00.000Z","updated":"2020-05-08T04:37:40.558Z","comments":true,"path":"2020/05/08/Ajax/","link":"","permalink":"https://www.iamys.club/2020/05/08/Ajax/","excerpt":"","text":"Ajax的作用浏览器提供的一个方法，可以实现无刷新更新数据，提高用户浏览应用的体验。 Ajax的应用场景 页面上拉加载更多数据 列表数据无刷新分页 表单项离开焦点数据验证 搜索框提示文字下拉列表 Ajax运行原理及实现Ajax运行原理Ajax相当于浏览器发送请求与接收响应的代理人，以实现在不影响用户浏览页面的情况下，局部更新数据，从而提高用户体验。 Ajax的实现步骤 创建Ajax对象 var xhr = new XHLHttpRequest() 告诉Ajax请求地址以及请求方式 xhr.open(&#39;get&#39;,&#39;http://localhost:3000&#39;) 发送请求 xhr.send() 获取服务器端给客服端的响应数据 xhr.onload = function(){ console.log(xhr.responseText) }服务器端响应的数据格式服务器端大多数情况下会以JSON对象作为响应数据的格式，客户端拿到数据时要将JSON数据和HTML字符串进行拼接，再把拼接好的结果展示在页面 在http请求和响应的过程中，无论时请求参数还是请求参数还是响应内容，如果时对象类型，最终都会被转换为对象字符串进行传输。 JSON.parse() //将json字符串转换为json对象 JSON.stringify() // 将json对象转换为json字符串 在请求头中指定 Content-Type 属性的值是 application/json，告诉服务器端当前请求参数的格式是 json。 注意：get 请求是不能提交 json 对象数据格式的，传统网站的表单提交也是不支持 json 对象数据格式的。 请求参数传递 GET请求方式 xhr.open(&#39;get&#39;,&#39;http://www.example.com?name=zhangsan&amp;age=20&#39;) POST请求方式 xhr.setRequestHeader(&#39;Content-Type&#39;,&#39;application/x-www-form-urlencoded&#39;) xhr.send(&#39;name=zhangsan&amp;age=20&#39;)请求报文 在http请求和响应的过程中传递的数据块就叫做报文，，包括要传送的数据和一些附加信息，这些数据和信息要遵守规定好的格式。 请求参数的格式 application/x-www-form-urlencoded name=zhangsan&amp;age=20&amp;sex=男 application/json {name: &#39;zhangsan&#39;, age: &#39;20&#39;, sex: &#39;男&#39;} 获取服务器的响应Ajax状态码在创建ajax对象，配置ajax对象，发送请求，以及接收完服务器端响应数据，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码。 0：请求未初始化(还没有调用open()) 1：请求已经建立，但是还没有发送(还没有调用send()) 2：请求已经发送 3：请求正在处理中，通常响应中已经有部分数据可以用了 4：响应已经完成，可以获取并使用服务器的响应了 xhr.readyState // 获取Ajax状态码onreadystatechange事件当Ajax状态码发生变化时自动触发该事件 在事件处理函数中可以获取 Ajax 状态码并对其进行判断，当状态码为 4 时就可以通过 xhr.responseText 获取服务器端的响应数据了。 // 当Ajax状态码发生变化时 xhr.onreadystatechange = function () { // 判断当Ajax状态码为4时 if (xhr.readyState == 4) { // 获取服务器端的响应数据 console.log(xhr.responseText); } }Ajax错误处理 网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期结果。 ​ 可以判断服务器端返回的状态码，分别进行处理。xhr.status 获取http状态码 网络畅通，服务器端没有接收到请求，返回404状态码。 ​ 检查请求地址是否错误。 网络畅通，服务器端能接收到请求，服务器端返回500状态码。 ​ 服务器端错误，找后端程序员进行沟通。 网络中断，请求无法发送到服务器端。 ​ 会触发xhr对象下面的onerror事件，在onerror事件处理函数中对错误进行处理。 低版本ie浏览器的缓存问题解决方案：在请求地址的后面加请求参数，保证每一次请求中的请求参数的值不相同 xhr.open(&#39;get&#39;, &#39;http://www.example.com?t=&#39; + Math.random());Ajax异步编程 一个人一件事情做了一半，转而去做其他事情，当其他事情做完以后，再回过头来继续做之前未完成的事情。 落实到代码上，就是异步代码虽然需要花费时间去执行，但程序不会等待异步代码执行完成后再继续执行后续代码，而是直接执行后续代码，当后续代码执行完成后再回头看异步代码是否返回结果，如果已有返回结果，再调用事先准备好的回调函数处理异步代码执行的结果。 模板引擎使用步骤1.下载art-template模板引擎文件，并引入 &lt;script src=&quot;./js/template-web.js&quot;&gt;&lt;/script&gt;2.准备模板 &lt;script id=&quot;tpl&quot; type=&quot;text/html&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/script&gt; 3.告诉模板引擎将哪一个模板和哪个数据进行拼接 var html = template(&#39;tpl&#39;, {username: &#39;zhangsan&#39;, age: &#39;20&#39;});4.将拼接好的html字符串添加到页面中 document.getElementById(&#39;container&#39;).innerHTML = html; 通过模板语法告诉模板引擎，数据和html字符串要如何拼接 &lt;script id=&quot;tpl&quot; type=&quot;text/html&quot;&gt; &lt;div class=&quot;box&quot;&gt; {{ username }} &lt;/div&gt; &lt;/script&gt;FormData 对象的作用1.模拟HTML表单，相当于将HTML表单映射成表单对象，自动将表单对象中的数据拼接成请求参数的格式。 2.异步上传二进制文件 FormData 对象的使用 1.有一个HTML表单 2.将HTML表单转换为formData对象 var form = document.getElementById(&#39;form&#39;); var formData = new FormData(form);3.提交表单对象 xhr.send(formData)注意： Formdata 对象不能用于 get 请求，因为对象需要被传递到 send 方法中，而 get 请求方式的请求参数只能放在请求地址的后面。 服务器端 bodyParser 模块不能解析 formData 对象表单数据，我们需要使用 formidable 模块进行解析。 formData对象的实例方法 获取表单对象中的属性值 formData.get(&#39;key&#39;) 设置表单对象中的属性的值 formData.set(&#39;key&#39;,value) 删除表单对象中属性的值 formData.delete(&#39;key&#39;) 像表单对象中追加属性值 formData.append(&#39;key&#39;,&#39;value&#39;)注意：set 方法与 append 方法的区别是，在属性名已存在的情况下，set 会覆盖已有键名的值，append会保留两个值。 FormData二进制文件上传&lt;input type=&quot;file&quot; id=&quot;file&quot;/&gt; var file = document.getElementById(&#39;file&#39;) // 当用户选择文件的时候 file.onchange = function () { // 创建空表单对象 var formData = new FormData(); // 将用户选择的二进制文件追加到表单对象中 formData.append(&#39;attrName&#39;, this.files[0]); // 配置ajax对象，请求方式必须为post xhr.open(&#39;post&#39;, &#39;www.example.com&#39;); xhr.send(formData); }FormData文件上传进度展示 // 当用户选择文件的时候 file.onchange = function () { // 文件上传过程中持续触发onprogress事件 xhr.upload.onprogress = function (ev) { // 当前上传文件大小/文件总大小 再将结果转换为百分数 // 将结果赋值给进度条的宽度属性 bar.style.width = (ev.loaded / ev.total) * 100 + &#39;%&#39;; } }FormData文件上传图片即使预览 xhr.onload = function () { var result = JSON.parse(xhr.responseText); var img = document.createElement(&#39;img&#39;); img.src = result.src; img.onload = function () { document.body.appendChild(this); } }同源政策什么时同源：如果两个页面拥有相同的协议、域名和端口，那么这两个页面就属于同一个源，其中只要有一个不相同，就是不同源。 同源的目的：同源政策是为了保证用户信息的安全，防止恶意的网站窃取数据。最初的同源政策是指 A 网站在客户端设置的 Cookie，B网站是不能访问的。随着互联网的发展，同源政策也越来越严格，在不同源的情况下，其中有一项规定就是无法向非同源地址发送Ajax 请求，如果请求，浏览器就会报错。 使用JSONP解决同源限制问题 将不同源的服务器端请求地址写在 script 标签的 src 属性中 &lt;script src=“https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; 服务器端响应数据必须是一个函数的调用，真正要发送给客户端的数据需要作为函数调用的参数。 const data = &#39;fn({name: &quot;张三&quot;, age: &quot;20&quot;})&#39;; res.send(data); 在客户端全局作用域下定义函数 fn，并进行处理 function fn (data) { console.log(data); } JSONP代码优化1.客户端需要将函数名称传递到服务器端。 2.将 script 请求的发送变成动态请求。 3.封装 jsonp 函数，方便请求发送。 4.服务器端代码优化之 res.jsonp 方法。 CORS跨域资源共享CORS：全称为 Cross-origin resource sharing，即跨域资源共享，它允许浏览器向跨域服务器发送 Ajax 请求，克服了 Ajax 只能同源使用的限制。 浏览器端请求头 origin: http://localhost:3000服务器端响应头 Access-Control-Allow-Origin: &#39;http://localhost:3000&#39; Access-Control-Allow-Origin: &#39;*&#39; //Node服务器设置响应头实例 app.use((req, res, next) =&gt; { res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET, POST&#39;); next(); })jQuery与Ajax$.ajax() :发送Ajax请求 $.ajax({ type: &#39;get&#39;, url: &#39;http://www.example.com&#39;, data: { name: &#39;zhangsan&#39;, age: &#39;20&#39; }, contentType: &#39;application/x-www-form-urlencoded&#39;, beforeSend: function () { return false }, success: function (response) {}, error: function (xhr) {} });$.ajax: 发送jsonp请求$.ajax({ url: &#39;http://www.example.com&#39;, // 指定当前发送jsonp请求 dataType: &#39;jsonp&#39;, // 修改callback参数名称 jsonp: &#39;cb&#39;, // 指定函数名称 jsonCallback: &#39;fnName&#39;, success: function (response) {} })serialize方法：将表单中的数据自动拼接成字符串类型的参数，获取用户在表单中输入的值 var params = $(&#39;#form&#39;).serialize(); // name=zhangsan&amp;age=30$.get()和$.post()方法：$.get方法用于发送get请求，$.post方法用于发送post请求 全局事件只要页面有Ajax请求被发送，对应的全局事件就会触发 .ajaxStart() // 当请求开始发送时触发 .ajaxComplete() // 当请求完成时触发NProgress：进度条动画NProgress.start(); // 进度条开始运动 NProgress.done(); // 进度条结束运动RESTful API 一套关于请求风格的规范 GET： 获取数据 POST： 添加数据 PUT： 更新数据 DELETE： 删除数据","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://www.iamys.club/tags/Ajax/"}]},{"title":"Express框架","slug":"Express框架","date":"2020-04-19T16:00:00.000Z","updated":"2020-04-20T12:36:41.432Z","comments":true,"path":"2020/04/20/Express框架/","link":"","permalink":"https://www.iamys.club/2020/04/20/Express%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Express是一个基于Node平台的web应用开放框架，他提供了一系列的强大特性，帮助你创建各种web应用。我们可以使用npm install express 命令下载 Express框架特性 提供了方便简洁的路由定义方式 对获取HTTP请求参数进行了简化处理 对模板引擎支持程度高，方便渲染动态HTML页面 提供中间件机制有效控制HTTP请求 拥有大量中间件对功能进行扩展 // 引入express框架 const express = require(&#39;express&#39;); // 创建网站服务器 const app = express(); app.get(&#39;/&#39; , (req, res) =&gt; { // send() // 1. send方法内部会检测响应内容的类型 // 2. send方法会自动设置http状态码 // 3. send方法会帮我们自动设置响应的内容类型及编码 res.send(&#39;Hello. Express&#39;); }) // 监听端口 app.listen(3000);中间件中间件就是一堆方法，可以接受客户端放来的请求，可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。 中间件由两部分构成，中间件方法以及请求处理函数；中间件方法由Exprss提供，负责拦截请求，请求函数有开发人员提供，负责处理请求。 app.get(&#39;请求路径&#39;, &#39;处理函数&#39;) // 接收并处理get请求 app.post(&#39;请求路径&#39;, &#39;处理函数&#39;) // 接收并处理post请求可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。可以调用next方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。 app.get(&#39;/request&#39;, (req, res, next) =&gt; { req.name = &quot;张三&quot;; next(); }); app.get(&#39;/request&#39;, (req, res) =&gt; { res.send(req.name); });app.use中间件用法app.use 匹配所有请求方式，可以直接传入请求处理函数，代表接受所有请求。第一个参数可以省略表示通配。 app.use(&#39;/admin&#39;, (req, res, next) =&gt; { console.log(req.url); next(); });中间件的应用 路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。 网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。 自定义404页面 错误处理中间件在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。 app.use((err, req, res, next) =&gt; { res.status(500).send(&#39;服务器发生未知错误&#39;); })当程序出现错误时，调用next()方法，并且将错误信息通过参数的形式传递给next()方法，即可触发错误处理中间件 app.get(&quot;/&quot;, (req, res, next) =&gt; { fs.readFile(&quot;/file-does-not-exist&quot;, (err, data) =&gt; { if (err) { next(err); } }); });捕获错误在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。 异步函数执行如果发生错误可以通过 try catch 捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。 app.get(&quot;/&quot;, async (req, res, next) =&gt; { try { await User.find({name: &#39;张三&#39;}) }catch(ex) { next(ex); } });Express请求处理模块化路由const home = express.Router(); // 为路由对象匹配请求路径 app.use(&#39;/home&#39;, home); // 创建二级路由 home.get(&#39;/index&#39;, (req, res) =&gt; { res.send(&#39;欢迎来到博客首页页面&#39;) }) // admin.js const admin = express.Router(); admin.get(&#39;/index&#39;, () =&gt; { res.send(&#39;欢迎来到博客管理页面&#39;); }); module.exports = admin;const admin = require(&#39;./route/admin.js&#39;); app.use(&#39;/admin&#39;, admin);GET 参数的获取Express框架中使用req.query即可获取GET参数，框架内部会将GET参数转换为对象并返回。 // 接收地址栏中问号后面的参数 // 例如: http://localhost:3000/?name=zhangsan&amp;age=30 app.get(&#39;/&#39;, (req, res) =&gt; { console.log(req.query); // {&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;30&quot;} });POST参数的获取Express中接收post请求参数需要借助第三方包 body-parser。 // 引入body-parser模块 const bodyParser = require(&#39;body-parser&#39;); // 配置body-parser模块 // extended: false 方法内部使用querystring模块处理请求参数的格式 // extended: true 方法内部使用第三方模块qs处理请求参数的格式 app.use(bodyParser.urlencoded({ extended: false })); // 接收请求 app.post(&#39;/add&#39;, (req, res) =&gt; { // 接收请求参数 console.log(req.body); }) 路由参数 app.get(&#39;/find/:id&#39;, (req, res) =&gt; { console.log(req.params); // {id: 123} });访问的是localhost:3000/find/123 静态资源的处理通过Express内置的express.static可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。 app.use(express.static(&#39;public&#39;));这样public下的静态资源就可以访问了 Express-art-template模板引擎模板引擎 为了使art-template模板引擎能够更好的和Express框架配合，模板引擎官方在原art-template模板引擎的基础上封装了express-art-template。 使用npm install art-template express-art-template命令进行安装。 // 当渲染后缀为art的模板时 使用express-art-template app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;)); // 设置模板存放目录 app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;)); // 渲染模板时不写后缀 默认拼接art后缀 app.set(&#39;view engine&#39;, &#39;art&#39;); app.get(&#39;/&#39;, (req, res) =&gt; { // 渲染模板 res.render(&#39;index&#39;); }); app.locals对象将变量设置到app.locals对象下面，这个数据在所有的模板中都可以获取到。 app.locals.users = [{ name: &#39;张三&#39;, age: 20 },{ name: &#39;李四&#39;, age: 20 }]","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"Express框架","slug":"Express框架","permalink":"https://www.iamys.club/tags/Express%E6%A1%86%E6%9E%B6/"}]},{"title":"mongoDB数据库","slug":"mongoDB接数据库","date":"2020-04-16T16:00:00.000Z","updated":"2020-04-20T12:38:47.286Z","comments":true,"path":"2020/04/17/mongoDB接数据库/","link":"","permalink":"https://www.iamys.club/2020/04/17/mongoDB%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"术语 解释说明 database 数据库，可建立多个 collection 集合，一组数据，相当于js里的数组 document 文档，一条具体的数据，相当于js里的对象 filed 字段，文档中的属性名称，相当与js中的对象属性 如何连mongoDB接数据库 下载mongoos第三方模块npm install mongoose 启动 ner start mongoDB 引入mongoose第三方模块，用来操作数据库 用connect方法来连接数据库，参数为mongodb://localhost/playground，最后一个是数据库名写上就会自动创建 分别用.then和.catch对数据库连接成功或失败一个反馈 const mongoose = require(&#39;mongoose&#39;) mongoose.connect(&#39;mongoose://localhost/playground&#39;) .then(() =&gt; console.log(&#39;数据库连接成功&#39;)) .catch(() =&gt; console.log(&#39;数据库连接失败&#39;))如何创建一个集合以及向集合插入文档 创建集合规则，用new实例化mongoose，用Schema方法添加规则，规则为字段名和类型 创建集合，model方法第一个参数是集合名第二个参数是集合规则 创建文档，用new实例化集合，参数为一个对象每一项是具体的字段和值 将文档保存到数据库，文档名.save() const personSchema = new mongoose.Schema({ name: String, age: Number, hobbies: [String] }) const Person = mongoose.model(&#39;Person&#39;, personSchema) const person = new Person({ name: &#39;zhangsan&#39;, age: 12, hobbies: [&#39;sing&#39;, &#39;read&#39;] }) person.save()集合插入文档的另一种方式之前我们插入文档是用new实例化集合，还有一个方式是用集合.create方法参数是一个对象，里面是具体的字段和值，可以用.then查看结果。 Person.create({ name: &#39;zhangsan&#39;, age: 12, hobbies: [&#39;sing&#39;, &#39;read&#39;] }) .then(result =&gt; {console.log(result);})文档查询文档查询之前可以先建立一个用户信息文件如user.json { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f1e5aeb04b22f8460965&quot; }, &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;hobbies&quot;: [&quot;足球&quot;, &quot;篮球&quot;, &quot;橄榄球&quot;], &quot;email&quot;: &quot;zhangsan@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f236aeb04b22f8460967&quot; }, &quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 10, &quot;hobbies&quot;: [&quot;足球&quot;, &quot;篮球&quot;], &quot;email&quot;: &quot;lisi@itcast.cn&quot;, &quot;password&quot;: &quot;654321&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f267aeb04b22f8460968&quot; }, &quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;hobbies&quot;: [&quot;敲代码&quot;], &quot;email&quot;: &quot;wangwu@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f294aeb04b22f8460969&quot; }, &quot;name&quot;: &quot;赵六&quot;, &quot;age&quot;: 50, &quot;hobbies&quot;: [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;], &quot;email&quot;: &quot;zhaoliu@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f2b6aeb04b22f846096a&quot; }, &quot;name&quot;: &quot;王二麻子&quot;, &quot;age&quot;: 32, &quot;hobbies&quot;: [&quot;吃饭&quot;], &quot;email&quot;: &quot;wangermazi@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f2d9aeb04b22f846096b&quot; }, &quot;name&quot;: &quot;狗蛋&quot;, &quot;age&quot;: 14, &quot;hobbies&quot;: [&quot;打豆豆&quot;], &quot;email&quot;: &quot;goudan@163.com&quot;, &quot;password&quot;: &quot;123456&quot; }创建好集合之后用导入数据：mongoimport -d 数据库名 -c 集合名 --file 要导入文件的路径 然后再找到mongodb数据库的安装目录，将安装目录下的bin目录放置在环境变量中。 find()查询指定集合的所有文档 Person.find().then(result =&gt; console.log(result))find({条件})查询指定集合中满足条件的文档 Person.find({name:&#39;李四&#39;}).then(result=&gt;console.log(result))find({字段:{$gt:开始范围 , $lt: 结束范围}})查询字段位于之间的文档 &amp;lt小于 &amp;gt大于 Person.find({age:{$gt:20,$lt40}}).then(result=&gt;console.log(result))find({字段:{$in:包含项}}) Person.find({hobbies:{$in:[&#39;sing&#39;]}}).then(result=&gt;console.log(result))find().select(&#39;字段1，字段2..&#39;)查询指定字段，字段前加-，可以去除字段 Person.find().select(&#39;name,age,-id&#39;).then(result=&gt;console.log(result))find().sort(&#39;排序字段&#39;)默认按升序排序，加-按降序排序 Person.find().sort(&#39;-age&#39;).then(result=&gt;console.log(result))find().skip(跳过的条数).limit(限制显示结果的条数) Person.find.skip(2).limit(3).then(result=&gt;console.log(result))findOne()返回指定集合第一个文档 Person.findOne().then(result=&gt;console.log(result))findOne({条件})返回指定集合满足条件的第一个文档 Person.findOne({age:14}).then(result=&gt;console.log(result))删除文档查找一条文档并且删除，返回的是删除的文档，匹配多个文档会删除第一条 Person.findOneAndDelete({name:&#39;张三&#39;}).then(result =&gt; console.log(result))删除多个文档，不加条件会删除全部文档 Person.deleteMany({}).then(result =&gt; console.log(result))更新文档更新一条文档 Person.updateOne({ name: &#39;李四&#39; }, { name: &#39;李小四&#39;, age: 18 }).then(result =&gt; console.log(result))更新全部文档 Person.updateMany({}, { age: 0 }).then(result =&gt; console.log(result))mongoose验证在集合规则中有很多验证规则 required必填项，typt字段类型，minlength最小长度，maxlength最大长度，min最小值，max最大值，trim:true去掉首尾空格，default默认值，enum:{values:[]}枚举，validate:{validator:v=&gt;{return v&amp;&amp;v.length&gt;4}}自定义验证程序 message错误提示的获得，在向集合插入文档时的错误信息定义成如下 .catch(error =&gt; { // 获取错误信息对象 const err = error.errors; // 循环错误信息对象 for (var attr in err) { // 将错误信息打印到控制台中 console.log(err[attr][&#39;message&#39;]); } })集合关联通常不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联。 使用id对集合进行关联 使用populate方法进行关联集合查询 const userSchema = new mongoose.Schema({ name: { type: String, required: true } }); const postSchema = new mongoose.Schema({ title: String, author: { //类型为id，固定写法 type: mongoose.Schema.Types.ObjectId, //关联集合user ref: &#39;User&#39; } }) const Post = mongoose.model(&#39;Post&#39;, postSchema); const User = mongoose.model(&#39;User&#39;, userSchema) Post.create({ title: &#39;123&#39;, author: &#39;5c0caae2c4e4081c28439791&#39; }).then(result =&gt; console.log(result)); User.create({ name: &#39;李四&#39; }).then(result =&gt; console.log(result)) //populate()关联集合查询 Post.find().populate(&#39;author&#39;).then(result =&gt; console.log(result))","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"mongoDB数据库","slug":"mongoDB数据库","permalink":"https://www.iamys.club/tags/mongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"node.js","slug":"node.js","date":"2020-04-15T16:00:00.000Z","updated":"2020-04-20T12:40:02.383Z","comments":true,"path":"2020/04/16/node.js/","link":"","permalink":"https://www.iamys.club/2020/04/16/node.js/","excerpt":"","text":"node概念node是基于Chrome V8引擎的JavaScript代码运行环境，全局对象是globle，在node环境下使用node命令执行后缀为.js的文件即可 CommonJScommonJS是为js的表现制定规范，因为js没有模块化系统，标准库较少，缺乏包管理工具，CommonJS应运而生，它希望js可以在任何地方运行而不只是浏览器中，从而达到一些后端语言具有开发大型应用的能力。 commonJS与Node.js的关系：CommonJS时模块化的标准，Node.js是CommonJS（模块化）的实现 应用 服务器端js的应用程序Node.js 命令行工具 桌面图形应用程序 node组成ECMAScript和node环境提供的附加API 模块化开发javasript使用存在文件依赖和命名冲突的问题，因而要使用模块化开发，模块化开发的含义是一个功能就是一个模块多个模块可以组成完整的应用，抽离一个模块不会影响其他模块的运行。node.js规定一个JavaScript就是一个模块，模块内部定义的变量和函数外部无法得到，需要使用exports对象进行成员导出，require方法导入其他模块。 模块的导入导出 导出 exports module.exports 两者之间的关系 module.exports 是真正的接口exports是一个辅助工具如果module.exports为空，那么所有的exports属性和方法都赋值module.exports如果module.exports具有任何方法和属性，则exports会被忽略 导入 require 模块 核心模块 node自带的模块加载速度快 http模块 // 引用系统模块 const http = require(&#39;http&#39;); // 创建web服务器 const app = http.createServer(); // 当客户端发送请求的时候 app.on(&#39;request&#39;, (req, res) =&gt; { // 响应 res.end(&#39;&lt;h1&gt;hi, user&lt;/h1&gt;&#39;); }); // 监听3000端口 app.listen(3000); console.log(&#39;服务器已启动，监听3000端口，请访问 localhost:3000&#39;) 请求方式 get 请求数据 数据处理 参数放在地址栏中 参数获取需要借助系统模块url 客户端请求途径：浏览器地址栏 link标签的href属性 script标签的src属性 img标签的src属性 const http = require(&#39;http&#39;); // 导入url系统模块 用于处理url地址 const url = require(&#39;url&#39;); const app = http.createServer(); app.on(&#39;request&#39;, (req, res) =&gt; { // 将url路径的各个部分解析出来并返回对象 // true 代表将参数解析为对象格式 let {query} = url.parse(req.url, true); console.log(query); }); app.listen(3000);​ post 发送数据 实现某种功能 参数再请求体中 获取需要data和end事件 使用querystringstring系统模块将参数转为对象 ​ 客户端请求途径：Form表单提交 // 导入系统模块querystring 用于将HTTP参数转换为对象格式 const querystring = require(&#39;querystring&#39;); app.on(&#39;request&#39;, (req, res) =&gt; { let postData = &#39;&#39;; // 监听参数传输事件 req.on(&#39;data&#39;, (chunk) =&gt; postData += chunk;); // 监听参数传输完毕事件 req.on(&#39;end&#39;, () =&gt; { console.log(querystring.parse(postData)); }); });请求地址 app.on(&#39;request&#39;, (req, res) =&gt; { req.headers // 获取请求报文 req.url // 获取请求地址 req.method // 获取请求方法 });http状态码 200 请求成功 404 请求的资源没有被找到 500 服务器端错误 400 客户端请求有语法错误 url模块 parse 获取地址信息 resolve 追加或替换地址 formal 根据地址信息获得原url信息 fs文件管理 fs.stats 检测是文件还是文档 isDirctory() 是否文档 isFile() 是否文件 fs.mkdir 创建文档 fs.writeFile 创建写入文件 fs.appendFile 追加文件 fs.readdFile 读取文件 fs.readdir 读取文档 fs.rename 重命名或者剪切 fs.rmdir 删除文档 fs.unlink 删除文件 fs.createReadStream 读取流 on读取 fs.createWriteStream 写入流 write写入 end写完 on完成 path模块 path join() 拼接模块 __dirname 当前文件的绝对路径 文件模块用户自己编写的模块，动态加载运行速度相对较慢 模块的加载机制1.require方法根据模块路径查找模块，如果是完整路径，直接引入模块。2.如果模块后缀省略，先找同名JS文件再找同名JS文件夹3.如果找到了同名文件夹，找文件夹中的index.js4.如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件5.如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到 常用的第三方包第三方模块：别人已经写好的，具有特定功能的，我们可以下载直接使用的模块，通常是有多个文件组合在一起放置自在一个文件夹中，又名包。有两种存在形式，以js文件的形式存在，提供项目具体的api接口。以命令行工具存在，辅助项目开发。npmjs.com第三方模块存储和分发厂库 npm：node的第三方模块管理工具下载：npm install/i 模块名卸载：npm uninstall package 模块名命令行工具：全局安装-g 可在计算机任何一个地方使用它库文件：本地安装 nodemon：命令行工具辅助项目开发下载：npm install -g nodemon命令行工具用nodemon命令替代node命令执行文件自动监听文件是否更新，如果更新就自动执行。 nrm ：下载地址切换工具下载：npm install nrm -g查询下载地址：nrm ls切换下载地址：nrm use 下载地址名 一般都是用淘宝镜像来安装 npm install -g cnpm --registry=https://registry.npm.taobao.orgGlup ：基于node的前端构建工具作用：将机械化的操作编写成任务，想要执行这些任务时，可以用一个命令任务就自动执行了，提高开发效率。 具体应用：项目上线，HTML CSS JS文件的压缩合并。 语法转换es6 less之类的 公共文件抽离 修改文件浏览器自动刷新 使用：npm install gulp下载gulp库文件，在项目根目录下建立gulpfile.js文件，用``src目录放置源文件，dist目录放置构建后文件，在gulpfile.js文件中编写任务，在命令行工具执行gulp任务 const gulp = require(&#39;gulp&#39;); // 复制文件夹 gulp.task(&#39;copy&#39;, () =&gt; { gulp.src(&#39;./src/images/*&#39;) .pipe(gulp.dest(&#39;dist/images&#39;)); gulp.src(&#39;./src/lib/*&#39;) .pipe(gulp.dest(&#39;dist/lib&#39;)) }); // 构建任务 gulp.task(&#39;default&#39;, [&#39;htmlmin&#39;, &#39;cssmin&#39;, &#39;jsmin&#39;, &#39;copy&#39;]); gulp中提供的方法 gulp.src():获取任务要处理的文件 gulp.dest() 输出文件 gulp.task() 建立gulp任务 gulp.watach() 监控文件的变化 .pope() 放置要处理的文件 gulp插件插件网址：www.npmjs.com 插件用法：下载 如：npm install gulp-htmlmin 引用：如：require gulp-htmlmin 调用 npm install gulp-cil -g 安装gulp的命令行工具 在文件名为.glupfile.js里面编写任务，相同路径下建立src文件夹存放源文件，在dist目录下存放修改后的文件 gulp-htmlmin html文件的压缩 const gulp = require(&#39;gulp&#39;); const htmlmin = require(&#39;gulp-htmlmin&#39;); const fileinclude = require(&#39;gulp-file-include&#39;); // html任务 // 1.html文件中代码的压缩操作 // 2.抽取html文件中的公共代码 gulp.task(&#39;htmlmin&#39;, () =&gt; { gulp.src(&#39;./src/*.html&#39;) .pipe(fileinclude()) // 压缩html文件中的代码 .pipe(htmlmin({ collapseWhitespace: true })) .pipe(gulp.dest(&#39;dist&#39;)); }); gulp-file-include 公共文件包含 先把公共部分提取到一个单独的文件里，再把需要引入公共部分的地方写上 @@include (‘公共文件的路径’) - gulp-csso 压缩css - gullp-less less语法转换 ``` const less = require(&#39;gulp-less&#39;); const csso = require(&#39;gulp-csso&#39;); // css任务 // 1.less语法转换 // 2.css代码压缩 gulp.task(&#39;cssmin&#39;, () =&gt; { // 选择css目录下的所有less文件以及css文件 gulp.src([&#39;./src/css/*.less&#39;, &#39;./src/css/*.css&#39;]) // 将less语法转换为css语法 .pipe(less()) // 将css代码进行压缩 .pipe(csso()) // 将处理的结果进行输出 .pipe(gulp.dest(&#39;dist/css&#39;)) }); ``` - gulp-bable js语法转换 - gulp-uglify 压缩混淆js ``` const babel = require(&#39;gulp-babel&#39;); const uglify = require(&#39;gulp-uglify&#39;); // js任务 // 1.es6代码转换 // 2.代码压缩 gulp.task(‘jsmin’, () =&gt; { gulp.src(‘./src/js/*.js’) .pipe(babel({ // 它可以判断当前代码的运行环境 将代码转换为当前运行环境所支持的代码 presets: [‘@babel/env’] })) .pipe(uglify()) .pipe(gulp.dest(‘dist/js’)) }); ``` - browsersync 浏览器实时同步package.json文件作用：项目描述文件，记录当前项目信息，可使用npm init -yes/y命令生成。 node_modules文件夹的问题Node规范将模块文件都放在node_modules这个目录 但是如果文件夹和文件过多过碎，我们要把整体文件夹拷贝给别人的时候传输速度会很慢。复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致以免运行报错。 项目依赖项目开发和运营上线都需要依赖的第三方包，使用npm install 包名下载的文件会默认添加到package.js文件的dependencies字段中 dependencies npm install 下载 开发依赖项目开发阶段需要的依赖，线上运营不需要的第三方包，称为开发依赖使用npm install 包名 --save-dev/-D命令将包添加到devDependencies字段中 devDependencies npm install –production 下载 package-lock.js文件的作用锁定包的版本，确保再次下载时不会因为包版本不同而产生问题加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作 Node.js异步编程同步API：只有当前API执行完成后，才能继续执行下一个API，可以从返回值拿到API的执行结果 异步API：当前API的执行不会阻塞后续代码的执行，使用回调函数(自己定义的函数别人调用)可以获取异步API的执行结果 Promise出现的目的是解决Node.js异步编程中回调地狱(也就是后面异步API依赖当前异步API的调用，造成一层层嵌套的关系)的问题。 异步函数异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。 async关键字 const fn = async () =&gt; {};async function fn () {} 普通函数定义前加async关键字 普通函数变成异步函数 异步函数默认返回promise对象 在异步函数内部使用return关键字进行结果返回 结果会被包裹的promise对象中 return关键字代替了resolve方法 在异步函数内部使用throw关键字抛出程序异常 调用异步函数再链式调用then方法获取异步函数执行结果 调用异步函数再链式调用catch方法获取异步函数执行的错误信息 await关键字 await关键字只能出现在异步函数中 await promise await后面只能写promise对象 写其他类型的API是不不可以的 await关键字可是暂停异步函数向下执行 直到promise返回结果","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://www.iamys.club/tags/node-js/"}]},{"title":"初识jQuery","slug":"jQuery","date":"2020-04-09T16:00:00.000Z","updated":"2020-04-11T14:07:22.863Z","comments":true,"path":"2020/04/10/jQuery/","link":"","permalink":"https://www.iamys.club/2020/04/10/jQuery/","excerpt":"","text":"初始jQuery什么是jQueryjQuery是一个快速、简洁的javascript库，它里面封装了JavaScript常用大的功能代码，优化了DOM操作、事件处理、动画设计和Ajax交互，学习jQuery的本质就是学习调用这些函数（方法）； jQuery的优点 轻量级。核心文件才几十kb，不会影响页面大的加载速度 跨浏览器兼容。基本兼容了现在主流大的浏览器 链式编程，隐式迭代 ( 隐式迭代就是把匹配的所有元素内部进行遍历循环) 对事件、样式、动画支持，大大简化大的DOM操作 支持插件扩展开发。有着丰富大的第三方插件，如树形菜单、日期控件、轮播图等 免费、开源 简单的使用jQuery1.jQuery的入口函数 $(function() { $(&#39;div&#39;).hide();//此处是DOM加载完成的入口，相当与原生的DOMContentLoaded })2.jQuery的顶级对象$ ​ $是jQuery的别称，在代码中jQuery和$可以互换 ​ $是jQuery的顶级对象，相当于原生的的window，帮元素利用$包装成jQuery对象，就可以调用jQuery的方法。 DOM对象和jQuery对象的区别 用原生js获取来的对象就是DOM对象 var myDiv = document.querySelector(&#39;div&#39;); // myDiv 是DOM对象 jQuery方法获取的元素就是jQuery对象 $(&#39;div&#39;); // $(&#39;div&#39;)是一个jQuery 对象 jQuery对象的本质是：利用$对DOM对象大的包装后生产的对象（伪数组形式储存） DOM对象和jQuery对象之间是可以相互转换的 因为原生js比jQuery更大，原生的一些属性和方法jQuery没有给我们封装。要是想要这些属性和方法需要把和jQuery对象转换成DOM对象才能使用 DOM对象转换为jQuery对象 $(DOM对象) $(&#39;div&#39;) jQuery对象转换为DOM对象(两种方式) $(&#39;div&#39;)[index] //index是索引号$(&#39;div&#39;).get(index)jQuery的基本操作能写出常用的jQuery选择器基础选择器$(&quot;选择器&quot;) //直接写css选择器，但是一定要加双引号 用法 名称 描述 $(“#id”) Id选择器 获取指定ID元素 $(“*”) 全选选择器 匹配所有元素 $(“.class”) 类选择器 获取同一类元素 $(“div”) 标签选择器 获取同一类标签的所有元素 $(“div,p,li”) 并集选择器 选取多个元素 $(“li.current”) 交集选择器 交集元素 层级选择器 名称 用法 描述 子代选择器 $(“ul&gt;li”) 使用&gt;号，获取亲儿子层级的元素；注意不会获取到孙子层级的元素 后代选择器 $(“ul li”) 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子 筛选选择器 语法 用法 描述 :first $(“li:first”) 获取第一个li元素 :last $(“li:last”) 获取最后一个li元素 :ed(index) $(“li:ed(2)”) 获取li元素中，选择索引号为2的元素 :odd $(“li:odd”) 获取li元素中，选择索引号为奇数的元素 :even $(“li:even”) 获取li元素中,选择索引号为偶数的元素 筛选方法(重点) 语法 用法 说明 parent() $(“li”).parent(); 查找父级 children(selector) $(“ul”).children(“li”); 相当于$(“ul&gt;li”),最近一级(亲儿子) find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“.first”).siblings(“li”); 查找兄弟节点。不包括自己 nextAll([expr]) $(“.first”).nextAll() 查找当前元素之后所有的同辈元素 prevtAll([expr]) $(“.last”).pravAll() 查找当前元素之前所有的同辈元素 hasClass(class) $(“div”).hasClass(“protected”) 查找当前元素是否含有某个特定的类，如果有则返回true eq(index) $(“li”).eq(2) 相当于$(“li:eq(2)”),index从0开始 重点记住：parent() children() find() siblings() eq() 能够操作jQuery样式操作css方法jQuery可以使用css方法来修改简单元素样式；也可以操作类，修改多个样式。 1.参数只写属性名，则返回属性值 $(this).css(&quot;color&quot;);2.参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用单位和引号 $(this.css(&quot;color&quot;,&quot;red&quot;);3.参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不加引号 $(this).css(&quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;20px&quot;)设置类样式方法作用等同于以前的classList，可以操作类样式，注意操作类里面的参数不要加点 1.添加类 $(&quot;div&quot;).addClass(&quot;current&quot;);2.移除类 $(&quot;div&quot;).removeClass(&quot;current&quot;);3.切换类 $(&quot;div&quot;).toggleClass(&quot;current&quot;);类操作与ClassName区别原生js中的ClassName会覆盖原先里面的类名 jQuery里面的类操作只是对指定类进行操作，不会影响原先的类名。 能够写出常用的jQuery动画1.显示隐藏 show() hide() toggle()show([speed,[easing],[fn]]) //(1) 参数都可以省略，无动画直接显示 (2)speed：三种预定速度之一的字符串(&quot;slow&quot;,&quot;narmal&quot;,&quot;fast&quot;)或者表示动画时长的毫秒数值 (3)easing:(Optional)用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;. (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次 下面的相同2.滑动 sideDown() sideUp() sideToggle()3.淡入淡出 fadeIn() fadeOut() fadeToggle() fadeTo()fadeTo(speed,opacity,[easing],[fn]) //(1)opacity 透明度必须写，取值0-1之间 (2)speed 三种预定速度之一的字符串(&quot;slow&quot;,&quot;narmal&quot;,&quot;fast&quot;)或者表示动画时长的毫秒数值必须写4.自定义动画 animate()animate(params,[speed],[easing],[fn]) //params 想要更改的属性，以对象的形式传递，必须写，属性名可以不写引号，复合属性采用驼峰命名方式5.动画或效果队列及其停止排队方法动画或者效果一旦触发就会执行，如果多次触发，就会造成多个动画或者效果排队执行。 stop() //用于停止动画或者效果，一定要写到动画前面，相当于停止结束上一次的动画能够操作jQuery属性设置获取元素固有属性值prop()所谓元素固有属性就是元素本身自带的属性； 1.获取属性的语法prop(&quot;属性&quot;)2.设置属性语法prop(&quot;属性&quot;，&quot;属性值&quot;)设置或获取元素自定义属性attr()用户给元素添加大的属性； 1.获取属性语法attr(&quot;属性&quot;) //类似原生getAttribute2.设置属性语法attr(&quot;属性&quot;,&quot;属性值&quot;) //类似原生setAttribute数据缓存data()data() 方法可以在指定的元素上存取数据，并不会修改DOM元素结构。一旦页面刷新，之前存放的数据都会移除。 1.附加数据语法data(&quot;name&quot;,&quot;value&quot;) //向被选元素附加数据2.获取数据语法data(&quot;name&quot;) //向被选元素获取数据同时还可以读取HTML5自定义属性data-index，得到的是数字型 能够操作jQuery元素内容文本值主要针对元素的内容还有表单的值操作 1.普通元素内容html()(相当于原生inneHTML)html() //获取元素的内容html(&quot;内容&quot;) //设置元素的内容2.普通元素文本内容text() (相当与原生innerText)text() //获取元素文本内容text(&quot;文本内容&quot;) //设置元素文本内容3.表单的值val()(相当于原生value)遍历元素jQuery隐式迭代是对同一类元素作了同样的操作，如果想要给同一类做不同的操作，就要用到遍历 语法1$(&quot;div&quot;).each(function(index,domEle){xxx;})1.each()方法遍历匹配的每一个元素。主要用DOM处理。each每一个 2.里面大的回调函数有两个参数：index是每个元素的索引号；domEle是每隔DOM元素对象不是jQuery对象 3.所以想要使用jQuery方法，需要给这个dom元素转换为jQuery对象$(domEle) 语法2$.each(object,function(index,element){xxx;})1.$.each()方法可用于遍历任何对象，主要是数据处理。比如数组对象 2.里面的函数有2个参数：index是每个元素的索引号；element遍历内容 添加元素1.内部添加element.append(&quot;内容&quot;)把内容放入匹配元素内部最后面，类似原生appendChild element.prapend(&quot;内容&quot;)2.外部添加element.after(&quot;内容&quot;) //把内容放入目标元素后面element.before(&quot;内容&quot;) //把内容放入目标元素前面内部添加元素，生成之后，他们是父子关系 外部添加元素，生成之后，他们是兄弟关系 删除元素element.remove() //删除匹配的元素（本身）element.empty() //删除匹配的元素集合中的所有子节点element.html(&quot;&quot;) //清空匹配的元素内容事件处理事件处理on()绑定事件on()方法在匹配元素上绑定一个或多个事件处理函数 element.on(events,[selector],fn)1.events:一个或多个空格分隔的事件类型，如click或者keydown 2.selector：元素的子元素选择器 3.fn：回调函数，即绑定在元素身上的侦听函数 on()方法的优势1.可以绑定多个事件 多个事件处理程序$(&quot;div&quot;).on({ mouseover:function(){}, mouseout:function(){}, click:function(){} });如果事件处理程序相同 $(&quot;div&quot;).on(&quot;mouseover mouseout&quot;,function(){ $(this).toggleClass(&quot;current&quot;); });2.可以事件委派操作，事件委派的定义就是，把原来加给子元素事件绑定在父元素身上，就是把事件委派给父元素$(&#39;ul&#39;).on(&#39;click&#39;,&#39;li&#39;,function(){ alert(&#39;hello world!&#39;); });在此之前有bind(),live() delegate()等方法来处理事件绑定或者事件委派，最新版用on代替他们 3.动态创建的元素，click()没有办法绑定事件，on()可以给动态生成的元素绑定事件事件处理off()解绑事件off()方法可以移除通过on()方法添加的事件处理程序 $(&quot;p&quot;).off() //解绑p元素所有事件处理程序 $(&quot;p&quot;).off(&quot;click&quot;) //解绑p元素上面的点击事件 $(&quot;ul&quot;).off(&quot;click&quot;,&quot;li&quot;); //解绑事件委托如果事件只想触发一次，可以使用one()来绑定事件 自动触发事件trigger()有些时间希望自动触发，比如轮播图自动播放功能跟点击右侧按钮一致，可以利用定时器自动触发右侧按钮的点击事件，不必鼠标点击触发 element.click() //第一种简写方式element.trigger(&quot;type&quot;) //第二种自动触发模式$(&quot;p&quot;).on(&quot;click&quot;,function(){ alert(&quot;hi~&quot;); }); $(&quot;p&quot;).trigger(&quot;click&quot;); //此时自动触发点击事件，不需要鼠标点击jQuery事件对象事件被触发，就会有事件对象的产生。 element.on(events,[selector],function(event){})阻止默认行为：event.preventDefault() 或者 return false 阻止冒泡：event.stopPropagation jQuery对象拷贝如果想要把某个对象拷贝（合并）给另外一个对象使用，此时可以使用$.extend()方法 $.extend([deep],target,object,[objectN])1.deep:如果设为true为深拷贝，默认false为浅拷贝 2.target：要拷贝的目标对象 3.object1：代拷贝到第一个对象的对象 4.objectN：待拷贝到第N个对象的对象 5.浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象 6.深拷贝，前面加true，完全克隆（拷贝的对象，而不是地址），修改的目标对象不会影响被拷贝的对象。 jQuery多库共存jQuery使用$作为标识符随着jQuery的流行，其他js库也用这$作为标识符，这样一来就会引起冲突。需要一个解决方案，让jQuery和其他的js和其他的js库不存在冲突，可以同时存在。这就叫做多库共存。 解决方案1.把里面的$符号统一改为jQuery。比如jQuery(“div”) 2.jQuery变量规定新的名称：$.noConflict() 如： var xxx =$.noConflict(); jQuery插件1.jQuery插件库 http://www.jq22.com/ 2.jQuery之家http://www.htmleaf.com/ 使用步骤1.引入相关文件（jQuery文件和插件文件） 2.复制相关的html，css，js（调用插件） 常用插件1.瀑布流 2.图片懒加载(图片使用延迟加载在可提高网页下载速度，它也能帮助减轻服务器负载) 当我们页面滑动得到可视区域，在显示图片，使用插件库的EasyLazyload，注意此时引入的文件和js调用必须写在DOM元素（图片）最后面 3.全屏滚动（fullpage.js) GitHub：https://github.com/alvarotrigo/fullPage.js 中文翻译网：http://www.dowebok.com/demo/2014/77/ bootstrap中文文档https://v3.bootcss.com 能够操作jQuery元素尺寸、位置jQuery尺寸 语法 用法 width()/height() 取得匹配元素宽度和高度值 只算width/height innerWidth() /innerHeight() 取得匹配元素宽度和高度值 包含padding outerWidth()/outerheight() 取得匹配元素的宽度和高度值 包含padding、border outerWidth(ture)/outerHeight(ture) 取得匹配元素宽度和高度值 包含padding、border、margin 以上参数为空，则是获取相应值，返回的是 数字型 如果参数为数字，则是修改相应值 参数可以不必写单位 jQuery位置位置主要有三个：offset()、position()、scrollTop()/scrollLeft() 1.offset()设置或获取元素偏移offset()方法设置或返回被选中元素相当于文档的偏移坐标，跟父级没有关系 该方法有2个属性left、top、offset()、top 用于获取距离文档顶部的距离，offset().left用于获取距离文档左侧的距离。 可以设置元素的偏移：offset({top:10,left:30}); 2.position() 获取元素偏移position()方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准。这个方法只能获取不能设置偏移。 3.scrollTop() /scrollLeft()设置或获取元素被卷去的头不和左侧srcollTop()方法设置或返回被选元素被卷去的头部","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.iamys.club/tags/jQuery/"}]},{"title":"初识vue","slug":"vue基础","date":"2020-04-09T16:00:00.000Z","updated":"2020-04-20T12:36:47.999Z","comments":true,"path":"2020/04/10/vue基础/","link":"","permalink":"https://www.iamys.club/2020/04/10/vue%E5%9F%BA%E7%A1%80/","excerpt":"","text":"vue模块语法Vue概述声明式渲染&gt;组件系统&gt;客户端路由&gt;集中式状态管理&gt;项目构建 优点：易用、灵活、高效 Vue基本使用目标：能够说出Vue基本用法 vue的基本使用步骤 提供标签填充数据 引入vue.js库文件 可以使用vue的语法做功能 把vue提供的数据填充到标签中 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{msg}} &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;Hello Vue&#39; //在页面中打印这段字符 } }); &lt;/script&gt;细节分析： 实例参数分析 el：元素的挂载位置（值可以是css选择器，也可以是DOM元素） data：模型数据（值是一个对象） 插值表达式用法 将数据填充到HTML标签中 插值表达式支持基本计算 vue代码运行原理分析 vue代码通过可以通过vue框架编译成原生js代码 Vue模板语法目标：能够说出Vue的模板语法 模板语法概述如何理解前端渲染：把数据填充得HTML中 前端渲染的方式 原生js拼接字符串 使用前端模板引擎 使用vue特有的模板语法 模板语法概述 插值表达式 指令 事件绑定 属性绑定 样式绑定 分支循环结构 指令什么是指令 指令的本质就是自定义属性 指令的格式:以v-开始 v-cloak指令用法先提供样式,再在插值表达式中添加v-cloak指令 &lt;style&gt; [v-cloak] { display: none; } &lt;/style&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-cloak&gt;{{msg}}&lt;/div&gt; &lt;/div&gt; 插值表达式存在的问题:闪动 如何解决该问题:使用v-cloak指令 解决问题的原理:先隐藏,替换好值之后显示最终的值 数据绑定指令 v-text填充纯文本 相比插值表达式更加简洁 v-html填充HTMl片段 存在安全问题 只能本网站内部可以用 v-pre填充原始信息 显示原始信息,跳过编译过程 数据的响应式 如何理解响应式? h5中的响应式就是屏幕尺寸变化导致的样式变化,数据的响应式就是数据的变化导致页面内容的变化 什么是数据绑定?将数据填充到标签中 v-once 只编译一次,显示内容之后不再具有响应式功能 &lt;div v-once&gt;{{info}} &lt;/div&gt;双向数据绑定什么是双向数据绑定?当在表单输入域输入字符是页面的内容也会有所变化. 双向数据绑定分析v-model指令 &lt;div id=&quot;app&quot;&gt; &lt;div v-text=&#39;uname&#39;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; v-model=&#39;uname&#39;&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { uname: &#39;&#39; } }) &lt;/script&gt;MVVM设计思想M(model) 模型 js对象 V(view) 视图 页面的DOM VM(View-Model) 视图模型 Vue DOM监听+数据绑定 视图和模型可以通过视图模型相互访问,也就是DOM元素和js对象通过Vue相互转换 事件绑定vue如何处理事件用v-on指令实现事件绑定 事件函数的调用方式事件函数参数的传递 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{num}} &lt;/div&gt; &lt;button v-on:click=&#39;num++&#39;&gt;点击3&lt;/button&gt; &lt;!-- 事件绑定简写形式 --&gt; &lt;button @click=&#39;num++&#39;&gt;点击4&lt;/button&gt; &lt;!-- 事件绑定函数名 默认会传递事件对象 它为第一个参数 --&gt; &lt;button v-on:click=handle1&gt;点击1&lt;/button&gt; &lt;!-- 事件绑定函数调用 可以传递参数 事件对象必须是最后一个参数 参数名必须是$event --&gt; &lt;button v-on:click=handle2(123,456,$event)&gt;点击2&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { num: 0 }, methods: { handle1: function(event) { console.log(event.target.innerHTML); }, handle2: function(a, b, event) { // 调用参数必须写this，它指向实例对象 this.num++ console.log(a, b, event.target.innerHTML); } } }); &lt;/script&gt;事件修饰符.stop阻止冒泡 &lt;a v-on:click.stop=&#39;handle&#39;&gt;&lt;/a&gt;.prevent 阻止默认行为 &lt;a v-on:click.prevent=&#39;handle&#39;&gt;&lt;/a&gt;按键修饰符.enter回车键 &lt;input v-on:keyup.enter=&#39;submit&#39;&gt;.delete删除键 &lt;input v-on:keyup.delete=&#39;handle&#39;&gt;自定义按键修饰符全局config.keyCodes对象 Vue.config.keyCodes.f1=112属性绑定Vue如何动态处理数据v-bind指令实现动态绑定数据 &lt;div id=&quot;app&quot;&gt; &lt;!-- v-bind动态绑定属性:是它的缩写 --&gt; &lt;a v-bind:href=&quot;url&quot;&gt;百度&lt;/a&gt; &lt;!-- &lt;a :href=&quot;url&quot;&gt;百度&lt;/a&gt; --&gt; &lt;button v-on:click=&#39;handle&#39;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { url: &#39;http//www.baidu.com&#39; }, methods: { handle: function() { this.url = &#39;http://itcast.cn&#39;; } } }) &lt;/script&gt;v-model的底层实现原理 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{msg}} &lt;/div&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; v-on:input=&quot;handle&quot;&gt; //v-bind v-on &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;hello&#39; }, methods: { handle: function(event) { this.msg = event.target.value; } } }) &lt;/script&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; v-on:input=&#39;msg=$event.target.value&#39;&gt; &lt;input type=&quot;text&quot; v-model=&#39;msg&#39;&gt;样式绑定class样式处理对象语法 &lt;div v-bind:class=&quot;{active:isActive}&quot;&gt;&lt;/div&gt;数组语法 &lt;div v-bind:class=&quot;[activeClass,errorClass]&quot;&gt;&lt;/div&gt;style样式处理对象语法 &lt;div v-bind:style=&quot;{color:activeColor,fontSize:fontSize} &quot;&gt;&lt;/div&gt;数组语法 &lt;div v-bind:style=&quot;[beseStyle,overrideingStyles]&quot;&gt;&lt;/div&gt;分支循环结构分支结构v-if和v-show的区别循环结构v-for遍历数组 &lt;li v-for=&#39;item in list&#39;&gt;{{item}}+{{index}}&lt;/li&gt;key的作用：帮助Vue区分不同的元素，从而提高性能 &lt;li :key=&#39;item.id&#39; v-for=&#39;{item,index} in list&#39;&gt;{{item}}+{{index}}&lt;/li&gt;基础案例简易计算器 通过v-nodel指令实现数值a和数值b的绑定 给计算按钮绑定事件,实现计算逻辑 将计算结果绑定到对应位置 &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;简单计算器&lt;/h1&gt; 数字1：&lt;input type=&quot;text&quot; v-model=&#39;a&#39;&gt;&lt;br&gt; 数字2： &lt;input type=&quot;text&quot; v-model=&#39;b&#39;&gt;&lt;br&gt; &lt;button v-on:click=&#39;handle&#39;&gt;计算&lt;/button&gt; &lt;span v-text=&#39;result&#39;&gt;计算结果：&lt;/span&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { a: &#39;&#39;, b: &#39;&#39;, result: &#39;&#39; }, methods: { handle: function() { this.result = parseInt(this.a) + parseInt(this.b); } } }) &lt;/script&gt;tab栏切换 实现静态dUI效果： 用传统的方式实现标签结构和样式 基于数据重构UI效果：将静态的结构和样式重构基于Vue模板语法的形式，处理事件绑定和逻辑控制 &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;tab&quot;&gt; &lt;ul&gt; &lt;li v-on:click=&#39;change(index)&#39; :class=&#39;currentIndex==index?&quot;active&quot;:&quot;&quot;&#39; :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;&gt;{{item.title}} &lt;/li&gt; &lt;/ul&gt; &lt;div :class=&#39;currentIndex==index?&quot;current&quot;:&quot;&quot;&#39; :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;&gt; &lt;img :src=&quot;item.path&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { currentIndex: 0, //选项卡的当前索引 list: [{ id: 1, title: &#39;apple&#39;, path: &#39;images/01.jpg&#39; }, { id: 2, title: &#39;orange&#39;, path: &#39;images/02.jpg&#39; }, { id: 3, title: &#39;lemon&#39;, path: &#39;images/03.jpg&#39; }] }, methods: { change: function(index) { this.currentIndex = index; } } }) &lt;/script&gt;声明式编程：模板的结构和最终显示的效果基本一致 Vue常用特性目标：能够说出Vue的常用特性 表单操作 input单行文本 直接值文本域中添加v-model=’uname’,然后再到data里面给uname初始值 textarea多行文本 直接值文本域中添加v-model=’dect’,然后再到data里面给dect初始值 select下拉多选 单选方式 v-model=”occupation” 再到data里给一个初始值，多选方式 v-model=”occupation” multiple 数组的形式给初始值（给每个选项一个单独的value值） redio单选框 v-model=”gender ，data中给初始值（每个选项给一个value值） checkbox多选框 v-model=”hobby” data里以数组的方式给一个初始值（每个选项给一个单独的value值） 表单修饰符 number：转化为数值 trim：去掉开始和结尾空格 lazy：将input事件切换为change事件 &lt;input type=&quot;text&quot; v-model.number=&#39;age&#39;&gt;自定义指令当内置指令不满足要求时我们需要自定义指令 自定义的语法规则 //自定义获得焦点指令 Vue.directive(&#39;focus&#39;, { inserted: function(el) { //el表示指令所绑定的元素 el.focus(); } });自定义的指令用法 &lt;input type=&quot;text&quot; v-focus&gt;带参数的自定义属性 directives: { color: { bind: function(el, binding) { el.style.backgroundColor = binding.value; } }, focus: { //定义在实例中的局部指令 inserted: function(el) { el.focus(); } } }指令的用法 &lt;input type=&quot;text&quot; v-color=&quot;msg&quot;&gt; &lt;input type=&quot;text&quot; v-focus&gt;计算属性表达式可能比较复杂的时候，使用计算属性可以使模板内容更加简洁 计算属性的用法 computed: { reverseString: function() { return this.msg.split(&#39;&#39;).reverse().join(&#39;&#39;); //反转字符串 } }过滤器格式化数据，比如将字符串格式转换为首字符大写，将日期格式 转化为指定的格式 自定义过滤器 Vue.filter(&#39;upper&#39;, function(val) { return val.charAt(0).toUpperCase() + val.slice(1); //将第一个字母转换为大写slice字符截取 });过滤器的用法 &lt;div&gt;{{msg|upper}}&lt;/div&gt; &lt;div&gt;{{msg|upper|lower}}&lt;/div&gt; &lt;div :abc=&quot;msg|upper&quot;&gt;测试&lt;/div&gt;局部过滤器 filters: { upper: function(val) { return val.charAt(0).toUpperCase() + val.slice(1); } }带参数的过滤器Vue.filter(&#39;format&#39;,function(Value,arg)){ //value就是过滤器传过来的参数 }过滤器的使用&lt;div&gt;{{data|format('yyyy-MM-dd')}}&lt;/div&gt;侦听器在数据变化使执行异步或开销较大的操作可以使用侦听器 侦听器的用法 methods: { checkName: function(uname) { //使用定时任务模拟接口调用 var that = this; setTimeout(function() { if (uname == &#39;admin&#39;) { that.tip = &#39;用户名已存在，请更换一个&#39;; } else { that.tip = &#39;用户名可以使用&#39;; } }, 1000); } }, watch: { uname: function(val) { //调用后台接口验证用户名的合法性 this.checkName(val); //修改提示信息 this.tip = &#39;用户名正在验证…&#39;; } }生命周期主要阶段 挂载（初始化相关属性） beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用 created 在实例创建完成后立即被调用 beforeMount 在挂载开始之前被调用 mounted 被新创建的vm.$el替换，并挂载到实例上去时候调用该钩子 更新（元素或组件的变更操作） beforeUpdate 数据更新使调用，发生在虚拟DOM打补丁之前 updated 由于数据更改导致虚拟DOM重新渲染和打补丁在这之后会调用该钩子 销毁（销毁相关属性）关属性） beforeDestroy 实例销毁之前调用 destroyed 实例销毁之后调用 综合案例目标：能够基于Vue实现案例效果","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.iamys.club/tags/vue/"}]},{"title":"JavaScript进阶","slug":"js高级","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-10T06:50:46.219Z","comments":true,"path":"2020/04/06/js高级/","link":"","permalink":"https://www.iamys.club/2020/04/06/js%E9%AB%98%E7%BA%A7/","excerpt":"","text":"1.面向对象和类的继承什么是面向对象面向对象是把事务分解成一个一个对象，以对象来划分问题，然后对象之间分工与合作。 面向对象的程序思维中，每一个对象都是功能中心，具有明确的分工。 面向对象编程具有灵活，代码可复用、容易维护和开发大的优点，适合多人合作的大型软件项目 面向对象的特性：封装性、继承性、多态性 面向对象的思维特点：1.抽取（抽象）对象公用的属性和行为组织（封装）成一个类（模板） 2.对类进行实例化，获取类的对象 面向对象编程我们考虑的是有哪些对象，按照面向对象的思维特点不断的创建对象，使用对象，指挥对象做事情 类和对象的关系对象对象是一个具体的事务，在javascript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象。 对象是由属性和方法组成的 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 类class在ES6中添加了类的概念，可以使用class关键字声明一个类，之后这个类来实例化对象。 类抽象了对象的公共部分，它泛指某一大类（class） 对象特指某一个，通过类实例化的一个具体的对象 使用class创建自定义类语法：class name{ //class body }创建实例：var xx = new name;注意：类必须使用new实例化对象 类的constructor构造函数constructor()方法是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有显示定义，类内部会自动给我们创建一个constructor() 类添加方法语法： class Person{ constructor(name,age){ this.name=name; this.age=age; } say(){ console.log(this.name+&#39;你好&#39;)； } }什么是继承子类可以继承父类的一些属性和方法。 语法：class Father{ } class Son extends Father{ }super关键字super关键字用于访问和调用父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数 调用构造函数语法：class Person { //父类 constructor(surname){ this.surname = surname; } } class Student extends Person { //子类继承父类 constructor(surname,firstname){ super(surname); //调用父类的constructor(surname) this.firstname = firstname; //定义子类独有的属性 } }注意：子类在构造函数中使用super，必须放在this前面（必须先调用父类的构造方法在使用子类构造方法） 调用普通函数语法：class Father{ say(){ return &#39;我是爸爸&#39;; } } class Son extends Father { say(){ //super.say() super调用父类方法 return super.say()+&#39;的儿子&#39;; } } var damo = new Son(); console.log(damo.say());注意：在继承中的属性和方法查找原则是就近原则，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就执行子类的，如果没有就在父类中找有没有这个方法，如果有就执行父类的这个方法。 四个注意点1.在ES6中类没有变量提升，所以先定义类，再实例化对象 2.类里面的共用属性和方法一定要加this使用 3.类里面的this指向问题 4.constructor里面的 this指向实例化对象，方法里面的this指向这个方法的调用者 2.构造函数和原型使用构造函数创建对象概述在ES6之前没有引入类的概念，所以对象不是基于类创建的，而是 一种称为构造函数的特殊函数来定义对象和他们的特征 创建对象可以通过以下三种方式： 1，对象字面量 2，new Object() 3,自定义构造函数 构造函数构造函数是一种特殊的函数 ，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用，我们可以把对象中的共有属性和方法抽取出来，然后封装到这个函数里面 在js中使用构造函数要注意以下两点： 1.构造函数用于创建一类对象，其首字母要大写 2.构造函数要和new一起使用才有意义 new在执行时会做四件事情：1.在内存中创建一个新的空对象 2.让this指向这个新的对象 3.执行构造函数的代码，给这个新对象添加属性和方法 4.返回这个新对象（所以构造函数里面不需要return） 成员分类JavaScript的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this上添加。通过这两种方法添加的成员，就分别称为静态成员和实例成员 静态成员：在构造函数本身上添加的成员为静态成员，只能由构造函数 本身来访问 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问 构造函数的问题构造函数的方法虽然很好用，但是存在浪费内存的问题，因为如果构造函数里面添加了方法这种复杂数据类型，我们每实例化一个对象就会开辟新的空间存放这种复杂数据类型，这样是很没有必要的，所以就有了构造函数的原型prototype 原型的作用构造函数原型prototype构造函数通过分配的函数是所有对象所共享的。 JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype就是一个对象，这个对象的所有属性和方法都会被构造函数所拥有。 function Star(uname, age) { this.uname = uname; this.age = age; // this.sing = function() { // console.log(&#39;我会唱歌&#39;); // } } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); console.log(ldh.sing === zxy.sing); ldh.sing(); zxy.sing(); // 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上我们可以把一些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。 问答 1.原型是什么？ 一个对象，我们也称为原型对象 2.原型的作用是什么？ 共享方法 对象原型 proto对象都有一个属性proto指向构造函数的原型对象prototype，之所以我们对象可以使用构造函数prototype原型对象的方法和属性，就是因为对象有proto原型存在。 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); ldh.sing(); console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype console.log(ldh.__proto__ === Star.prototype); // 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing // 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法 对象原型proto和原型对象prototype是等价的 proto对象原型大的意义在于为对象的查找机制提供了一个方向，或者说是一条路线，但是它是一个非标准属性，因此在实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype constructor构造函数对象原型__proto __和构造函数原型对象prototype里面都有一个属性constructor属性，constructor我们称为构造函数，因为它指回构造函数本身。 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype = { // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数 constructor: Star, sing: function() { console.log(&#39;我会唱歌&#39;); }, movie: function() { console.log(&#39;我会演电影&#39;); } } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); console.log(Star.prototype); console.log(ldh.__proto__); console.log(Star.prototype.constructor); console.log(ldh.__proto__.constructor);constructor主要用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数 构造函数、实例、原型对象三者之间的关系原型链 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); // 1. 只要是对象就有__proto__ 原型, 指向原型对象 console.log(Star.prototype); console.log(Star.prototype.__proto__ === Object.prototype); // 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototype console.log(Object.prototype.__proto__); // 3. 我们Object.prototype原型对象里面的__proto__原型 指向为 null 扩展内置对象可以通过原型对象，对原来内置对象进行扩展自定义的方法，比如给数组增加自定义求偶数和的功能。 注意：数组和字符内置对象不能给原型对象覆盖操作Array.prototype = {},只能是Array.prototype.xxx = function(){}的方式 Array.prototype.sum = function() { var sum = 0; for (var i = 0; i &lt; this.length; i++) { sum += this[i]; } return sum; }; var arr = [1, 2, 3]; console.log(arr.sum()); console.log(Array.prototype); var arr1 = new Array(11, 22, 33); console.log(arr1.sum());访问对象成员的规则JavaScript成员查找机制 1.当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 2.如果没有就查找它的原型（也就是proto指向的prototype原型对象） 3.如果还没有就查找原型对象的原型（Object的原型对象） 4.依次类推一直到找到Object为止（null） 5.proto对象原型的意义在于为对象成员查找机制提供了一个方向，或者说是一条线路 继承ES6之前并没有给我们提供extends继承，我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承 call()调用这个函数，并且修改函数运行时的this指向 fun.call(thisArg,arg1,arg2,……)thisArg：当前调用函数this的指向函数 arg1，arg2：传递的其他参数 function fn(x, y) { console.log(&#39;我想喝手磨咖啡&#39;); console.log(this); console.log(x + y); } var o = { name: &#39;andy&#39; }; // 1. call() 可以调用函数 fn.call(); // 2. call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象 fn.call(o, 1, 2); function Father(uname, age) { // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; } function Son(uname, age, score) { // this 指向子构造函数的对象实例 Father.call(this, uname, age);// 借用父构造函数继承属性 this.score = score; } Son.prototype = new Father(); //借用原型对象继承方法 // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数 Son.prototype.constructor = Son; // 这个是子构造函数专门的方法 Son.prototype.exam = function() { console.log(&#39;孩子要考试&#39;); } var son = new Son(&#39;刘德华&#39;, 18, 100); console.log(son);ES5新增的一些方法数组方法 迭代（遍历）方法：forEach()、map()、filter()、some()、every() array.forEach(function(currenValue,index,arr))currentValue:相当于当前项的值 index：数组当前项的索引 arr：数组对象本身 // forEach 迭代(遍历) 数组 var arr = [1, 2, 3]; var sum = 0; arr.forEach(function(value, index, array) { console.log(&#39;每个数组元素&#39; + value); console.log(&#39;每个数组元素的索引号&#39; + index); console.log(&#39;数组本身&#39; + array); sum += value; }) console.log(sum);array.filter(function(currenValue,index,arr))filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组，它直接返回一个新的数组。 // filter 筛选数组 var arr = [12, 66, 4, 88, 3, 7]; var newArr = arr.filter(function(value, index) { // return value &gt;= 20; return value % 2 === 0; }); console.log(newArr);array.some(function(currenValue,index,arr))some()方法用于检测数组中的元素是否满足指定条件，就是查找数组中是否有满足条件大的元素，它返回值是布尔值，如果查找这个元素就返回true，找不到就返回false var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;]; // 如果查询数组中唯一的元素, 用some方法更合适, arr.some(function(value) { if (value == &#39;green&#39;) { console.log(&#39;找到了该元素&#39;); return true; // 在some 里面 遇到 return true 就是终止遍历 迭代效率更高 } console.log(11); });字符串方法 trim()方法会从一个字符串的两端删除空白字符 str.trim()trim()方法并不影响原字符串本身，它返回的是一个新的字符串。 对象方法 Object.keys()用于获取对象自身的所有属性 Object.keys(obj)效果类似for…in 返回一个由属性名组成的数组 // 用于获取对象自身所有的属性 var obj = { id: 1, pname: &#39;小米&#39;, price: 1999, num: 2000 }; var arr = Object.keys(obj); console.log(arr); arr.forEach(function(value) { console.log(value); })Object.defineProperty()定义新属性或修改原有的属性 Object.defineProperty(obj,prop,descriptor)Object.defineProperty()第三个参数descriptor说明：以对象形式{}书写 value：设置属性的值 默认为undefined writable：值是否可以重写。true|false 默认为false enumerable：目标属性是否可以被枚举。true|false 默认false configurable：目标属性是否可以被删除或是否可以再次修改特性true|false 默认是false 3.函数进阶说出函数的多种定义和调用方式函数的定义方式1.函数声明方式function关键字（命名函数） function fn(){};2.函数表达式（匿名函数) var fun = function(){};3.new Function() var fn = new Function(&#39;参数1&#39;，&#39;参数2&#39;……,&#39;函数体&#39;) Function里面的参数必须是字符串格式 这种方式执行效率低，也不方便使用，因此使用较少 所有的函数都是Function的实例（对象） 函数也属于对象 函数的调用方式1.普通函数 function fn() { console.log(&#39;这是一个普通函数&#39;); } fn(); fn.call();2.对象的方法 var o = { sayHi: function() { console.log(&#39;这是对象的方法&#39;); } } o.sayHi();3.构造函数 function Star() { console.log(&#39;这是一个大写的构造函数&#39;); } new Star();4.绑定事件函数 var btn = document.querySelector(&#39;button&#39;); btn.onclick = function() { console.log(&#39;这是一个绑定事件函数&#39;); }5.定时器函数 setTimeout(function() { console.log(&#39;这是定时器函数&#39;) }, 1000);6.立即执行函数 (function() { console.log(&#39;这是一个立即执行函数&#39;); })()说出和改变函数内部this的指向函数内的this指向this的指向是当我们调用函数时确定的，调用的方式不同决定了this的指向不同，一般指向调用者。 调用方式 this指向 普通函数调用 window 构造函数调用 实例对象，原型对象里的方法也指向实例对象 对象的方法对象 该方法所属的对象 事件绑定方法 绑定的事件对象 定时器函数 window 立即执行函数 window 改变函数内部的this指向JavaScript提供了函数和方法帮助我们改变函数内部this的指向，常用的有bind() call() apply() call() var o = { name: &#39;andy&#39; } function fn(a, b) { console.log(this); console.log(a + b); } fn.call(o, 1, 23) //可以调用函数，可以改变this指向，可以传递普通参数 //主要应用于继承 function Father(uname, age, sex) { this.uname = uname; this.age = age; this.sex = sex; } function Son(uname, age, sex) { Father.call(this, uname, age, sex); } var son = new Son(&#39;刘德华&#39;, 12, &#39;男&#39;) console.log(son);apply() var o = { uname: &#39;andy &#39; } function fn(arr) { console.log(this); console.log(arr); } fn.apply(o, [&#39;hello&#39;]);//可以调用函数，可以改变this指向，但是第二个参数必须是数组 //apply主要应用于用数学内置函数求数组最大最小值 var arr = [12, 33, 77, 1, 0] var max = Math.max.apply(Math, arr) var min = Math.min.apply(Math, arr) console.log(max, min);bind() var o = { name: &#39;andy&#39; }; function fn(a, b) { console.log(this); console.log(a + b); }; var f = fn.bind(o, 1, 2); //不会调用函数 ，可以改变this的指向，返回的时改变后的新函数 f();// bind()的主要应用：函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind // 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮 var btn = document.querySelectorAll(&#39;button&#39;); for (var i = 0; i &lt; btn.length; i++) { btn[i].onclick = function() { this.disabled = true; setTimeout(function() { this.disabled = false; }.bind(this), 2000) } }说出严格模式的特点严格模式（strict modes）JavaScript变体的一种方式，即在严格的条件下运行js代码，它对正常的js语义做了一些更改： 消除了JavaScript语法的一些不合理，不谨慎之处，减少了一些怪异行为 消除了代码运行的不安全之处，保证了代码运行的安全 提高编译器效率，增加运行速度 禁用了ECMAScript的未来版本中可能会定义的一些语法，为未来的JavaScript做好了铺垫。 开启严格模式严格模式可以应用到整个脚本或个别函数中，因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。 为脚本开启严格模式&lt;scprit&gt; &#39;use strict&#39;; console,log(&quot;这是严格模式&quot;); &lt;/scprit&gt; //不常用，影响文件合成为函数开启严格模式 &lt;script&gt; (function() { &#39;use strict&#39;; })(); &lt;/script&gt;严格模式中的变化变量的变化 在正常模式下如果一个变量未声明就赋值默认是全局变量，在严格模式下禁止这样使用变量必须先用var声明再使用。 严禁删除已声明的变量 严格模式下this的指向问题 以前全局作用域函数this指向window，严格模式下全局作用域的函数this指向undefined 以前构造函数不加new调用当成普通函数调用且this指向window，严格模式下会报错 new实例化的构造函数还是指向创建的对象实例 定时器this还是指向window 事件、对象还是指向调用者 函数的变化 函数不能有重名的参数 函数必须声明在顶层，不能声明在for if 之类的里面 把函数作为参数和返回值传递高阶函数高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出 function fn(a, b, callback) { console.log(a + b); callback &amp;&amp; callback(); } fn(1, 2, function() { console.log(&#39;我是最后调用的&#39;); });function fn(){ return function() {}; } fn();说出闭包的的作用什么是闭包闭包是指有权访问另一个函数作用域中的变量的函数。简单说就是一个作用域可以访问另一个函数内部的局部变量。 闭包的作用闭包的主要作用：延伸了变量的作用范围 闭包案例循环注册点击事件 var lis = document.querySelectorAll(&#39;li&#39;); for (var i = 0; i &lt; lis.length; i++) { (function(i) { lis[i].onclick = function() { console.log(i); } })(i); }循环中的setTimeout() //3秒钟后打印所有的li var lis = document.querySelector(&#39;.nav&#39;).querySelectorAll(&#39;li&#39;); for (var i = 0; i &lt; lis.length; i++) { (function(i) { setTimeout(function() { console.log(lis[i].innerHTML); }, 3000) })(i) }计算打车价格 说出递归的两个条件什么是递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数，简单的说就是一个函数自己调用自己就是递归函数。递归函数的作用和循环时一样的。由于递归函数很容易发生“栈溢出”错误（stack overflow），所以必须加退出条件return。 递归的两个条件：一自身调用，二退出条件 //利用递归求1-n的阶乘 function fn(n) { if (n == 1) { return 1; } return n * fn(n - 1); } console.log(fn(4));//利用递归求斐波拉及数 function fun(i) { if (i == 1 || i == 2) { return 1; } return fun(i - 1) + fun(i - 2); } console.log(fun(4));说出深拷贝和浅拷贝的区别1.浅拷贝只拷贝一层，更深层次对象级别的只拷贝引用 Object.assign(target,…sources) es6新增的方法可以实现浅拷贝 var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 } }; var o = {}; for (var k in obj) { //k是属性名，obg[k]是属性值 o[k] = obj[k]; } console.log(o); o.msg.age = 20;//这种复杂数据类型拷贝的是地址额，当一个改变原来的也会改变 console.log(obj); Object.assign(o, obj);2.深拷贝拷贝多层，每一次的数据都会拷贝 var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 }, color: [&#39;pink&#39;, &#39;red&#39;] }; var o = {}; //封装函数 function deepCopy(newobj, oldobj) { for (k in oldobj) { var item = oldobj[k]; //判断数据类型 if (item instanceof Array) { newobj[k] = []; deepCopy(newobj[k], item); } else if (item instanceof Object) { newobj[k] = {}; deepCopy(newobj, item); } else { newobj[k] = item; } } } deepCopy(o, obj); o.msg.age = 90;//修改拷贝过的对象里的方法，原对象不会有影响 console.log(o); console.log(obj);4.正则表达式说出正则表达式的作用什么是正则表达式正则表达式是用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象 正则表达式的作用正则表达式通常用检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名，表单只能输入英文字母，数字或下划线，昵称可以输入中文（匹配）；此外，正则表达式还常用于过滤页面中内容的一些敏感词（替换）；或从字符串中提取我们想要的特定部分（提取）。 正则表达式的特点 灵活性、逻辑性和功能性非常强 可以迅速的用极为简单的方法达对字符串的复杂控制 对于刚接触的人可能比较晦涩难懂 实际开发一般都是直接复制写好的正则表达式，但是要求我们能看懂并且根据需求修改 写出简单的正则表达式创建正则表达式1.通过RegExp对象的构造寒素创建 var 变量名 = new RegExp(/表达式/)2.通过字面量创建 var 变量名 = /表达式/;测试正则表达式texttext()正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，其参数式测试字符串 regexobj.text(str) regexobj是写的正则表达式 str是我们要测试的文本 作用是检测str文本是否符合我们写的正则表达式 正则表达式的组成一个正则表达式可以由简答的字符组成，比如/abc/，也可以是简单和特殊字符的组合，比如/ab*c/，其中特殊字符也被称为原字符，在正则表达式中具有特殊意义的符号，如^,$,+等。 边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要由两个字符， 边界符 说明 ^ 表示匹配行首大的文本（从谁开始） $ 表示匹配行尾的文本（以谁结束） 字符类字符类有一系列的字符可供选择，只要匹配其中一个就可以了，所有可供选择的字符都放在方括号中就可以了。[a-z]表示从a到z。方括号里面可以使用字符组合如：[a-zA-Z0-9]；方括号中的^是取反符[^]。 量词符量词符用来设定某个模式出现的次数 量词 说明 * 重复零次或更多次 + 重复一次或更多次 ？ 重复一次或零次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 括号总结 大括号 量词符 里面重复的次数 中括号 字符集合 匹配方括号中的任意字符 小括号 表示优先级 预定义类预定义类表示的是常见模式的简写方式 预定类 说明 \\d 匹配0-9之间的任意一个数字，相当于[0-9] \\D 匹配所有0-9之外的字符，相当于 [ ^ 0-9 ] \\w 匹配任意字母数字下划线，相当于[a-zA-Z0-9_] \\W 匹配所有字母数字下划线以外的字符，相当于[ ^a-zA-Z0-9_] \\s 匹配空格 换行符制表符空格符等 \\S 匹配非空格字符 使用正则表达式对表单进行验证使用正则表达式替换内容raplace()raplace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式 stringObject.replace(regexp/substr,replacement) 第一个参数：被替换的字符串或者正则表达式 第二个参数：替换为大的字符串 返回值十一和替换完毕的新字符串 正则表达式参数/表达式/[switch]switch（也称为修饰符）按照什么样的模式匹配，有三种值 g：全局匹配 i：忽略大小写 gi：全局匹配+忽略大小写 5.ES6ES6概述什么是ES6ES的全ECMAScript，它是由ECMA国际标准化组织制度的一项脚本语言的标准化规范，2015年的版本叫做ES2015，2016年的版本叫做ES2016……所以ES6实际上是泛指ES2015及后续的版本。 为什么要使用ES6每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript本身有一些让人不满意的地方。比如变量的提升特性增加了程序运行的不可预测性，语法过于松散，实现相同的功能不同的人可能写出不同的代码…… 变量letES6中新增的声明变量的关键字 let的特点特点1：let声明的变量只在处于块级有效（大括号中定义的，只在大括号中有效） if(true){ let a =10; } console.log(a); //a is not defined注意：let声明的变量只在块级作用域下有效，但是var声明的变量不具有块级作用域的特性。 特点2：不存在变量提升（不能先用再声明） console.log(a); //a is not defined let a = 10 ;特点3：暂时性死区 var num = 10 if (true) { console.log(num); //因为在块级作用域有let关键字，所以var定义的全局不起作用，let在后面定义前面打印就会出错。 let num = 20; }let的经典面试题 var arr = []; for (var i = 0; i &lt; 2; i++) { arr[i] = function() { console.log(i); } } arr[0](); //2 arr[1](); //2 //关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值 let arr = []; for (let i = 0; i &lt; 2; i++) { arr[i] = function() { console.log(i); } } arr[0](); //0 arr[1](); //1 //关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上 一级（循环每次产生的块级作用域）作用域下的i值常量const作用：声明常量，常量就是值（内存地址）不会发生变化的量 特点1：具有块级作用域 if(true) { const a=10; } console.log(a); //a is not defined特点2：声明常量必须赋值 conts PI; //错误，PI没有赋初值特点3：常量赋值后，值不能修改 const PI = 3.14; PI = 100; //错误：Assignment to constant variable. const ary = [100, 200]; ary[0] = &#39;a&#39;; ary[1] = &#39;b&#39;; console.log(ary); //[&#39;a&#39; ,&#39;b&#39;] ary = [&#39;a&#39;, &#39;b&#39;]; // 错误 Assignment to constant variable.let、const、var的区别 var let const 函数级作用域 块级作用域 块级作用域 变量提升 不存在变量提升 不存在变量提升 值可更改 值可更改 值不可更改 解构赋值ES6中允许从数组中提取值，按照对应的位置对变量赋值，对象也可以实现解构。 数据解构数组解构允许我们按照一一对应的关系从数组中提取值然后将值赋给变量。 let [a, b, c] = [1, 2, 3]; console.log(a); //1 console.log(b); //2 console.log(c); //3当数组中的值和变量不是一一对应关系，变量的值就是undefined let [foot] = []; let [foo, bar] = [11]; console.log(foot, foo, bar); //undefined 11 undefined对象结构let person = { name: &#39;张三&#39;, age: 20 }; let {name,age} = person console.log(name); //张三 console.log(age); //20 let {name: myName} = person; //也可以使用别名获取 console.log(myName);箭头函数ES中新增的定义函数的方式 () =&gt; {} //如下 const fn = () =&gt; { console.log(123); } fn(); //如果函数体中只有一句代码并且代码的执行结果就是函数的返回值，函数体大括号可以省略 const sum = (n1, n2) =&gt; { return n1 + n2; } //可简写为： const sum = (n1, n2) =&gt; n1 + n2; console.log(sum(1, 2)); //如果形参只有一个参数可省略小括号 const fun = (v) =&gt; { alert(v); } //可简写为 const fun = v =&gt; { alert(v) } fun(7);箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this 剩余参数剩余函数允许我们将不定数量的参数表示为一个数组 function sum(first, ...args) { console.log(first); //10 console.log(args); //[20,30,40] } sum(10, 20, 30, 40);剩余参数配合解构使用 let ary = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; let [s1, ...s2] = ary; console.log(s1); //&#39;a&#39; console.log(s2); //[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]Array的扩展方法扩展运算符（展开语法）1.扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。 let ary = [1, 2, 3]; console.log(...ary); //1 2 3 注意这里逗号被当成了log的分隔符2.扩展运算符可以应用于合并数组 let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; console.log(ary3); //[1,2,3,4,5,6] ary1.push(...ary2); console.log(ary1); //[1,2,3,4,5,6]3.扩展运算符可以将类数组或可遍历的对象转换为真正的数组，以便调用数组的方法 let divs = document.querySelectorAll(&#39;div&#39;); let oDivs = [...divs]; oDivs.push(&#39;abc&#39;) console.log(oDivs); //[div, div, div, div, div, &quot;abc&quot;]构造函数的方法：Array.from()1.将类数组或可遍历的数组转换为真正的数组 let arrLike = { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, length: 3 }; let arr = Array.from(arrLike); console.log(arr); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]2.这个方法还可以接受第二个参数，作用类似于数组map方法，用于对每个元素进行处理，将处理后的值放入数组。 let arrLike = { &#39;0&#39;: &#39;2&#39;, &#39;1&#39;: &#39;3&#39;, &#39;2&#39;: &#39;4&#39;, length: 3 }; let arr = Array.from(arrLike, item =&gt; item * 2); console.log(arr); //[4, 6, 8]实例方法:find()用于找出第一个符合条件的数组成员，如果没有找回就返回undefined let ary = [{ id: 2, name: &quot;张三&quot; }, { id: 2, name: &quot;李四&quot; }]; let target = ary.find(item =&gt; item.id == 2); console.log(target); //{id: 2, name: &quot;张三&quot;}实例方法:findIndex()用于找到第一个符合条件的数组成员的位置，如果没有找到返回-1 let ary = [1, 5, 10, 15]; let index = ary.findIndex(value =&gt; value &gt; 9); console.log(index); //2实例方法:includes()表示某个数组是否包含给定值，返回的是布尔值 [1,2,3].includes(2) //trueString的扩展方法模板字符串ES6新增的创建字符串的方式，使用反引号定义 let name = `zhangsan`;模板字符串可以解析变量 let name = `zhangsan`; let sayHello = `hello my name is ${name}`; console.log(sayHello);模板字符串可以换行 let res = { name: &#39;张三&#39;, age: 12 } let html = ` &lt;div&gt; &lt;span&gt;${res.name}&lt;/span&gt; &lt;span&gt;${res.age}&lt;/span&gt; &lt;/div&gt;`; console.log(html);模板字符串可以调用函数 const fn = () =&gt; &#39;我是fn函数&#39; let html = `我是模板字符串 ${fn()}`; console.log(html)实例方法：starsWith()和endsWith() starsWith():表示参数字符串是否在原字符串的头部，返回布尔值 endsWith():表示参数字符串是否在原字符串的尾部，返回布尔值 let str = &#39;Hello ECMAScript 2015&#39;; let r1 = str.startsWith(&#39;Hello&#39;); //true console.log(r1); let r2 = str.endsWith(&#39;2016&#39;); //false console.log(r2)实例方法：repeat()表示将原字符重复n次返回一个新字符串 console.log(&quot;y&quot;.repeat(5)) //yyyyyset数据结构ES6提供了新的数据结构Set，它类似于数组，但成员的值都是唯一的，没有重复的。 Set本身是一个构造函数，用来生成Set数据结构。 const s = new Set();Set 函数可以接受一个数组作为参数，用来初始化。 const set = new Set([1,2,3,4,4]);实例方法 add(Value):添加某个值，返回Set结构本身 delete(value):删除一个值，返回一个布尔值，表示删除是否成功。 has(value):返回一个布尔值，表示该值是否为Set的成员 clear():清除所有成员，没有返回值 const s = new Set(); s.add(1).add(2); //向set结构中添加值 s.delete(2); //删除set结构中的2值 s.has(1) //表示set结构中是否有这个值，返回布尔值 s.clear() //清除s中的所有值遍历Set结构的实例与数组一样，也有forEach方法，用于对每个成员执行某种操作，没有返回值 s.forEach(value =&gt; console.log(value))","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.iamys.club/tags/JavaScript/"},{"name":"EC6","slug":"EC6","permalink":"https://www.iamys.club/tags/EC6/"}]}],"categories":[{"name":"大数据","slug":"大数据","permalink":"https://www.iamys.club/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"},{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"大数据 python爬虫","slug":"大数据-python爬虫","permalink":"https://www.iamys.club/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE-python%E7%88%AC%E8%99%AB/"},{"name":"Ajax","slug":"Ajax","permalink":"https://www.iamys.club/tags/Ajax/"},{"name":"Express框架","slug":"Express框架","permalink":"https://www.iamys.club/tags/Express%E6%A1%86%E6%9E%B6/"},{"name":"mongoDB数据库","slug":"mongoDB数据库","permalink":"https://www.iamys.club/tags/mongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"node.js","slug":"node-js","permalink":"https://www.iamys.club/tags/node-js/"},{"name":"jQuery","slug":"jQuery","permalink":"https://www.iamys.club/tags/jQuery/"},{"name":"vue","slug":"vue","permalink":"https://www.iamys.club/tags/vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.iamys.club/tags/JavaScript/"},{"name":"EC6","slug":"EC6","permalink":"https://www.iamys.club/tags/EC6/"}]}