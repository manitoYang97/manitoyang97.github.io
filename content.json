{"meta":{"title":"XiaoQi's Blog","subtitle":"Serious life.","description":"专注于Web前端,分享生活,分享知识","author":"XiaoQi","url":"https://www.iamys.club","root":"/"},"pages":[{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T12:59:50.241Z","comments":true,"path":"categories/index.html","permalink":"https://www.iamys.club/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T12:58:58.164Z","comments":true,"path":"about/index.html","permalink":"https://www.iamys.club/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T13:00:58.441Z","comments":true,"path":"contact/index.html","permalink":"https://www.iamys.club/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-04-08T13:02:15.797Z","comments":true,"path":"friends/index.html","permalink":"https://www.iamys.club/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-04-08T12:54:45.821Z","comments":true,"path":"tags/index.html","permalink":"https://www.iamys.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vuex","slug":"Vuex","date":"2020-09-28T12:19:07.627Z","updated":"2020-09-28T12:21:35.714Z","comments":true,"path":"2020/09/28/Vuex/","link":"","permalink":"https://www.iamys.club/2020/09/28/Vuex/","excerpt":"","text":"Vuex是一个全局数据管理的一种机制，可以方便的实现数据的共享 使用Vuex管理数据的好处A.能够在vuex中集中管理共享的数据，便于开发和后期进行维护B.能够高效的实现组件之间的数据共享，提高开发效率C.存储在vuex中的数据是响应式的，当数据发生改变时，页面中的数据也会同步更新 使用Vuex只需要在创建项目配置的时候选上vuwx即可，会自动生成以下页面 import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) export default new Vuex.Store({ state: {}, mutations: {}, actions: {}, modules: {} })state提供唯一的公共数据源，所有共享的数据都要统一放在store的state中存储 state: { user: JSON.parse(window.localStorage.getItem(&#39;user&#39;)) }在组件中访问State的方式：1)this.$store.state.全局数据名称 ：this.$store.state.count2).先按需导入mapState函数：import { mapState } from &#39;vuex&#39;然后数据映射为计算属性：computed:{ ...mapState([&#39;全局数据名称&#39;]) } mutations用于修改$store中的数据 mutations: { setUser(state, data) { //第一个形参永远都是state也就是$state对象 //第二个形参是调用setUser时传递的参数 state.user = data //为了数据持久化，把数据放在本地 window.localStorage.setItem(&#39;user&#39;, JSON.stringify(state.user)) }在组件中访问mutations方法 //调用函数名，传递参数 this.$store.commit(&#39;setUser&#39;,data.data) import { mapMutations } from &#39;vuex&#39; methods:{ ...mapMutations([&#39;add&#39;]) }action在mutations中不能编写异步的代码，会导致vue调试器的显示出错。在vuex中我们可以使用Action来执行异步操作。 actions: { addAsync(context,step){ setTimeout(()=&gt;{ context.commit(&#39;add&#39;,step); },2000) } }在组件中访问action方法 methods:{ AddAsync(){ this.$store.dispatch(&#39;addAsync&#39;,5) } }import { mapActions } from &#39;vuex&#39; methods:{ ...mapMutations([&#39;subAsync&#39;]) }gettergetter用于对store中的数据进行加工处理形成新的数据它只会包装store中保存的数据，并不会修改store中保存的数据，当store中的数据发生变化时，getter生成的内容也会随之变化 getters:{ //添加了一个showNum的属性 showNum : state =&gt;{ return &#39;最新的count值为：&#39;+state.count; } }在组件中访问getter方法 {{$store.getters.showNum}}import { mapGetters } from &#39;vuex&#39; computed:{ ...mapGetters([&#39;showNum&#39;]) }","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.iamys.club/tags/vue/"}]},{"title":"超级简历一面","slug":"找到数组中符合条件的数","date":"2020-09-23T03:44:27.323Z","updated":"2020-09-23T03:48:05.155Z","comments":true,"path":"2020/09/23/找到数组中符合条件的数/","link":"","permalink":"https://www.iamys.club/2020/09/23/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%95%B0/","excerpt":"","text":"找到数组中符合条件的数findfind方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 var newArray = {}; var array =[ {name:&#39;aiai&#39;,aeg:12}, {name:&#39;sisi&#39;,aeg:12}, {name:&#39;lulu&#39;,aeg:12} ] newArray = this.array.find((item)=&gt;{ if(item.name===&#39;sisi&#39;){ return item } })findIndexfindIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 [1,2,3,4,5].findIndex(function(value,index,arr){ return value&gt;2; }) //2for循环 加if判断var newArray = []; var j = 0; var array =[ {name:&#39;aiai&#39;,aeg:12}, {name:&#39;sisi&#39;,aeg:12}, {name:&#39;lulu&#39;,aeg:12} ] for (let i in array){ if(array[i].name===&#39;sisi&#39;){ newArray[j++]=array[i] } }filtervar array =[ {name:&#39;aiai&#39;,aeg:12}, {name:&#39;sisi&#39;,aeg:12}, {name:&#39;lulu&#39;,aeg:12} ] function filterByName(array,name){ return array.filter(item=&gt;item.name===name) } console.log(filterByName(array,&#39;sisi&#39;))includesincludes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7 [1,2,3,4,5].includes(2)//trueindexOfif (arr.indexOf(el) !== -1) { // ... }遍历数组的方法使用for和for/in，我们可以访问数组的下标，而不是实际的数组元素值箭头函数与普通函数的区别 for(let i=0;i&gt;arr.length;i++){ console.log(arr[i]) } for(let i in arr){ console.log(arr[i]); }for/of 可以直接访问数组的元素值 for (const v of arr){ console.log(v) }使用forEach()，则可以同时访问数组的下标与元素值 arr.forEach((v,i)=&gt;console.log(v))map方法 让数组通过某种计算产生一个新数组,影射成一个新的数组 var arr = [1, 2, 3] var firearr = arr.map(current =&gt; current * 5) console.log(firearr); //[ 5, 10, 15 ]filter方法 筛选出过滤出数组中符合条件的项,组成新数组. var arr = [2, 3, 4, 5, 6] var morearr = arr.filter(function(number) { return number &gt; 3 }) console.log(morearr);//[ 4, 5, 6 ]箭头函数基本语法 如果箭头函数没有参数，直接写一个空括号即可 如果参数只有一个可以省略参数的括号 如果有多个参数写在括号里用都好分割 如果函数体只有一句代码或一个变量或简单的js表达式，可以省去函数体的大括号 如果只有一条语句不需要返回值，可以在这条语句前加一个viod关键字 箭头函数最常见的用处就是简化回调函数 箭头函数与普通函数的区别 语法更加简洁、清晰 箭头函数不会创建自己的this,它会捕获自己在定义时所处的外层执行环境的this,并且继承这个this值。所以箭头函数中的this的指向在它定义时就已经确定了，永远不会改变。 call()/apply()/bind()也无法改变箭头函数中this的指向 箭头函数不能作为构造函数使用 箭头函数没有原型prototype vue生命周期beforeCreate实例初始化之后，数据观测和事件配置之前被调用（此时data 和 methods 以及页面的DOM结构都没有初始化 什么都做不了） created 实例完成创建之后被立即调用（此时data 和 methods已经可以使用 但是页面还没有渲染出来）调用后台数据 beforeMount在挂载之前被调用(此时页面上还看不到真实数据 只是一个模板页面而已) mountedel被新创建的vm.$el替换，并挂载到实例上去之后调用改钩子（ 数据已经真实渲染到页面上 在这个钩子函数里面我们可以使用一些第三方的插件） 修改switch开关的颜色 兄弟组件传值接收方监听事件 beforeUpdate数据更新时调用，发生在虚拟DOM打补丁之前（ 页面上数据还是旧的） updated由于数据更新导致的虚拟DOM重新渲染和打补丁，在这之后会调用改钩子（页面上的数据已经替换成最新的了） beforeDestroy实例销毁之前调用 destroyed实例销毁之后调用 兄弟组件传值 兄弟之间传递数据需要借助于事件中心，通过事件中心传递数据 提供事件中心 var hub = new Vue() 传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据) 接收数据方，通过mounted(){} 钩子中 触发hub.$on()方法名 销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据 父子组件传值父组件向子组件传值父组件发送的形式是以属性的形式绑定值在子组件的身上 子组件用属性props接收 子组件向父组件传值$emit()参数一为自定义事件名，参数二是需要传递的数据 父组件用v-on监听子组件的事件 npm、cnpm、yarn 的区别yarn的优点 速度快：并行安装、离线模式 安装版本统一 更简洁的输出 多注册来源处理 Yarn和npm命令对比 npm yarn npm install yarn npm install react –save yarn add react npm uninstall react –save yarn remove react npm install react –save-dev yarn add react –dev npm update –save yarn upgrade const、var、let区别，const定义对象，可以改变对象的属性嘛…","categories":[{"name":"前端面试","slug":"前端面试","permalink":"https://www.iamys.club/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.iamys.club/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Vue","slug":"Vue","date":"2020-08-05T14:19:20.525Z","updated":"2020-08-06T03:07:28.276Z","comments":true,"path":"2020/08/05/Vue/","link":"","permalink":"https://www.iamys.club/2020/08/05/Vue/","excerpt":"","text":"数据与方法当一个 Vue 实例被创建时，它将 数据 对象中的所有的 属性加入到 Vue 的响应式系统中。当这些 属性 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。值得注意的是只有当实例被创建时就已经存在于数据中的属性才是响应式的。也就是说如果你添加一个新的属性，那么对于这个新添加的属性的改动不会触发任何试图的更新 使用 Object.freeze()，这会阻止修改现有的 属性，也意味着响应系统无法再追踪变化。 除了数据 属性，Vue 实例还暴露了一些有用的实例 属性与方法。它们都有前缀 $，以便与用户定义的 属性 区分开来。API 参考 实例生命周期钩子 挂载（初始化相关属性） beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用 created 在实例创建完成后立即被调用 beforeMount 在挂载开始之前被调用 mounted 被新创建的vm.$el替换，并挂载到实例上去时候调用该钩子 更新（元素或组件的变更操作） beforeUpdate 数据更新使调用，发生在虚拟DOM打补丁之前 updated 由于数据更改导致虚拟DOM重新渲染和打补丁在这之后会调用该钩子 销毁（销毁相关属性）关属性） beforeDestroy 实例销毁之前调用 destroyed 实例销毁之后调用 不要在选项 property 或回调上使用箭头函数因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致错误 模板语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。 插值文本：数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定 v-html 指令：双大括号会将数据解释为普通文本，而非 HTML 代码。v-html输出真正的 HTML（站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击） v-bind 指令：绑定html属性 对于以上所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。有个限制就是，每个绑定都只能包含单个表达式 指令指令 (Directives) 是带有 v- 前缀的特殊 attribute。 一些指令能够接收一个“参数”，在指令名称之后以冒号表示。 v-bind可以绑定动态参数，你可以使用动态参数为一个动态的事件名绑定处理函数 &lt;a v-bind:[attributeName]=\"url\"> ... &lt;/a> &lt;a v-on:[eventName]=\"doSomething\"> ... &lt;/a> 修饰符修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定 &lt;form v-on:submit.prevent=\"onSubmit\">...&lt;/form> v-bind 缩写为:,v-on 缩写为@ 计算属性模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。所以，对于任何复杂逻辑，你都应当使用计算属性。 &lt;div id=\"example\"> &lt;p>Original message: \"{{ message }}\"&lt;/p> &lt;p>Computed reversed message: \"{{ reversedMessage }}\"&lt;/p> &lt;/div> var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { // 计算属性的 getter reversedMessage: function () { // `this` 指向 vm 实例 return this.message.split('').reverse().join('') } } }) 我们可以将同一函数定义为一个方法(methods)而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。 观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch,通常更好的做法是使用计算属性而不是命令式的 watch 回调 计算属性默认只有 getter，不过在需要时你也可以提供一个 setter 侦听器虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。除了 watch 选项之外，还可以使用命令式的 vm.$watch API","categories":[],"tags":[]},{"title":"关于ES6","slug":"关于ES6","date":"2020-08-04T13:43:44.299Z","updated":"2020-09-23T03:49:42.640Z","comments":true,"path":"2020/08/04/关于ES6/","link":"","permalink":"https://www.iamys.club/2020/08/04/%E5%85%B3%E4%BA%8EES6/","excerpt":"","text":"let命令ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 for循环的计数器，就很合适使用let命令。 let在for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 for (let i = 0; i &lt; 3; i++) { let i = &#39;abc&#39;; console.log(i); } // abc // abc // abc不存在变量提升var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 暂时性死区使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ） 有些“死区”比较隐蔽，不太容易发现。 function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。因此，不能在函数内部重新声明参数。 块级作用域ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 第二种场景，用来计数的循环变量泄露为全局变量。 let实际上为 JavaScript 新增了块级作用域。 ES6 允许块级作用域的任意嵌套。 内层作用域可以定义外层作用域的同名变量。 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 const 命令 const声明一个只读的常量。一旦声明，常量的值就不能改变。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。所以对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 const声明的常量，也与let一样不可重复声明。 对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 如果真的想将对象冻结，应该使用Object.freeze方法。 ES6 声明变量的六种方法 var命令和function命令 let和const import命令和class 变量的解构赋值数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 let [a, b, c] = [1, 2, 3]; 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 如果解构不成功，变量的值就等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功 如果等号的右边不是数组，那么将会报错。 对于 Set 结构，也可以使用数组的解构赋值。 let [x, y, z] = new Set(['a', 'b', 'c']); x // \"a\" 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 默认值解构赋值允许指定默认值。 let [x, y = 'b'] = ['a']; // x='a', y='b' let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' let [x = 1] = [null]; x // null 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 对象的解构赋值let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; foo // \"aaa\" bar // \"bbb\" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 如果变量名与属性名不一致，必须写成下面这样。 let { foo: baz } = { foo: 'aaa', bar: 'bbb' }; baz // \"aaa\" foo // error: foo is not defined //foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 可以嵌套赋值 let obj = {}; let arr = []; ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true }); obj // {prop:123} arr // [true] 对象的解构赋值可以取到继承的属性 const obj1 = {}; const obj2 = { foo: 'bar' }; Object.setPrototypeOf(obj1, obj2); const { foo } = obj1; foo // \"bar\" 默认值生效的条件是，对象的属性值严格等于undefined var {x = 3} = {x: undefined}; x // 3 var {x = 3} = {x: null}; x // null 只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。 let x; ({x} = {x: 1}); 字符串解构const [a, b, c, d, e] = 'hello'; a // \"h\" b // \"e\" c // \"l\" d // \"l\" e // \"o\" 数值和布尔值的解构赋值解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 变量的解构赋值用途（1）交换变量的值 let x = 1; let y = 2; [x, y] = [y, x]; （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 unction example() { return [1, 2, 3]; } let [a, b, c] = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 （4）提取 JSON 数据 let jsonData = { id: 42, status: \"OK\", data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number); // 42, \"OK\", [867, 5309] （5）函数参数的默认值 （6）遍历 Map 结构 const map = new Map(); map.set('first', 'hello'); map.set('second', 'world'); for (let [key, value] of map) { console.log(key + \" is \" + value); } // first is hello // second is world （7）输入模块的指定方法 const { SourceMapConsumer, SourceNode } = require(\"source-map\"); 字符串的扩展字符串的遍历器接口ES6 为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历。 for (let codePoint of 'foo') { console.log(codePoint) } // \"f\" // \"o\" // \"o\" 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 模板字符串之中还能调用函数。 const tmpl = addrs => ` &lt;table> ${addrs.map(addr => ` &lt;tr>&lt;td>${addr.first}&lt;/td>&lt;/tr> &lt;tr>&lt;td>${addr.last}&lt;/td>&lt;/tr> `).join('')} &lt;/table> `; 模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能 alert`hello` // 等同于 alert(['hello']) 字符串的新增方法 ES6 提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。fromCodePoint方法定义在String对象上 ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。 codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。 ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 这三个方法都支持第二个参数，表示开始搜索的位置。 repeat方法返回一个新字符串，表示将原字符串重复n次。 ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 padStart()的常见用途是为数值补全指定位数，另一个用途是提示字符串格式。 ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。 浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。 数字的扩展 传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效 Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。如果参数类型不是数值，Number.isFinite一律返回false。 Number.isNaN()用来检查一个值是否为NaN。如果参数类型不是NaN，Number.isNaN一律返回false。 ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 Number.isInteger()用来判断一个数值是否为整数。Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。 Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的 比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。 function withinErrorMargin (left, right) { return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2); } 0.1 + 0.2 === 0.3 // false withinErrorMargin(0.1 + 0.2, 0.3) // true 1.1 + 1.3 === 2.4 // false withinErrorMargin(1.1 + 1.3, 2.4) // true ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内 ES2016 新增了一个指数运算符（**）。 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。 为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n BigInt 与普通整数是两种值，它们之间并不相等。 BigInt 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突。 BigInt()构造函数必须有参数，而且参数必须可以正常转为数值 BigInt(&#39;123&#39;) // 123n BigInt(false) // 0nBigInt 不能与普通数值进行混合运算 函数的扩展默认值ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 参数变量是默认声明的，所以不能用let或const再次声明。 使用参数默认值时，函数不能有同名参数。 参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 参数默认值可以与解构赋值的默认值，结合起来使用。 function m1({x = 0, y = 0} = {}) { return [x, y]; } //函数参数的默认值是空对象，但是设置了对象解构赋值的默认值 函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 (function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).length // 2 (function (a, b = 1, c) {}).length // 1 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 rest参数ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 // arguments变量的写法 function sortNumbers() { return Array.prototype.slice.call(arguments).sort(); } // rest参数的写法 const sortNumbers = (...numbers) => numbers.sort(); 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。函数的length属性，不包括 rest 参数 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。 var f = v => v; // 等同于 var f = function (v) { return v; }; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 // 报错 let getTempItem = id => { id: id, name: \"Temp\" }; // 不报错 let getTempItem = id => ({ id: id, name: \"Temp\" }); 箭头函数可以与变量解构结合使用。 const full = ({ first, last }) => first + ' ' + last; // 等同于 function full(person) { return person.first + ' ' + person.last; } 箭头函数有几个使用注意点。 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。(this对象的指向是可变的，但是在箭头函数中，它是固定的。) 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 数组的扩展扩展运算符扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 function add(x, y) { return x + y; } const numbers = [4, 38]; add(...numbers) // 42 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了 // ES5 的写法 function f(x, y, z) { // ... } var args = [0, 1, 2]; f.apply(null, args); // ES6的写法 function f(x, y, z) { // ... } let args = [0, 1, 2]; f(...args); 复制数组数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。修改一个会时另一个也更改 //ES5方法 const a1 = [1, 2]; const a2 = a1.concat();//a1会返回原数组的克隆，再修改a2就不会对a1产生影响。 a2[0] = 2; a1 // [1, 2] //ES6复制数组写法 const a1 = [1, 2]; // 写法一 const a2 = [...a1]; // 写法二 const [...a2] = a1; 合并数组const arr1 = ['a', 'b']; const arr2 = ['c']; const arr3 = ['d', 'e']; // ES5 的合并数组 arr1.concat(arr2, arr3); // [ 'a', 'b', 'c', 'd', 'e' ] // ES6 的合并数组 [...arr1, ...arr2, ...arr3] // [ 'a', 'b', 'c', 'd', 'e' ] //这两种方法都是浅拷贝，使用的时候需要注意。 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 字符串[...'hello'] // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 实现了 Iterator 接口的对象任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。 let nodeList = document.querySelectorAll('div'); let array = [...nodeList]; Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 let ps = document.querySelectorAll('p'); Array.from(ps).filter(p => { return p.textContent.length > 100; }); // arguments对象 function foo() { var args = Array.from(arguments); // ... } 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。 Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换 对象的扩展ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。除了属性简写，方法也可以简写 function f(x, y) { return {x: x, y: y}; } const o = { method() { return \"Hello!\"; } }; 注意，简写的对象方法不能用作构造函数，会报错。 表达式作为属性名，这时要将表达式放在方括号之内。表达式还可以用于定义方法名。 let propKey = 'foo'; let obj = { [propKey]: true, ['a' + 'bc']: 123 }; 注意，属性名表达式与简洁表示法，不能同时使用，会报错。 name 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。 有四个操作会忽略enumerable为false的属性。 for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 ES6 一共有 5 种方法可以遍历对象的属性。 （1）for…in for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。 注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 解构赋值对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; x // 1 y // 2 z // { a: 3, b: 4 } SymbolES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。 const obj = { toString() { return 'abc'; } }; const sym = Symbol(obj); sym // Symbol(abc) 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。 Symbol 值不能与其他类型的值进行运算，会报错。但是，Symbol 值可以显式转为字符串。另外，Symbol 值也可以转为布尔值，但是不能转为数值。 ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。 重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。 let s1 = Symbol.for('foo'); let s2 = Symbol.for('foo'); s1 === s2 // true Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。 let s1 = Symbol.for(\"foo\"); Symbol.keyFor(s1) // \"foo\" let s2 = Symbol(\"foo\"); Symbol.keyFor(s2) // undefined setES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成 Set 数据结构。 const s = new Set(); [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x)); for (let i of s) { console.log(i); } // 2 3 5 4 // 去除数组的重复成员 [...new Set(array)] //去除字符串里面的重复字符 [...new Set('ababbc')].join('') // \"abc\" Set 结构的实例有以下属性 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法：操作方法（用于操作数据） Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 Set 结构的实例遍历方法，可以用于遍历成员 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。 作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。 const a = [[1, 2], [3, 4]]; const ws = new WeakSet(a); // WeakSet {[1, 2], [3, 4]} MapES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 const m = new Map(); const o = {p: 'Hello World'}; m.set(o, 'content') m.get(o) // \"content\" m.has(o) // true m.delete(o) // true m.has(o) // false 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。 const map = new Map(); map.set(['a'], 555); map.get(['a']) // undefined 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。 const map = new Map(); const k1 = ['a']; const k2 = ['a']; map .set(k1, 111) .set(k2, 222); map.get(k1) // 111 map.get(k2) // 222 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 WeakMap与Map的区别有两点。 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。 WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.iamys.club/tags/ES6/"}]},{"title":"Promise","slug":"promise","date":"2020-08-04T02:09:03.368Z","updated":"2020-08-04T05:31:11.751Z","comments":true,"path":"2020/08/04/promise/","link":"","permalink":"https://www.iamys.club/2020/08/04/promise/","excerpt":"","text":"JavaScript 执行机制 javascript是一门单线程语言不能同时处理多个任务，把任务分成了同步和异步。 事件循环Event Loop事件循环是js实现异步的一种方法，也是js的执行机制。 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 //举个栗子 let data = []; $.ajax({ url:www.javascript.com, data:data, success:() =&gt; { console.log(&#39;发送成功!&#39;); } }) console.log(&#39;代码执行结束&#39;); ajax进入Event Table，注册回调函数success。 执行console.log(&#39;代码执行结束&#39;)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行 宏任务和微任务 macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick setTimeout(function() { console.log(&#39;setTimeout&#39;); //4 }) new Promise(function(resolve) { console.log(&#39;promise&#39;); //1 }).then(function() { console.log(&#39;then&#39;); //3 }) console.log(&#39;console&#39;); //2 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 整体代码script作为第一个宏任务执行结束，执行then在微任务Event Queue里面。 第一轮事件循环结束了，开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 promise Promise 可以理解为承诺，就像我们去点餐服务员给我们一引订单票，这就是承诺。如果餐做好了叫我们这就是成功，如果没有办法给我们做出食物这就是拒绝。 一个 promise 必须有一个 then 方法用于处理状态改变 状态说明 Promise包含pending、fulfilled、rejected三种状态 pending 指初始等待状态，初始化 promise 时的状态 resolve 指已经解决，将 promise 状态设置为fulfilled reject 指拒绝处理，将 promise 状态设置为rejected promise 是生产者，通过 resolve 与 reject 函数告之结果 promise 非常适合需要一定执行时间的异步任务 状态一旦改变将不可更改 promise 是队列状态，就像体育中的接力赛，状态一直向后传递，当然其中的任何一个promise也可以改变状态。 promise 没有使用 resolve 或 reject 更改状态时，状态为 pending console.log( new Promise((resolve, reject) =&gt; {}) )//Promise{&lt;pending&gt;} promise状态更改为resolve或reject之后 console.log( new Promise((resolve, reject) =&gt; { resolve(&#39;felfilled&#39;) }) ) //Promise{&lt;felfilled&gt;:felfilled} console.log( new Promise((resolve, reject) =&gt; { reject(&#39;rejected&#39;) }) ); //Promise{&lt;rejected&gt;:rejected} promise 创建时即立即执行即同步任务，then 会放在异步微任务中执行，需要等同步任务执行后才执行。 promise 的 then、catch、finally的方法都是异步任务 程序需要将主任务执行完成才会执行异步队列任务 let promise = new Promise((resolve, reject) =&gt; { resolve(&#39;iamys.club&#39;); console.log(&#39;世界&#39;); }).then(msg =&gt; { console.log(msg); }) console.log(&#39;你好&#39;); //世界 //你好 //iamys.club Promise里的是微任务比回调函数的宏任务先执行 new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(&#39;定时器&#39;); }, 3000); resolve(&quot;fulfilled&quot;); }).then( msg =&gt; { console.log(msg); }, error =&gt; { console.log(error); } ); //felfilled //定时器 状态被改变后就不能再修改了。下面先通过resolve 改变为成功状态，表示promise 状态已经完成，就不能使用 reject 更改状态了 new Promise((resolve, reject) =&gt; { resolve(&quot;操作成功&quot;); reject(new Error(&quot;请求失败&quot;)); }).then( msg =&gt; { console.log(msg); }, error =&gt; { console.log(error); } ); //操作成功 动态改变 如果 resolve 参数是一个 promise ，将会改变promise状态。 下例中 p1 的状态将被改变为 p2 的状态 const p1 = new Promise((resolve, reject) =&gt; { resolve( //p2 new Promise((s, e) =&gt; { e(&quot;失败&quot;); }) ); }).then(msg =&gt; { console.log(msg); }, reson =&gt; { console.log(reson);//失败 } ); 当promise做为参数传递时，需要等待promise执行完才可以继承 下面的p2需要等待p1执行完成。因为p2 的resolve 返回了 p1 的promise，所以此时p2 的then 方法已经是p1 的了，所以 then 的第一个函数输出了 p1 的 resolve 的参数 const p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&quot;操作成功&quot;); }, 2000); }); const p2 = new Promise((resolve, reject) =&gt; { resolve(p1); }).then( msg =&gt; { console.log(msg);//操作成功 }, error =&gt; { console.log(error); } ); then 一个promise 需要提供一个then方法访问promise 结果，then 用于定义当 promise 状态发生改变时的处理，即promise处理异步操作，then 用于结果。 then 方法必须返回 promise，用户返回或系统自动返回 第一个函数在resolved 状态时执行，即执行resolve时执行then第一个函数处理成功状态，如果只关心失败时状态，then 的第一个参数传递 null 第二个函数在rejected状态时执行，即执行reject 时执行第二个函数处理失败状态，该函数是可选的 两个函数都接收 promise 传出的值做为参数 也可以使用catch 来处理失败的状态，那就是对所有没有指定失败返回的统一的失败返回 如果 then 返回 promise ，下一个then 会在当前promise 状态改变后执行 链式调用promise 中的 then 方法可以链接执行，then 方法的返回值会传递到下一个then 方法。 then 会返回一个promise ，所以如果有多个then 时会连续执行 then 返回的值会做为当前promise 的结果 第一个then 是对上个promise 的状态的处理，每个 then 会是一个新的promise，默认传递 fulfilled状态，上一个 promise状态不会影响以后then返回的状态 new Promise((resolve, reject) =&gt; { reject(); }) .then( resolve =&gt; console.log(&quot;fulfilled&quot;), reject =&gt; console.log(&quot;rejected&quot;) ) .then( resolve =&gt; console.log(&quot;fulfilled&quot;), reject =&gt; console.log(&quot;rejected&quot;) ) .then( resolve =&gt; console.log(&quot;fulfilled&quot;), reject =&gt; console.log(&quot;rejected&quot;) ); // 执行结果如下 // rejected // fulfilled // fulfilled 如果内部返回promise，就用这个promise let p1 = new Promise(resolve =&gt; { resolve(); }); let p2 = p1.then(() =&gt; { return new Promise(r =&gt; { r(&quot;iamys.club&quot;); }); }); p2.then(v =&gt; { console.log(v); //iamys.club }); 如果 then 返回promise 时，后面的then 就是对返回的 promise 的处理（promise的返回值是promise也一样），其他操作需要等待该 promise 变更状态后执行。 let promise = new Promise(resolve =&gt; resolve()); let p1 = promise.then(() =&gt; { return new Promise(resolve =&gt; { setTimeout(() =&gt; { console.log(`p1`); resolve(); }, 2000); }); }).then(() =&gt; { return new Promise((a, b) =&gt; { console.log(`p2`); }); }); //p1 //p2 如果then返回 promise 时，返回的promise 后面的then 就是处理这个promise 的 new Promise((resolve, reject) =&gt; { resolve(); }) .then(v =&gt; { return new Promise((resolve, reject) =&gt; { resolve(&quot;第二个promise&quot;); }); }) .then(value =&gt; { console.log(value); //第二个promise return value; }) .then(value =&gt; { console.log(value); //第二个promise }); 其它类型 如果 then 返回与 promise 相同将禁止执行 let promise = new Promise(resolve =&gt; { resolve(); }); let p2 = promise.then(() =&gt; { return p2; }); // TypeError: Chaining cycle detected for promise 包含 then 方法的对象就是一个 promise ，享受和promise一样的特性和待遇，如果对象中的 then 不是函数，则将对象做为值传递 new Promise((resolve, reject) =&gt; { resolve( class { static then(resolve, reject) { setTimeout(() =&gt; { resolve(&quot;解决状态&quot;); }, 2000); } } ); }).then( v =&gt; { console.log(`felfilled: ${v}`);//felfilled:解决状态 }, v =&gt; { console.log(`rejected: ${v}`); } ); catch catch用于失败状态的处理函数，等同于 then(null,reject){} 建议使用 catch 处理错误 将 catch 放在最后面用于统一处理前面发生的错误 错误是冒泡的操作的，只要一个then 没有定义第二个函数，将一直冒泡到 catch 处理错误 catch 也可以捕获对 then 抛出的错误处理 new Promise((resolve, reject) =&gt; { resolve(); }) .then(msg =&gt; { throw new Error(&quot;这是then 抛出的错误&quot;); }) .catch(() =&gt; { console.log(&quot;33&quot;);//33 }); 在异步中 throw 将不会触发 catch，而使用系统错误处理 const promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { throw new Error(&quot;fail&quot;); }, 2000); }).catch(msg =&gt; { console.log(msg + &quot;123&quot;); }); 定制错误404错误 class ParamError extends Error { constructor(msg) { super(msg); this.name = &quot;ParamError&quot;; } } class HttpError extends Error { constructor(msg) { super(msg); this.name = &quot;HttpError&quot;; } } function ajax(url) { return new Promise((resolve, reject) =&gt; { if (!/^http/.test(url)) { throw new ParamError(&quot;请求地址格式错误&quot;); } let xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.send(); xhr.onload = function() { if (this.status == 200) { resolve(JSON.parse(this.response)); } else if (this.status == 404) { reject(new HttpError(&quot;用户不存在&quot;)); } else { reject(&quot;加载失败&quot;); } }; xhr.onerror = function() { reject(this); }; }); } ajax(`url`) .then(value =&gt; { console.log(value); }) .catch(error =&gt; { if (error instanceof ParamError) { console.log(error.message); } if (error instanceof HttpError) { alert(error.message); } console.log(error); }); finally 无论状态是resolve 或 reject 都会执行此动作，finally 与状态无关 const promise = new Promise((resolve, reject) =&gt; { reject(&quot;hdcms&quot;); }) .then(msg =&gt; { console.log(&quot;resolve&quot;); }) .catch(msg =&gt; { console.log(&quot;reject&quot;); }) .finally(() =&gt; { console.log(&quot;resolve/reject状态都会执行&quot;); });扩展接口 使用 promise.resolve 方法可以快速的返回一个promise对象 和 Promise.resolve 类似，reject 生成一个失败的promise 使用Promise.all 方法可以同时执行多个并行异步操作，比如页面加载时同进获取课程列表与推荐课程。 任何一个 Promise 执行失败就会调用 catch方法 适用于一次发送多个异步操作 参数必须是可迭代类型，如Array/Set 成功后返回 promise 结果的有序数组 const hdcms = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&quot;第一个Promise&quot;); }, 1000); }); const houdunren = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&quot;第二个异步&quot;); }, 1000); }); const hd = Promise.all([hdcms, houdunren]) .then(results =&gt; { console.log(results); }) //[&quot;第一个Promise&quot;, &quot;第二个异步&quot;] .catch(msg =&gt; { console.log(msg); }); allSettled 用于处理多个promise ，只关注执行完成，不关注是否全部执行成功，allSettled 状态只会是fulfilled。 使用Promise.race() 处理容错异步，和race单词一样哪个Promise快用哪个，哪个先返回用哪个。 以最快返回的promise为准 如果最快返加的状态为rejected 那整个promise为rejected执行cache 如果参数不是promise，内部将自动转为promise const hdcms = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&quot;第一个Promise&quot;); }, 2000); }); const houdunren = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&quot;第二个异步&quot;); }, 1000); }); Promise.race([hdcms, houdunren]) .then(results =&gt; { console.log(results);//第二个异步 }) .catch(msg =&gt; { console.log(msg); });async/await async/await 是promise 的语法糖，可以让编写 promise 更清晰易懂，也是推荐编写promise 的方式。 async/await 本质还是promise，只是更简洁的语法糖书写 async/await 使用更清晰的promise来替换 promise.then/catch 的方式 函数前加上async，函数将返回promise，我们就可以像使用标准Promise一样使用了。 如果有多个await 需要排队执行完成，我们可以很方便的处理多个异步队列 使用 await 关键词后会等待promise 完 await 后面一般是外部的promise，如果不是直接返回 await 必须放在 async 定义的函数中使用 await 用于替代 then 使编码更优雅 async function hd(message) { return new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve(message); }, 2000); }); } async function run() { let h1 = await hd(&quot;好的&quot;); console.log(h1); let h2 = await hd(&quot;123&quot;); console.log(h2); } run();并发执行有时需要多个await 同时执行，有以下几种方法处理，下面多个await 将产生等待 async function p1() { return new Promise(resolve =&gt; { setTimeout(() =&gt; { console.log(&quot;123&quot;); resolve(); }, 2000); }); } async function p2() { return new Promise(resolve =&gt; { setTimeout(() =&gt; { console.log(&quot;456&quot;); resolve(); }, 2000); }); } async function hd() { await p1(); await p2(); } hd(); //相当于使用 Promise.all() 处理多个promise并行执行 async function hd() { await Promise.all([p1(), p2()]); } hd();","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://www.iamys.club/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"}]},{"title":"类型和语法","slug":"类型和语法","date":"2020-08-03T06:29:39.007Z","updated":"2020-08-03T06:34:34.213Z","comments":true,"path":"2020/08/03/类型和语法/","link":"","permalink":"https://www.iamys.club/2020/08/03/%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1.类型 JavaScript 有 七 种 内 置 类 型：null、undefined、boolean、number、string、object 和 symbol，可以使用 typeof 运算符来查看。 变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。 很多开发人员将undeﬁned 和 undeclared 混为一谈，但在JavaScript 中它们是两码事。 undefined 是值的一种。undeclared 则表示变量还没有被声明过。 遗憾的是，JavaScript 却将它们混为一谈，在我们试图访问”undeclared” 变量时这样报 错：ReferenceError: a is not deﬁned，并且typeof 对 undeﬁned 和 undeclared 变量都返回 “undefined”。 然而，通过 typeof 的安全防范机制（阻止报错）来检查 undeclared 变量，有时是个不错的 办法。 内置类型JavaScript七种内置类型 空值（null） 未定义（undefined） 布尔值（ boolean） 数字（number） 字符串（string） 对象（object） 符号（symbol，ES6 中新增） 除对象之外，其他统称为“基本类型”。 typeof undefined === &quot;undefined&quot;; // true typeof true === &quot;boolean&quot;; // true typeof 42 === &quot;number&quot;; // true typeof &quot;42&quot; === &quot;string&quot;; // true typeof { life: 42 } === &quot;object&quot;; // true typeof Symbol() === &quot;symbol&quot;; // true typeof null === &quot;object&quot;; // true //null 是基本类型中唯一的一个“假值，正确的返回结果应该是 &quot;null&quot;，但这个bug 由来已久 typeof function a(){ /* .. */ } === &quot;function&quot;; // true //函数是 object 的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属 性 [[Call]]，该属性使其可以被调用。 typeof [1,2,3] === &quot;object&quot;; // true //数组也是对象。确切地说，它也是 object 的一个“子类型”，数组的 元素按数字顺序来进行索 值和类型 JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。 也就是说JavaScript 不做“类型强制”；也就是说，语言引擎不要求变量总是 持有与其初始值同类型的值。一个变量可以现在被赋值为字符串类型值，随后又被赋值为 数字类型值。 所以在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类 型，因为 JavaScript 中的变量没有类型 undefined 和 undeclared 已在作用域中声明但还没有赋值的变量，是 undeﬁned 的。 相反，还没有在作用域中声明 过的变量，是 undeclared 的。 var a; typeof a; // &quot;undefined&quot; typeof b; // &quot;undefined&quot; //对于 undeclared（或者 not deﬁned）变量，typeof 照样返回 &quot;undefined&quot;。请注意虽然 b 是 一个 undeclared 变量，但 typeof b 并没有报错。这是因为 typeof 有一个特殊的安全防范 机制。2.值 JavaScript 中的数组是通过数字索引的一组任意类型的值。字符串和数组类似，但是它们的 行为特征不同，在将字符作为数组来处理时需要特别小心。JavaScript 中的数字包括“整 数”和“浮点型”。 基本类型中定义了几个特殊的值。null 类型只有一个值 null，undefined 类型也只有一个值 undefined。所有变量在赋值之 前默认值都是 undefined。void 运算符返回 undefined。 数 字 类 型 有 几 个 特 殊 值， 包 括NaN（ 意 指“not a number”， 更 确 切 地 说 是“invalid number”）、 +Infinity、-Infinity 和 -0。 简单标量基本类型值（字符串和数字等）通过值复制来赋值 / 传递，而复合值（对象等） 通过引用复制来赋值 / 传递。JavaScript 中的引用和其他语言中的引用 / 指针不同，它们不 能指向别的变量 / 引用，只能指向值。 数组 在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、 数字、对象（object），甚至是其他数组（多维数组） 对数组声明后即可向其中加入值，不需要预先设定大小 类数组一些 DOM 查询操作会返回 DOM 元素列表，它们并非真正意义上的数组，但十分 类似。另一个例子是通过 arguments 对象（类数组）将函数的参数当作列表来访问（从 ES6 开始已废止） function foo() { var arr = Array.prototype.slice.call( arguments ); arr.push( &quot;bam&quot; ); console.log( arr ); } foo( &quot;bar&quot;, &quot;baz&quot; ); // [&quot;bar&quot;,&quot;baz&quot;,&quot;bam&quot;] //工具函数 slice(..) 经常被用于这类转换，slice() 返回参数列表（上例中是一个类数组）的一个数组复本。 //用 ES6 中的内置工具函数 Array.from(..) 也能实现同样的功能： var arr = Array.from( arguments ); 字符串 字符串和数组很相似，它是类数组，都有 length 属性以及 indexOf(..)（从 ES5 开始数组支持此方法）和 concat(..) 方法 JavaScript 中字符串是不可变的，而数组是可变的。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符 串。而数组的成员函数都是在其原始值上进行操作。 许多数组函数用来处理字符串很方便。虽然字符串没有这些函数，但可以通过“借用”数 组的非变更方法来处理字符串 另一个不同点在于字符串反转（JavaScript 面试常见问题）。数组有一个字符串没有的可变更成员函数 reverse()。我们无法“借用”数组的可变更成员函数，因为字符串是不可变的 //字符串反转一个变通（破解）的办法是先将字符串转换为数组，待处理完后再将结果转换回字符串 var c = a .split( &quot;&quot; ) // 将a的值转换为字符数组 .reverse() // 将数组中的字符进行倒转 .join( &quot;&quot; ); // 将数组中的字符拼接回字符串 c; // &quot;oof&quot; 如果需要经常以字符数组的方式来处理字符串的话，倒不如直接使用数组。这样就不用在 字符串和数组之间来回折腾。可以在需要时使用 join(“”) 将字符数组转换为字符串 数字 JavaScript 只有一种数值类型：number（数字），包括“整数”和带小数的十进制数。此处 “整数”之所以加引号是因为和其他语言不同，JavaScript 没有真正意义上的整数 JavaScript 中的“整数”就是没有小数的十进制数。所以 42.0 即等同于“整数”42。 数字语法特别大和特别小的数字默认用指数格式显示，与 toExponential() 函数的输出结果相同。 a; // 50000000000 a.toExponential(); // &quot;5e+10&quot; tofixed(..) 方法可指定小数部分的显示位数 var a = 42.59; a.toFixed( 0 ); // &quot;43&quot; a.toFixed( 4 ); // &quot;42.5900&quot;42.toFixed( 3 ); // SyntaxError 无效语法 42 .toFixed(3); // &quot;42.000&quot; 空格有效 42..toFixed( 3 ); // &quot;42.000&quot; //第一个 . 被视为 number 的一部分，第二个 . 是属性访问 运算符toPrecision(..) 方法用来指定有效数位的显示位数 var a = 42.59; a.toPrecision( 1 ); // &quot;4e+1&quot; a.toPrecision( 2 ); // &quot;43&quot; a.toPrecision( 3 ); // &quot;42.6&quot;较小数值0.1 + 0.2 === 0.3; // false //二进制浮点数中的 0.1 和 0.2 并不是十分精确，它们相加的结果并非刚好等于 0.3，而是一个比较接近的数字 0.30000000000000004，所以条件判断结果为 false。如何做到完全精确 也就是怎样来判断 0.1 + 0.2 和 0.3 是否相等？ 最常见的方法是设置一个误差范围值，通常称为“机器精度”（machine epsilon）， 对 JavaScript 的数字来说，这个值通常是 2^-52 从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用 为 ES6 之前 的版本写 polyﬁll： if (!Number.EPSILON) { Number.EPSILON = Math.pow(2,-52); } 可以使用 Number.EPSILON 来比较两个数字是否相等（在指定的误差范围内）： function numbersCloseEnoughToEqual(n1,n2) { return Math.abs( n1 - n2 ) &lt; Number.EPSILON; } var a = 0.1 + 0.2; var b = 0.3; numbersCloseEnoughToEqual( a, b ); // true 整数检测要检测一个值是否是整数，可以使用 ES6 中的 Number.isInteger(..) 方法 Number.isInteger( 42 ); // true Number.isInteger( 42.000 ); // true Number.isInteger( 42.3 ); // false要检测一个值是否是安全的整数，可以使用 ES6 中的 Number.isSafeInteger(..) 方法 Number.isSafeInteger( Number.MAX_SAFE_INTEGER ); // true Number.isSafeInteger( Math.pow( 2, 53 ) ); // false Number.isSafeInteger( Math.pow( 2, 53 ) - 1 ); // true特殊数值不是值的值 undefined 类型只有一个值，即 undefined。undefined 指没有值 null 类型也只有一个值，即 null。它们的名 称既是类型也是值。null 指空值 undefined 和 null 常被用来表示“空的”值或“不是值”的值 null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而 undefined 却是一个标识符，可以被当作变量来使用和赋值。但是永远不要重新定义 undefined。 void 运算符undefined 是一个内置标识符（除非被重新定义），它的值为 undefined， 通过 void 运算符即可得到该值 表达式 void ___ 没有返回值，因此返回结果是 undefined。按惯例我们用 void 0 来获得 undefined，void 并不改变表达式的结果， 只是让表达式不返回值 var a = 42; console.log( void a, a ); // undefined 42特殊的数字 不是数字的数字 如果数学运算的操作数不是数字类型（或者无法解析为常规的十进制或十六进制数字）， 就无法返回一个有效的数字，这种情况下返回值为 NaN。 NaN 意指“不是一个数字”（not a number），这个名字容易引起误会。NaN是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误 情况，即“执行数学运算没有成功，这是失败后返回的结果”。 var a = 2 / &quot;foo&quot;; // NaN typeof a === &quot;number&quot;; // true NaN仍然是数字类型NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reﬂexive，即 x === x 不 成立）的值。而 NaN != NaN 为 true。 var a = 2 / &quot;foo&quot;; a == NaN; // false a === NaN; // false可以使用内建的全局工具函数 isNaN(..) 来判断一个值是否是 NaN var a = 2 / &quot;foo&quot;; isNaN( a ); // trueisNaN(..) 有一个严重的缺陷，它的检查方式过于死板，就 是“检查参数是否不是 NaN，也不是数字”。但是这样做的结果并不太准确 var b = &quot;foo&quot;; window.isNaN( b ); // true解决这个问题可以使用ES6工具函数 Number.isNaN(..) // Number.isNaN(..)实现原理 return (typeof n === &quot;number&quot; &amp;&amp; window.isNaN( n )); 还有一个方法是利用 NaN 不等于自身这个特点。NaN 是 JavaScript 中唯 一一个不等于自身的值 if (!Number.isNaN) { Number.isNaN = function(n) { return n !== n; }; } 无穷数 JavaScript 使用有限数字表示法，所以和纯粹的数学运算不同，JavaScript 的运算结果有可能溢出，此时结果为 Infinity 或者 -Infinity。 var a = 1 / 0; // Infinity var b = -1 / 0; // -Infinity计算结果一旦溢出为无穷数（inﬁnity）就无法再得到有穷数 Infinity/ Infinity 是一个未定义操作，结果为 NaN。有穷正数除以 Infinity，结果是 0。 零值 JavaScript 有一个常规的 0（也叫作 +0）和一个 -0。 var a = 0 / -3; // -0 var b = 0 * -3; // -0 加法和减法运算不会得到负对负零进行字符串化会返回 “0”，如果反过来将其从字符串转换为数字，得到的结果是准确的 var a = 0 / -3; a + &quot;&quot;; // &quot;0&quot; +&quot;-0&quot;; // -0 //JSON.stringify(-0) 返回 &quot;0&quot;，而 JSON.parse(&quot;-0&quot;) 返回 -0-0 == 0; // true //区分-0和0的原理 n = Number( n ); return (n === 0) &amp;&amp; (1 / n === -Infinity); 为什么要-0 有些应用程序中的数据需要以级数形式来表示（比如动画帧的移动速度），数字的符号位 （sign）用来代表其他信息（比如移动的方向）。此时如果一个值为 0 的变量失去了它的符号位，它的方向信息就会丢失。所以保留 0 值的符号位可以防止这类情况发生。 值和引用 简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值 / 传递，包括 null、undefined、字符串、数字、布尔和 ES6 中的 symbol。 var a = 2; var b = a; // b是a的值的一个副本 b++; a; // 2 b; // 3 复合值（compound value）——对象（包括数组和封装对象，参见第 3 章）和函数，则总是通过引用复制的方式来赋值 / 传递。 var c = [1,2,3]; var d = c; // d是[1,2,3]的一个引用 d.push( 4 ); c; // [1,2,3,4] d; // [1,2,3,4]由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向 var a = [1,2,3]; var b = a; b = [4,5,6]; a; // [1,2,3] b; // [4,5,6]//函数传参时不能通过引用 x 来更改引用 a 的指向，只能更改 a 和 x 共同指向的值。 function foo(x) { x.push( 4 ); x; // [1,2,3,4] // 然后 x = [4,5,6]; x.push( 7 ); x; // [4,5,6,7] } var a = [1,2,3]; foo( a ); a; // 是[1,2,3,4]，不是 [4,5,6,7]//传递的是指向数字对象的引用复本，但我们并不能通过它来更改其 中的基本类型值,原因是标量基本类型值是不可更改的，除非创建一个包含新值的数字对象。 function foo(x) { x = x + 1; x; // 3 } var a = 2; var b = new Number( a ); // Object(a)也一样 foo( b ); console.log( b ); // 是2，不是 3 我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。如果想要改变传递的类型，有以下两种方法 如果通过值复制的方式来传递复合值（如数组），就需要为其创建一个复本可利用slice()返回一个浅副本，这样传递的 就不再是原始值。 相反，如果要将标量基本类型值传递到函数内并进行更改，就需要将该值封装到一个复合值（对象、数组等）中，然后通过引用复制的方式传递。 3.原始函数 JavaScript 为基本数据类型值提供了封装对象，称为原生函数（如 String、Number、Boolean 等）。它们为基本数据类型值提供了该子类型所特有的方法和属性（如：String#trim() 和 Array#concat(..)）。 对于简单标量基本类型值，比如 “abc”，如果要访问它的 length 属性或 String.prototype 方法，JavaScript 引擎会自动对该值进行封装（即用相应类型的封装对象来包装它）来实 现对这些属性和方法的访问。 常用的原生函数有： String() Number() Boolean() Array() Object() Function() RegExp() Date() Error() Symbol()——ES6 中新加入的！实际上，它们就是内建函数。 内部属性 [[Class]]所有 typeof 返回值为 “object” 的对象（如数组）都包含一个内部属性 [[Class]]（我们可 以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问， 一般通过 Object.prototype.toString(..) 来查看。 Object.prototype.toString.call( [1,2,3] ); // &quot;[object Array]&quot; Object.prototype.toString.call( /regex-literal/i ); // &quot;[object RegExp]封装对象包装封装对象（object wrapper）扮演着十分重要的角色。由于基本类型值没有.length 和 .toString() 这样的属性和方法，需要通过封装对象才能访问，此时 JavaScript 会自动为基本类型值包装一个封装对象 一般情况下，我们不需要直接使用封装对象。最好的办法是让 JavaScript 引擎自己决定什 么时候应该使用封装对象 拆封 如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数 var a = new String( &quot;abc&quot; ); a.valueOf(); // &quot;abc&quot; 在需要用到封装对象中的基本类型值的地方会发生隐式拆封。（即强制类型转换） var a = new String( &quot;abc&quot; ); var b = a + &quot;&quot;; // b的值为&quot;abc&quot; 4.强制类型转换 JavaScript 的数据类型之间的转换，即强制类型转换：包括显式和隐式。 强制类型转换常常为人诟病，但实际上很多时候它们是非常有用的。作为有使命感的 JavaScript 开发人员，我们有必要深入了解强制类型转换，这样就能取其精华，去其糟粕。 显式强制类型转换明确告诉我们哪里发生了类型转换，有助于提高代码可读性和可维 护性。 隐式强制类型转换则没有那么明显，是其他操作的副作用。感觉上好像是显式强制类型转 换的反面，实际上隐式强制类型转换也有助于提高代码的可读性。 在处理强制类型转换的时候要十分小心，尤其是隐式强制类型转换。在编码的时候，要知 其然，还要知其所以然，并努力让代码清晰易读。 值类型转换将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐 式的情况称为强制类型转换（coercion）。JavaScript 中的强制类型转换总是返回标量基本类型值 抽象值操作ToString抽象操作 ToString，它负责处理非字符串到字符串的强制类型转换。 基本类型值的字符串化规则为：null 转换为 “null”，undefined 转换为 “undefined”，true 转换为 “true”。数字的字符串化则遵循通用规则，不过极小和极大的数字使用指数形式 对普通对象来说，除非自行定义，否则 toString()（Object.prototype.toString()）返回 内部属性 [[Class]] 的值，如 “[object Object]”。 数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 “,” 连接起 来 var a = [1,2,3]; a.toString(); // &quot;1,2,3&quot;工具函数 JSON.stringify(..) (1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。 (2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符 串化前调用，以便将对象转换为安全的 JSON 值。 ToNumber将非数字值当作数字来使用，其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。 Number( &quot;&quot; ); // 0 Number( [] ); // 0 Number( [ &quot;abc&quot; ] ); // NaNToBoolean 假值 undefined null false +0、-0 NaN “” 假值列表以 外的值都是真值 假值对象 document.all 真值 真值就是假值列表之外的值。 var a = &quot;false&quot;; var b = &quot;0&quot;; var c = &quot;&#39;&#39;&quot;; var d = Boolean( a &amp;&amp; b &amp;&amp; c ); d;//truevar a = []; // 空数组——是真值还是假值？ var b = {}; // 空对象——是真值还是假值？ var c = function(){}; // 空函数——是真值还是假值？ var d = Boolean( a &amp;&amp; b &amp;&amp; c ); d;//true真值列表可以无限长，无法一一列举，所以我们只能用假值列表作为参考 显式强制类型转换字符串和数字之间的显式转换 String(..) 遵循前面讲过的 ToString 规则，将值转换为字符串基本类型。 Number(..) 遵循 前面讲过的 ToNumber 规则，将值转换为数字基本类型。 一元运算符 - 和 + 会将操作 数显式强制类型转换为数字 日期显式转换为数字一元运算符 + 的另一个常见用途是将日期（Date）对象强制类型转换为数字，返回结果为 Unix 时间戳，以微秒为单位 var timestamp = +new Date();var timestamp = new Date().getTime(); var timestamp = Date.now();~ 运算符 ~ 运算符（即字位操作“非”） ~ 返回 2 的补码，所以~x 大致等同于 -(x+1) ~42; // -(42+1) ==&gt; -43 ~ 和 indexOf() 一起可以将结果强制类型转换（实际 上仅仅是转换）为真 / 假值 var a = &quot;Hello World&quot;; if (a.indexOf( &quot;lo&quot; ) &gt;= 0) { // true // 找到匹配！ } if (a.indexOf( &quot;ol&quot; ) == -1) { // true // 没有找到匹配！ } &gt;= 0 和 == -1 这样的写法不是很好，称为“抽象渗漏”，意思是在代码中暴露了底层的实 现细节，这里是指用 -1 作为失败时的返回值，这些细节应该被屏蔽掉。var a = &quot;Hello World&quot;; ~a.indexOf( &quot;lo&quot; ); // -4 &lt;-- 真值! if (~a.indexOf( &quot;lo&quot; )) { // true // 找到匹配！ } ~a.indexOf( &quot;ol&quot; ); // 0 &lt;-- 假值! !~a.indexOf( &quot;ol&quot; ); // true if (!~a.indexOf( &quot;ol&quot; )) { // true // 没有找到匹配！ }如果 indexOf(..) 返回 -1，~ 将其转换为假值 0，其他情况一律转换为真值。 显式解析数字字符串解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停 止。而转换不允许出现非数字字符，否则会失败并返回 NaN。 var b = &quot;42px&quot;; parseInt( b ); // 42 parseInt(..) 针对的是字符串值。向 parseInt(..) 传递数字和其他类型的参数是 没有用的，比如 true、function(){...} 和 [1,2,3]。显式转换为布尔值 Boolean(..) 是显式的，但并不常用 显式强制类型转换为布尔值最常用的方法是 !!，因为第二个 ! 会将结果反转回原值 一元运算符 ! 显式地将值强制类型转换为布尔值。但是它同时还将 真值反转为假值（或者将假值反转为真值） 隐式强制类型转换字符串和数字之间的隐式强制类型转换 数字强制类型转换为字符串 如果 + 的其中一个操作数是字符串， 则执行字符串拼接；否则执行数字加法。 var a = 42; var b = a + &quot;&quot;; b; // &quot;42&quot;a + “”（隐式）和前面的String(a)（显式）之间有一个细微的差别需要注意。根据 ToPrimitive 抽象操作规则，a + “” 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象 操作将返回值转换为字符串。而 String(a) 则是直接调用 ToString()。 var a = { valueOf: function() { return 42; }, toString: function() { return 4; } }; a + &quot;&quot;; // &quot;42&quot; String( a ); // &quot;4&quot; 字符串强制类型转换为数字的情况 var a = &quot;3.14&quot;; var b = a - 0; b; // 3.14 - 是数字减法运算符，因此 a - 0 会将 a 强制类型转换为数字。也可以使用 a * 1 和 a / 1，因为这两个运算符也只适用于数字，只不过这样的用法不太常见。对象的 - 操作与 + 类似 var a = [3]; var b = [1]; a - b; // 2 为了执行减法运算，a 和 b 都需要被转换为数字，它们首先被转换为字符串（通过强制类型转换toString()），然后再转换为数字。隐式强制类型转换为布尔值 if (..) 语句中的条件判断表达式。 for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。 while (..) 和 do..while(..) 循环中的条件判断表达式。 ? : 中的条件判断表达式。 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。 || 和 &amp;&amp;在JavaScript 中的表现也和在其他语言中不太一样，“逻辑运算符”，因为这不太准确。称它们为“选择器运算符”更恰当。它们的返回值是两个操作数中的一个（且仅一个）。即选择两个操作数中的一个，然后返回它的值 var a = 42; var b = &quot;abc&quot;; var c = null; a || b; // 42 a &amp;&amp; b; // &quot;abc&quot; c || b; // &quot;abc&quot; c &amp;&amp; b; // null 对于|| 来说，如果条件判断结果为true 就返回第一个操作数（a 和 c）的值，如果为 false 就返回第二个操作数（b）的值。应用赋予默认值 &amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数（b）的值，如果为 false 就返 回第一个操作数（a 和 c）的值。应用守护运算符 符号的强制类型转换ES6 允许 从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误 var s1 = Symbol( &quot;cool&quot; ); String( s1 ); // &quot;Symbol(cool)&quot; var s2 = Symbol( &quot;not cool&quot; ); s2 + &quot;&quot;; // TypeError宽松相等和严格相等 “== 检查值是否相等，=== 检查值和类型是否相等” 说法不准确 正确的解释是：“== 允许在相等比较中进行强制类型转换，而 === 不允许。” 如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用 ==，没有就用 ===，不用在乎性能。 == 和 === 都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。 抽象相等 如果两个值的类型相同，就仅比较它们是否相等。例如，42 等于 42，”abc” 等于 “abc”。 两个对象指向同一个值时 即视为相等，不发生强制类型转换。 == 在比较两个不同类型的值时会发生隐式强制类型转换，会将其中之 一或两者都转换为相同的类型后再进行比较。 字符串和数字之间的相等比较var a = 42; var b = &quot;42&quot;; a === b; // false a == b; // true 因为没有强制类型转换，所以 a === b 为 false，42 和 &quot;42&quot; 不相等。 而 a == b 是宽松相等，即如果两个值的类型不同，则对其中之一或两者都进行强制类型 转换。 (1) 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。 (2) 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。 其他类型和布尔类型之间的相等比较== 最容易出错的一个地方是 true 和 false 与其他类型之间的相等比较。 var a = &quot;42&quot;; var b = true; a == b; // false 将 true 强制类型转换为 1，变成 1 == &quot;42&quot;，二者的 类型仍然不同，&quot;42&quot; 根据规则被强制类型转换为 42，最后变成 1 == 42，结果为 false。反过来也一样 (1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果； (2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。 建议：无论什么情况下都不要使用 == true 和 == false。请注意，这里说的只是 ==，=== true 和 === false 不允许强制类型转换可以使用 null 和 undefined 之间的相等比较 (1) 如果 x 为 null，y 为 undefined，则结果为 true。 (2) 如果 x 为 undefined，y 为 null，则结果为 true。 在 == 中 null 和 undefined 相等（它们也与其自身相等），除此之外其他值都不存在这种 情况。 var a = null; var b; a == b; // true a == false; // false b == false; // falsenull 和 undefined 之间的强制类型转换是安全可靠的，通过这种方式将 null 和 undefined 作为等价值来处理比较好。 var a = doSomething(); if (a == null) { // .. }var a = doSomething(); if (a === undefined || a === null) { // .. }对象和非对象之间的相等比较 (1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果； (2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。 var a = &quot;abc&quot;; var b = Object( a ); // 和new String( a )一样 a === b; // false a == b; // true 因为 b 通过 ToPromitive 进行强制类型转换（也称为“拆封”），并返回标量基本类型值 &quot;abc&quot;，与 a 相等。var a = null; var b = Object( a ); // 和Object()一样 a == b; // false var c = undefined; var d = Object( c ); // 和Object()一样 c == d; // false var e = NaN; var f = Object( e ); // 和new Number( e )一样 e == f; // false 因为没有对应的封装对象，所以 null 和 undefined 不能够被封装（boxed）， Object(null) 和 Object() 均返回一个常规对象。 NaN 能够被封装为数字封装对象，但拆封之后 NaN == NaN 返回 false，因为 NaN 不等于 NaN 比较少见的情况返回其他数字Number.prototype.valueOf = function() { return 3; }; new Number( 2 ) == 3; // true Number(2) 涉及 ToPrimitive 强制类型 转换，因此会调用 valueOf()。if (a == 2 &amp;&amp; a == 3) { // .. }假值的相等比较&quot;0&quot; == false; // true false == 0; // true false == &quot;&quot;; // true false == []; // true &quot;&quot; == 0; // true &quot;&quot; == []; // true 0 == []; // true 极端情况[] == ![] // true2 == [2]; // true &quot;&quot; == [null]; // true 第一行中的 [2] 会转换为 &quot;2&quot;，然后通过 ToNumber 转换为 2。第二行中的 [null] 会直接转 换为 &quot;&quot;。0 == &quot;\\n&quot;; // true42 == &quot;43&quot;; // false &quot;foo&quot; == 42; // false &quot;true&quot; == true; // false 42 == &quot;42&quot;; // true &quot;foo&quot; == [ &quot;foo&quot; ]; // true完整性检查&quot;&quot; == 0; // true &quot;&quot; == []; // true 0 == []; // true 安全运用隐式强制类型转换我们要对 == 两边的值认真推敲，以下两个原则可以让我们有效地避免出错。这时最好用 === 来避免不经意的强制类型转换。 如果两边的值中有 true 或者 false，千万不要使用 ==。 如果两边的值中有 []、”” 或者 0，尽量不要使用 ==。 抽象关系比较 比较双方首先调用 ToPrimitive，如果结果出现非字符串，就根据 ToNumber 规则将双方强 制类型转换为数字来进行比较。 var a = [ 42 ]; var b = [ &quot;43&quot; ]; a &lt; b; // true b &lt; a; // false 如果比较双方都是字符串，则按字母顺序来进行比较 var a = [ &quot;42&quot; ]; var b = [ &quot;043&quot; ]; a &lt; b; // falsevar a = { b: 42 }; var b = { b: 43 }; a &lt; b; // false 因为 a 是 [object Object]，b 也是 [object Object]，所以按照字母顺序 a &lt; b 并不成立。var a = { b: 42 }; var b = { b: 43 }; a &lt; b; // false a == b; // false a &gt; b; // false a &lt;= b; // true a &gt;= b; // true 因为根据规范 a &lt;= b 被处理为 b &lt; a，然后将结果反转。因为 b &lt; a 的结果是 false，所 以 a &lt;= b 的结果是 true。 实际上 JavaScript 中 &lt;= 是 “不大于”的意思（即 !(a &gt; b)，处理为 !(b &lt; a)）。同理 a &gt;= b 处理为 b &lt;= a。相等比较有严格相等，关系比较却没有“严格关系比较”。 也就是说如果要避免 a &lt; b 中发生隐式强制类型转换，我们只能确保 a 和 b 为相同的类型， 除此之外别无他法 5.语法 JavaScript 语法规则中的许多细节需要我们多花点时间和精力来了解。从长远来看，这有 助于更深入地掌握这门语言。 语句和表达式在英语中都能找到类比——语句就像英语中的句子，而表达式就像短语。表 达式可以是简单独立的，否则可能会产生副作用。 JavaScript 语法规则之上是语义规则（也称作上下文）。例如，{ } 在不同情况下的意思不 尽相同，可以是语句块、对象常量、解构赋值（ES6）或者命名函数参数（ES6）。 JavaScript 详细定义了运算符的优先级（运算符执行的先后顺序）和关联（多个运算符的 组合方式）。只要熟练掌握了这些规则，就能对如何合理地运用它们作出自己的判断。 ASI（自动分号插入）是 JavaScript 引擎的代码解析纠错机制，它会在需要的地方自动插 入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必要的（可以省略）， 或者由于分号缺失导致的错误是否都可以交给 JavaScript 引擎来处理。 JavaScript 中有很多错误类型，分为两大类：早期错误（编译时错误，无法被捕获）和运 行时错误（可以通过 try..catch 来捕获）。所有语法错误都是早期错误，程序有语法错误 则无法运行。 函数参数和命名参数之间的关系非常微妙。尤其是 arguments 数组，它的抽象泄漏给我们 挖了不少坑。因此，尽量不要使用 arguments，如果非用不可，也切勿同时使用 arguments 和其对应的命名参数。 finally 中代码的处理顺序需要特别注意。它们有时能派上很大用场，但也容易引起困惑， 特别是在和带标签的代码块混用时。总之，使用 finally 旨在让代码更加简洁易读，切忌 弄巧成拙。 switch 相对于 if..else if.. 来说更为简洁。需要注意的一点是，如果对其理解得不够透 彻，稍不注意就很容易出错。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://www.iamys.club/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"}]},{"title":"对象和类","slug":"对象和类","date":"2020-08-01T15:01:44.997Z","updated":"2020-08-01T15:09:42.648Z","comments":true,"path":"2020/08/01/对象和类/","link":"","permalink":"https://www.iamys.club/2020/08/01/%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/","excerpt":"","text":"对象 JavaScript 中的对象有字面形式（比如 var a = { .. }）和构造形式（比如 var a = new Array(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。 许多人都以为“JavaScript 中万物都是对象”，这是错误的。对象是 6 个（或者是 7 个，取决于你的观点）基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同 的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。 对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访 问属性时，引擎实际上会调用内部的默认 [[Get]] 操作（在设置属性值时是 [[Put]]）， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]] 链。 属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象（及其 属性）的不可变性级别。 属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是 可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。 你可以使用 ES6 的 for..of 语法来遍历数据结构（数组、对象，等等）中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值 对象可以通过两种形式定义：声明（文字）形式和构造形式。 var myObj = { key: value // ... };var myObj = new Object(); myObj.key = value; 唯一的区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。字面量方式更常用。 类型对象是 JavaScript 的基础。在 JavaScript 中一共有六种主要类型（术语是“语言类型”）： string number boolean null undefined object 注意：简单基本类型（string、boolean、number、null 和 undefined）本身并不是对象。 null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 “object”。1 实际上，null 本身是基本类型。 内置对象JavaScript 中还有一些对象子类型，通常被称为内置对象 String Number Boolean Object Function Array Date RegExp Error var strPrimitive = &quot;I am a string&quot;; console.log( strPrimitive.length ); // 13 console.log( strPrimitive.charAt( 3 ) ); // &quot;m&quot; 使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这 样做，是因为引擎自动把字面量转换成 String 对象，所以可以访问属性和方法。 内容对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的， 我们称之为属性 var myObject = { a: 2 }; myObject.a; // 2 myObject[&quot;a&quot;]; // 2 这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法 可以接受任意 UTF-8/Unicode 字符串（有些不是一个有效 的标识符属性名）作为属性名或者属性是一个变量时还有就是ES6 增加的可计算属性名使用 [ ] 包裹一个表达式来当作属性名。如myObject[prefix + name] 对象复制 浅拷贝（shallow copy）：只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存； 深拷贝（deep copy）：复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变。 ES6 定义了 Object.assign(..) 方 法来实现浅复制。Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个 或多个源对象。它会遍历一个或多个源对象的所有可枚举（enumerable） 的自有键（owned key）并把它们复制（使用 = 操作符赋值）到目标对象，最 后返回目标对象 var newObj = Object.assign( {}, myObject ); newObj.a; // 2 newObj.b === anotherObject; // true newObj.c === anotherArray; // true newObj.d === anotherFunction; // true属性描述符var myObject = { a:2 }; Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; ); // { // value: 2, // writable: true, // enumerable: true, // configurable: true // } 普通的对象属性对应的属性描述符（也被称为“数据描述符”，因为它 只保存一个数据值）可不仅仅只是一个 2。它还包含另外三个特性：writable（可写）、 enumerable（可枚举）和 configurable（可配置）。 可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性（如果它是 configurable）并对特性进行设置 var myObject = {}; Object.defineProperty( myObject, &quot;a&quot;, { value: 2, writable: true, configurable: true, enumerable: true } ); myObject.a; // 2 注意：把 configurable 修改成 false 是单向操作，无法撤销！除了无法修改，configurable:false 还会禁止删除这个属性。 不变性 对象常量 结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、 重定义或者删除） 禁止扩展 如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.prevent Extensions(..) 密封 Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以 修改属性的值） 冻结 Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们 的值。这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意 直接属性的修改 [[Get]] 对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。 如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为，就是遍历可能存在的 [[Prototype]] 链， 也就是原型链。 如果无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined [[Put]]如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。 属性是否是访问描述符？如果是并且存在 setter 就调用 setter。 属性的数据描述符中 writable 是否是 false ？如果是，在非严格模式下静默失败，在 严格模式下抛出 TypeError 异常。 如果都不是，将该值设置为属性的值。 Getter和Setter在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法 应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏 函数，会在设置属性值时调用。当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述 符”（和“数据描述符”相对）。对于访问描述符来说，JavaScript 会忽略它们的 value 和 writable 特性，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性。 存在性不访问属性值的情况下判断对象中是否存在这个属性 var myObject = { a:2 }; (&quot;a&quot; in myObject); // true (&quot;b&quot; in myObject); // false myObject.hasOwnProperty( &quot;a&quot; ); // true myObject.hasOwnProperty( &quot;b&quot; ); // false in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。 看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某 个属性名是否存在。对于数组来说这个区别非常重要，4 in [2, 4, 6] 的结 果并不是你期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、 2，没有 4。 相比之下， hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。 所有的普通对象都可以通过对于 Object.prototype 的委托来访问 hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype（通过 Object. create(null) ）。在这种情况下，形如 myObejct.hasOwnProperty(..) 就会失败。 这时可以使用一种更加强硬的方法来进行判断：Object.prototype.hasOwnProperty. call(myObject,”a”)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定到 myObject 上。 类 类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。JavaScript 也有类 似的语法，但是和其他语言中的类完全不同。 类意味着复制。 传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类 中。多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父 类，但是本质上引用的其实是复制的结果。 JavaScript 并不会（像类那样）自动创建对象的副本。 混入模式（无论显式还是隐式）可以用来模拟类的复制行为，但是通常会产生丑陋并且脆 弱的语法，比如显式伪多态（OtherObj.methodName.call(this, …)），这会让代码更加难 懂并且难以维护。 此外，显式混入实际上无法完全模拟类的复制行为，因为对象（和函数！别忘了函数也 是对象）只能复制引用，无法复制被引用的对象或者函数本身。忽视这一点会导致许多 问题。 总地来说，在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋 下更多的隐患。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://www.iamys.club/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"}]},{"title":"闭包","slug":"作用域闭包","date":"2020-08-01T14:00:08.335Z","updated":"2020-08-01T15:10:55.027Z","comments":true,"path":"2020/08/01/作用域闭包/","link":"","permalink":"https://www.iamys.club/2020/08/01/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/","excerpt":"","text":"作用域闭包 闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人 才能够到达那里。但实际上它只是一个标准，显然就是关于如何在函数作为值按需传递的 词法环境中书写代码的。 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包。 如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循 环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。 模块有两个主要特征： （1）为创建内部作用域而调用了一个包装函数； （2）包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭 包。 定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行。 function foo() { var a = 2; function bar() { console.log( a ); // 2 } bar(); } foo(); bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但却 是非常重要的一部分！） bar() 嵌套在 foo() 内部，所以函数 bar() 具有一个涵盖 foo() 作用域的闭包 （事实上，涵盖了它能访问的所有作用域，比如全局作用域） function foo() { var a = 2; function bar() { console.log( a ); } return bar; } var baz = foo(); baz(); // 2 —— 朋友，这就是闭包的效果。 拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的 词法作用域 无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。传递函数当然也可以是间接的 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包。 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建 可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。 循环域闭包问题 for (var i=1; i&lt;=5; i++) { setTimeout( function timer() { console.log( i ); //66666 }, i*1000 ); } 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是 根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的， 但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i 解决方案 for (var i=1; i&lt;=5; i++) { (function(j) { setTimeout( function timer() { console.log( j ); //12345 }, j*1000 ); })( i ); } 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的 作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 for (let i=1; i&lt;=5; i++) { setTimeout( function timer() { console.log( i ); //12345 }, i*1000 ); } 本质上这是将一个块转换成一个可以被关闭的作用域，并且在这个块作用域中声明一个变量。 模块模块模式需要具备两个必要条件： 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块 实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 bar.js function hello(who) { return &quot;Let me introduce: &quot; + who; } export hello; foo.js // 仅从 &quot;bar&quot; 模块导入 hello() import hello from &quot;bar&quot;; var hungry = &quot;hippo&quot;; function awesome() { console.log(hello( hungry )); //Let me introduce:hippo } import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量 上（在我们的例子里是 hello）。module 会将整个模块的 API 导入并绑定到一个变量上（在 我们的例子里是 foo 和 bar）。 export 会将当前模块的一个标识符（变量、函数）导出为公 共 API。这些操作可以在模块定义中根据需要使用任意多次。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://www.iamys.club/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"}]},{"title":"作用域","slug":"作用域","date":"2020-08-01T13:28:16.109Z","updated":"2020-08-19T01:48:03.410Z","comments":true,"path":"2020/08/01/作用域/","link":"","permalink":"https://www.iamys.club/2020/08/01/%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"1.作用域 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。 如果查找的目的是对 变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。 赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域 的赋值操作。 JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声 明会被分解成两个独立的步骤： 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。 LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所 需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层 楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。 不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。 编译原理 传统编译语言的流程 分词/词法分析 将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代 码块被称为词法单元 解析/语法分析 将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”（ 代码生成 将 AST 转换为可执行代码的过程称被称为代码生成。 理解作用域 参与者 引擎 从头到尾负责整个 JavaScript 程序的编译及执行过程 编译器 负责语法分析及代码生成等脏活累活 作用域 负责收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 协同工作 变量赋值举例：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如 果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。 引擎如何查找 编译器已经到了第二步生成了代码，引擎与作用域协作，询问作用域是否存在这个值 RHS查询 谁是赋值操作的源头 （RHS）如：需要查找并取 得 a 的值 LHS查询 赋值操作的目标是谁（LHS） 如：不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标 作用域嵌套 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止。也叫遍历作用域链规则 异常 引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式” ReferenceError 同作用域判别失败相关 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常 在 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 2.词法作用域 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。 编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它 们进行查找。 JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包 含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在 运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。 词法阶段function foo(a) { var b = a * 2; function bar(c) { console.log( a, b, c ); } bar( b * 3 ); } foo( 2 ); // 2, 4, 12- 1. 包含着整个全局作用域，其中只有一个标识符：foo。 - 2.包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b - 3.包含着 bar 所创建的作用域，其中只有一个标识符：c 查找 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见 第一个匹配的标识符为止。 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此 可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。window.a 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定 欺骗词法 欺骗词法会导致性能下降，尽量不用 eval eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书 写时就存在于程序中这个位置的代码。 with with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象 本身 3.函数作用域和块级作用域 函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会 在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域， 也可以属于某个代码块（通常指 { .. } 内部）。 从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。 在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if (..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块 中。 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开 发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。 函数中的作用域 属于这个函数的全部变量都可以在整个函数的范围内使用及复 用（事实上在嵌套的作用域中也可以使用） 隐藏内部实现 可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域 来“隐藏”它们。 好处 隐藏原因：这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来 的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计 避免冲突 可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致 变量的值被意外覆盖。 全局命名空间 第三方库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象 被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属 性，而不是将自己的标识符暴漏在顶级的词法作用域中。 模块管理 是从众多模块管理器中挑选一个来 使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器 的机制将库的标识符显式地导入到另外一个特定的作用域中。 函数作用域 问题：首先， 必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域（在这个 例子中是全局作用域）。其次，必须显式地通过函数名（foo()）调用这个函数才能运行其 中的代码。 解决方法：立即执行函数和匿名函数 函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处 具名和匿名 匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的， 而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。 匿名函数缺点 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑 自身。 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让 代码不言自明 解决方法：行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函 数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践 立即执行函数IIFE (function foo(){ .. })()。第一个 ( ) 将函数变成表 达式，第二个 ( ) 执行了这个函数。改进的形式：(function(){ .. }()) 进阶用法 是把它们当作函数调用并传递参数进去 是解决 undefined 标识符的默认值被错误覆盖导致的异常（虽 然不常见）。将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以 保证在代码块中 undefined 标识符的值真的是 undefined： 倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去 块级作用域 表面上看 JavaScript 并没有块作用域的相关功能。 js中具有块级作用域的地方 with try/catch let let 为其声明的变量隐式地了所在的块作用域。 let 进行的声明不会在块作用域中进行提升 const 创建块作用域变量，但其值是固定的 （常量）。之后任何试图修改值的操作都会引起错误。 TDZTDZ 又称暂时性死区，指变量在作用域内已经存在，但必须在let/const声明后才可以使用。 TDZ可以让程序保持先声明后使用的习惯，让程序更稳定。 变量要先声明后使用 建议使用let/const 而少使用var 使用let/const 声明的变量在声明前存在临时性死区（TDZ）使用会发生错误 console.log(x); // Cannot access 'x' before initialization let x = 1; 在run函数作用域中产生TDZ，不允许变量在未声明前使用。 hd = \"houdunren\"; function run() { console.log(hd); let hd = \"hdcms\"; } run(); 下面代码b没有声明赋值不允许直接使用 function hd(a = b, b = 3) {} hd(); //Cannot access 'b' before initialization 因为a已经赋值，所以b可以使用a变量，下面代码访问正常 function hd(a = 2, b = a) {} hd(); 4.提升 我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的 最顶端，这个过程被称为提升。 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引 起很多危险的问题！ 编译器又来了 var a; 和 a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在 原地等待执行阶段。 这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动” 到了最上面。这个过程就叫作提升 函数声明会被提升，但是函数表达式却不会被提升 函数优先 函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个 “重复”声明的代码中）是函数会首先被提升，然后才是变量。 重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的 一个普通块内部的函数声明通常会被提升到所在作用域的顶部，所以尽可能避免在块内部声明函数","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://www.iamys.club/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"}]},{"title":"this全面解析","slug":"this全面解析","date":"2020-07-31T15:08:41.988Z","updated":"2020-08-19T01:48:07.905Z","comments":true,"path":"2020/07/31/this全面解析/","link":"","permalink":"https://www.iamys.club/2020/07/31/this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/","excerpt":"","text":"this 关键字是 JavaScript 中最复杂的机制之一。它是一个很特别的关键字，被自动定义在 所有函数的作用域中。但是即使是非常有经验的 JavaScript 开发者也很难说清它到底指向 什么。 实际上，JavaScript 中 this 的机制并没有那么先进，但是开发者往往会把理解过程复杂化， 毫无疑问，在缺乏清晰认识的情况下，this 对你来说完全就是一种魔法 为什么要用this使用this可以在不同的上下文对象中重复使用函数，不用针对每个对象编写不同版本的函数； 如果不使用this那就得给函数显示的传入一个上下文对象，随着你使用的模式越来越复杂，显示传递上下文对象会让代码越来越混乱； 而this提供了一种更优雅的方式来隐式传递一个对象引用，可以是API设计得更加简洁并且易于复用。 解开this的误解 this并不指向函数自身 this也不一定总指向函数的作用域 this到底是什么this实际上是在函数调用时发生绑定的，它指向什么完全取决于函数在哪里被调用。 调用位置有时候会被隐藏，可以分析调用栈也就是为了到达当前执行位置所调用的所有函数，要注意的是调用位置就在正在执行的函数的前一个调用中。 可以在工具中给 foo() 函数的 第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger; 语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数 调用列表，这就是你的调用栈。因此，如果你想要分析 this 的绑定，使用开 发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。 this的绑定规则以及优先级默认绑定最常用的函数调用类型：独立函数调用（函数的调用在全局不加任何修饰）。可以把这条规则看作是无法应用 其他规则时的默认规则，this指向全局对象window，但是如果时严格模式下this的绑定是undefined。 var bar = foo()隐式绑定需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，绑定在那个上下文对象。 obj1.foo()当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的 注意：对象属性引用链中只有最顶层或者说最后一层会影响调用位置obj1.obj2.foo()时this指向obj2 隐式丢失 上下文对象引用之后赋值在全局调用 把函数作为参数进行值传递在全局调用 把函数传入语言内置函数中调用 显示绑定由call、apply、bind调用，绑定到指定对象上 var bar = foo.call(obj2)new绑定是否由new调用，绑定到新创建的对象上 var bar = new foo()new调用函数自动执行的操作 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 优先级new绑定&gt;显示绑定&gt;隐式绑定&gt;默认绑定 绑定例外 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则 ​ 安全的做法：在忽略 this 绑定时总是传入一个 DMZ 对象 var ø = Object.create( null ); foo.apply( ø, [2, 3] ); 创建一个函数的“间接引用（间接引用最容易在赋值时发生）”，在这 种情况下，调用这个函数会应用默认绑定规则。 this词法ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这 其实和 ES6 之前代码中的 self = this 机制一样。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://www.iamys.club/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"}]},{"title":"原型和原型链","slug":"原型和原型链","date":"2020-07-30T04:01:06.123Z","updated":"2020-08-01T15:08:24.106Z","comments":true,"path":"2020/07/30/原型和原型链/","link":"","permalink":"https://www.iamys.club/2020/07/30/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"构造函数创建对象function Person(){ } var person = new Person(); person.name = &#39;Kevin&#39;; console.log(person.name);//KevinPerson是个构造函数，使用new创建了一个实例对象person. prototype每个函数都有一个prototype属性,也是函数才有的属性 function Person(){ } Person.prototype.name=&#39;Kevin&#39; var person1=new Person() var person2=new Person() console.log(person1.name)//Kevin console.log(person2.name)//Kevin函数的prototype属性指向的是一个对象，这个对象时调用该构造函数而创建的实例的原型，也就是例子中的person1和person2的原型。 __proto__这是每一个JavaScript对象（除了null）都具有的一个属性，它指向该对象的原型。 function Person(){ } var person=new Person() console.log(person.__proto__===Person.prototype) constructor这是原型指向构造函数的属性，每一个原型都有一个constructor属性指向关联的构造函数。 function Person(){ } console.log(Person===Person.prototype.constructor)//true 总结function Person() { } var person = new Person(); console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true // 顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true实例和原型当读取实例对象中的属性，读取不到时就回去查找实例对象的原型中的属性，如果还是没找到就会去原型的原型中找，直到找到顶层为止 function Person() { } Person.prototype.name = &#39;Kevin&#39;; var person = new Person(); person.name = &#39;Daisy&#39;; console.log(person.name) // Daisy delete person.name; console.log(person.name) // Kevin原型的原型原型也是一个对象，既然是对象就用原始的方法创建它 var obj = new Object(); obj.name = &#39;Kevin&#39; console.log(obj.name) // Kevin其实原型对象就是由Object构造函数生成的 原型链Object.prototype的原型是null，也就是没有原型，所以查找到Object.prototype就可以停止查找了 console.log(Object.prototype.__proto__ === null) // true 图中由相互关联的原型组成的链状结构就是原型链，也就是__proto__蓝色的一条线 补充最后，补充三点大家可能不会注意的地方： constructorfunction Person() { } var person = new Person(); console.log(person.constructor === Person); // true当获取 person.constructor 时，其实 person中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： person.constructor === Person.prototype.constructor__proto__绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype中，实际上，它是来自于Object.prototype，与其说是一个属性，不如说是一个getter/setter，当使用 obj.__proto__ 时，可以理解成返回了Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://www.iamys.club/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"}]},{"title":"git常用命令","slug":"git","date":"2020-06-24T16:00:00.000Z","updated":"2020-07-24T13:01:38.108Z","comments":true,"path":"2020/06/25/git/","link":"","permalink":"https://www.iamys.club/2020/06/25/git/","excerpt":"","text":"git常用命令git是一个版本管理系统VCS，它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点将更新记录恢复回来。 git工作流程工作目录 被git管理的项目目录 暂存区 临时存放被修改文件 git仓库 用于存放提取记录 git使用前的配置配置提交人姓名 git config –global user.name 提交人姓名 配置提交人邮箱 git config –global user.email 提交人邮箱 查看配置 git config –list 提交步骤初始化git仓库 git init 查看文件信息 git status 添加到暂存区 git add 文件列表 向仓库提交 git commit -m 提交信息 查看提交记录 git log 查看提交记录 撤销暂存区覆盖工作目录 git checkout 文件 文件从暂存区中删除 git rm –cached 文件 git仓库中恢复覆盖暂存区和工作目录 git rest –hard commitID 分支分支细分 主分支 master 第一次向git仓库提交记录时自动产生的一个分支 开发分支 develop 作为开发的分支，基于master分支创建的 功能分支 feature 作为具体功能的分支，基于开发分支创建 分支命令 查看分支 git branch 创建分支 git branch 分支名称 切换分支 git checkout 分支名称 合并分支 git merge 来源分支 删除分支 git branch -d 分支名称 （-D 强制删除） 暂时保存更改存储临时改动 git stash 恢复改动 git stash pop github注册多人协作开发流程A在自己的计算机中创建本地仓库A在github中创建远程仓库A将本地仓库推送到远程仓库B克隆远程仓库到本地进行开发B将本地仓库中开发的内容推送到远程仓库A将远程仓库中的最新内容拉去到本地 创建仓库 填写仓库基本信息 将本地仓库推送到远程仓库 推送 git push 远程仓库地址 分支名称 添加地址别名 git remote add 远程仓库别名 远程仓库 别名推送 git push 远程仓库别名 分支名称 简便推送 git -u 远程仓库别名 分支名称 git push 拉取操作 克隆仓库 git clone 仓库地址 拉取最新信息 git pull 远程地址 分支名称 解决冲突在多人同时开发一个项目时，如果两个人修改了同一个文件的同一个地方，就会发生冲突。冲突需要人为解决。 跨团队协作程序员 C fork仓库程序员 C 将仓库克隆在本地进行修改程序员 C 将仓库推送到远程程序员 C 发起pull reqest原仓库作者审核原仓库作者合并代码 ssh免登录生成秘钥：ssh-keygen秘钥存储目录：C:\\Users\\用户.ssh公钥名称：id_rsa.pub私钥名称：id_rsa git忽略清单将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。git忽略清单文件名称：.gitignore将工作目录中的文件全部添加到暂存区：git add . XMind: ZEN - Trial Version","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.iamys.club/tags/git/"}]},{"title":"初识vue","slug":"vue基础","date":"2020-06-19T16:00:00.000Z","updated":"2020-07-31T15:10:47.928Z","comments":true,"path":"2020/06/20/vue基础/","link":"","permalink":"https://www.iamys.club/2020/06/20/vue%E5%9F%BA%E7%A1%80/","excerpt":"","text":"vue模块语法Vue概述声明式渲染&gt;组件系统&gt;客户端路由&gt;集中式状态管理&gt;项目构建 优点：易用、灵活、高效 Vue基本使用目标：能够说出Vue基本用法 vue的基本使用步骤 提供标签填充数据 引入vue.js库文件 可以使用vue的语法做功能 把vue提供的数据填充到标签中 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{msg}} &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;Hello Vue&#39; //在页面中打印这段字符 } }); &lt;/script&gt;细节分析： 实例参数分析 el：元素的挂载位置（值可以是css选择器，也可以是DOM元素） data：模型数据（值是一个对象） 插值表达式用法 将数据填充到HTML标签中 插值表达式支持基本计算 vue代码运行原理分析 vue代码通过可以通过vue框架编译成原生js代码 Vue模板语法目标：能够说出Vue的模板语法 模板语法概述如何理解前端渲染：把数据填充得HTML中 前端渲染的方式 原生js拼接字符串 使用前端模板引擎 使用vue特有的模板语法 模板语法概述 插值表达式 指令 事件绑定 属性绑定 样式绑定 分支循环结构 指令什么是指令 指令的本质就是自定义属性 指令的格式:以v-开始 v-cloak指令用法先提供样式,再在插值表达式中添加v-cloak指令 &lt;style&gt; [v-cloak] { display: none; } &lt;/style&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-cloak&gt;{{msg}}&lt;/div&gt; &lt;/div&gt; 插值表达式存在的问题:闪动 如何解决该问题:使用v-cloak指令 解决问题的原理:先隐藏,替换好值之后显示最终的值 数据绑定指令 v-text填充纯文本 相比插值表达式更加简洁 v-html填充HTMl片段 存在安全问题 只能本网站内部可以用 v-pre填充原始信息 显示原始信息,跳过编译过程 数据的响应式 如何理解响应式? h5中的响应式就是屏幕尺寸变化导致的样式变化,数据的响应式就是数据的变化导致页面内容的变化 什么是数据绑定?将数据填充到标签中 v-once 只编译一次,显示内容之后不再具有响应式功能 &lt;div v-once&gt;{{info}} &lt;/div&gt;双向数据绑定什么是双向数据绑定?当在表单输入域输入字符是页面的内容也会有所变化. 双向数据绑定分析v-model指令 &lt;div id=&quot;app&quot;&gt; &lt;div v-text=&#39;uname&#39;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; v-model=&#39;uname&#39;&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { uname: &#39;&#39; } }) &lt;/script&gt;MVVM设计思想M(model) 模型 js对象 V(view) 视图 页面的DOM VM(View-Model) 视图模型 Vue DOM监听+数据绑定 视图和模型可以通过视图模型相互访问,也就是DOM元素和js对象通过Vue相互转换 事件绑定vue如何处理事件用v-on指令实现事件绑定 事件函数的调用方式事件函数参数的传递 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{num}} &lt;/div&gt; &lt;button v-on:click=&#39;num++&#39;&gt;点击3&lt;/button&gt; &lt;!-- 事件绑定简写形式 --&gt; &lt;button @click=&#39;num++&#39;&gt;点击4&lt;/button&gt; &lt;!-- 事件绑定函数名 默认会传递事件对象 它为第一个参数 --&gt; &lt;button v-on:click=handle1&gt;点击1&lt;/button&gt; &lt;!-- 事件绑定函数调用 可以传递参数 事件对象必须是最后一个参数 参数名必须是$event --&gt; &lt;button v-on:click=handle2(123,456,$event)&gt;点击2&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { num: 0 }, methods: { handle1: function(event) { console.log(event.target.innerHTML); }, handle2: function(a, b, event) { // 调用参数必须写this，它指向实例对象 this.num++ console.log(a, b, event.target.innerHTML); } } }); &lt;/script&gt;事件修饰符.stop阻止冒泡 &lt;a v-on:click.stop=&#39;handle&#39;&gt;&lt;/a&gt;.prevent 阻止默认行为 &lt;a v-on:click.prevent=&#39;handle&#39;&gt;&lt;/a&gt;按键修饰符.enter回车键 &lt;input v-on:keyup.enter=&#39;submit&#39;&gt;.delete删除键 &lt;input v-on:keyup.delete=&#39;handle&#39;&gt;自定义按键修饰符全局config.keyCodes对象 Vue.config.keyCodes.f1=112属性绑定Vue如何动态处理数据v-bind指令实现动态绑定数据 &lt;div id=&quot;app&quot;&gt; &lt;!-- v-bind动态绑定属性:是它的缩写 --&gt; &lt;a v-bind:href=&quot;url&quot;&gt;百度&lt;/a&gt; &lt;!-- &lt;a :href=&quot;url&quot;&gt;百度&lt;/a&gt; --&gt; &lt;button v-on:click=&#39;handle&#39;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { url: &#39;http//www.baidu.com&#39; }, methods: { handle: function() { this.url = &#39;http://itcast.cn&#39;; } } }) &lt;/script&gt;v-model的底层实现原理 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{msg}} &lt;/div&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; v-on:input=&quot;handle&quot;&gt; //v-bind v-on &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;hello&#39; }, methods: { handle: function(event) { this.msg = event.target.value; } } }) &lt;/script&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; v-on:input=&#39;msg=$event.target.value&#39;&gt; &lt;input type=&quot;text&quot; v-model=&#39;msg&#39;&gt;样式绑定class样式处理对象语法 &lt;div v-bind:class=&quot;{active:isActive}&quot;&gt;&lt;/div&gt;数组语法 &lt;div v-bind:class=&quot;[activeClass,errorClass]&quot;&gt;&lt;/div&gt;style样式处理对象语法 &lt;div v-bind:style=&quot;{color:activeColor,fontSize:fontSize} &quot;&gt;&lt;/div&gt;数组语法 &lt;div v-bind:style=&quot;[beseStyle,overrideingStyles]&quot;&gt;&lt;/div&gt;分支循环结构分支结构v-if和v-show的区别循环结构v-for遍历数组 &lt;li v-for=&#39;item in list&#39;&gt;{{item}}+{{index}}&lt;/li&gt;key的作用：帮助Vue区分不同的元素，从而提高性能 &lt;li :key=&#39;item.id&#39; v-for=&#39;{item,index} in list&#39;&gt;{{item}}+{{index}}&lt;/li&gt;基础案例简易计算器 通过v-nodel指令实现数值a和数值b的绑定 给计算按钮绑定事件,实现计算逻辑 将计算结果绑定到对应位置 &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;简单计算器&lt;/h1&gt; 数字1：&lt;input type=&quot;text&quot; v-model=&#39;a&#39;&gt;&lt;br&gt; 数字2： &lt;input type=&quot;text&quot; v-model=&#39;b&#39;&gt;&lt;br&gt; &lt;button v-on:click=&#39;handle&#39;&gt;计算&lt;/button&gt; &lt;span v-text=&#39;result&#39;&gt;计算结果：&lt;/span&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { a: &#39;&#39;, b: &#39;&#39;, result: &#39;&#39; }, methods: { handle: function() { this.result = parseInt(this.a) + parseInt(this.b); } } }) &lt;/script&gt;tab栏切换 实现静态dUI效果： 用传统的方式实现标签结构和样式 基于数据重构UI效果：将静态的结构和样式重构基于Vue模板语法的形式，处理事件绑定和逻辑控制 &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;tab&quot;&gt; &lt;ul&gt; &lt;li v-on:click=&#39;change(index)&#39; :class=&#39;currentIndex==index?&quot;active&quot;:&quot;&quot;&#39; :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;&gt;{{item.title}} &lt;/li&gt; &lt;/ul&gt; &lt;div :class=&#39;currentIndex==index?&quot;current&quot;:&quot;&quot;&#39; :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;&gt; &lt;img :src=&quot;item.path&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { currentIndex: 0, //选项卡的当前索引 list: [{ id: 1, title: &#39;apple&#39;, path: &#39;images/01.jpg&#39; }, { id: 2, title: &#39;orange&#39;, path: &#39;images/02.jpg&#39; }, { id: 3, title: &#39;lemon&#39;, path: &#39;images/03.jpg&#39; }] }, methods: { change: function(index) { this.currentIndex = index; } } }) &lt;/script&gt;声明式编程：模板的结构和最终显示的效果基本一致 Vue常用特性目标：能够说出Vue的常用特性 表单操作 input单行文本 直接值文本域中添加v-model=’uname’,然后再到data里面给uname初始值 textarea多行文本 直接值文本域中添加v-model=’dect’,然后再到data里面给dect初始值 select下拉多选 单选方式 v-model=”occupation” 再到data里给一个初始值，多选方式 v-model=”occupation” multiple 数组的形式给初始值（给每个选项一个单独的value值） redio单选框 v-model=”gender ，data中给初始值（每个选项给一个value值） checkbox多选框 v-model=”hobby” data里以数组的方式给一个初始值（每个选项给一个单独的value值） 表单修饰符 number：转化为数值 trim：去掉开始和结尾空格 lazy：将input事件切换为change事件 &lt;input type=&quot;text&quot; v-model.number=&#39;age&#39;&gt;自定义指令当内置指令不满足要求时我们需要自定义指令 自定义的语法规则 //自定义获得焦点指令 Vue.directive(&#39;focus&#39;, { inserted: function(el) { //el表示指令所绑定的元素 el.focus(); } });自定义的指令用法 &lt;input type=&quot;text&quot; v-focus&gt;带参数的自定义属性 directives: { color: { bind: function(el, binding) { el.style.backgroundColor = binding.value; } }, focus: { //定义在实例中的局部指令 inserted: function(el) { el.focus(); } } }指令的用法 &lt;input type=&quot;text&quot; v-color=&quot;msg&quot;&gt; &lt;input type=&quot;text&quot; v-focus&gt;计算属性表达式可能比较复杂的时候，使用计算属性可以使模板内容更加简洁 计算属性的用法 computed: { reverseString: function() { return this.msg.split(&#39;&#39;).reverse().join(&#39;&#39;); //反转字符串 } }过滤器格式化数据，比如将字符串格式转换为首字符大写，将日期格式 转化为指定的格式 自定义过滤器 Vue.filter(&#39;upper&#39;, function(val) { return val.charAt(0).toUpperCase() + val.slice(1); //将第一个字母转换为大写slice字符截取 });过滤器的用法 &lt;div&gt;{{msg|upper}}&lt;/div&gt; &lt;div&gt;{{msg|upper|lower}}&lt;/div&gt; &lt;div :abc=&quot;msg|upper&quot;&gt;测试&lt;/div&gt;局部过滤器 filters: { upper: function(val) { return val.charAt(0).toUpperCase() + val.slice(1); } }带参数的过滤器Vue.filter(&#39;format&#39;,function(Value,arg)){ //value就是过滤器传过来的参数 }过滤器的使用&lt;div&gt;{{data|format('yyyy-MM-dd')}}&lt;/div&gt;侦听器在数据变化使执行异步或开销较大的操作可以使用侦听器 侦听器的用法 methods: { checkName: function(uname) { //使用定时任务模拟接口调用 var that = this; setTimeout(function() { if (uname == &#39;admin&#39;) { that.tip = &#39;用户名已存在，请更换一个&#39;; } else { that.tip = &#39;用户名可以使用&#39;; } }, 1000); } }, watch: { uname: function(val) { //调用后台接口验证用户名的合法性 this.checkName(val); //修改提示信息 this.tip = &#39;用户名正在验证…&#39;; } }生命周期主要阶段 挂载（初始化相关属性） beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用 created 在实例创建完成后立即被调用 beforeMount 在挂载开始之前被调用 mounted 被新创建的vm.$el替换，并挂载到实例上去时候调用该钩子 更新（元素或组件的变更操作） beforeUpdate 数据更新使调用，发生在虚拟DOM打补丁之前 updated 由于数据更改导致虚拟DOM重新渲染和打补丁在这之后会调用该钩子 销毁（销毁相关属性）关属性） beforeDestroy 实例销毁之前调用 destroyed 实例销毁之后调用 综合案例目标：能够基于Vue实现案例效果","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.iamys.club/tags/vue/"}]},{"title":"初识爬虫","slug":"大数据2020","date":"2020-06-19T16:00:00.000Z","updated":"2020-07-24T13:04:47.067Z","comments":true,"path":"2020/06/20/大数据2020/","link":"","permalink":"https://www.iamys.club/2020/06/20/%E5%A4%A7%E6%95%B0%E6%8D%AE2020/","excerpt":"","text":"项目分析利用大数据实验环境完成一个真实的项目。以房天下西安站二手房源数据为分析对象，使用用Numpy + Pandas库对数据进行探索性分析。首先通过Pandas对象将其从Excel电子表格中导入到数据框中。然后，对房源数据进行清洗。最后，对各关键字段字段进行相应的可视化处理。 首先导入要使用的科学计算包numpy,pandas,可视化matplotlib,seaborn,以及机器学习包sklearn。 import pandas as pd import numpy as np import seaborn as sns import matplotlib as mpl import matplotlib.pyplot as plt from IPython.display import display plt.style.use(&quot;fivethirtyeight&quot;) sns.set_style({&#39;font.sans-serif&#39;:[&#39;simhei&#39;,&#39;Arial&#39;]}) %matplotlib inline # 检查Python版本 from sys import version_info if version_info.major != 3: raise Exception(&#39;请使用Python 3 来完成此项目&#39;) 复制代码然后导入数据，并进行初步的观察，这些观察包括了解数据特征的缺失值，异常值，以及大概的描述性统计。 # 导入链家二手房数据 lianjia_df = pd.read_csv(&#39;lianjia.csv&#39;) display(lianjia_df.head(n=2)) 复制代码 初步观察到一共有11个特征变量，Price 在这里是我们的目标变量，然后我们继续深入观察一下。 # 检查缺失值情况 lianjia_df.info() 发现了数据集一共有23677条数据，其中Elevator特征有明显的缺失值。 lianjia_df.describe() 上面结果给出了特征值是数值的一些统计值，包括平均数，标准差，中位数，最小值，最大值，25%分位数，75%分位数。这些统计结果简单直接，对于初始了解一个特征好坏非常有用，比如我们观察到 Size 特征 的最大值为1019平米，最小值为2平米，那么我们就要思考这个在实际中是不是存在的，如果不存在没有意义，那么这个数据就是一个异常值，会严重影响模型的性能。 当然，这只是初步观察，后续我们会用数据可视化来清晰的展示，并证实我们的猜测。 # 添加新特征房屋均价 df = lianjia_df.copy() df[&#39;PerPrice&#39;] = lianjia_df[&#39;Price&#39;]/lianjia_df[&#39;Size&#39;] # 重新摆放列位置 columns = [&#39;Region&#39;, &#39;District&#39;, &#39;Garden&#39;, &#39;Layout&#39;, &#39;Floor&#39;, &#39;Year&#39;, &#39;Size&#39;, &#39;Elevator&#39;, &#39;Direction&#39;, &#39;Renovation&#39;, &#39;PerPrice&#39;, &#39;Price&#39;] df = pd.DataFrame(df, columns = columns) # 重新审视数据集 display(df.head(n=2))我们发现Id特征其实没有什么实际意义，所以将其移除。由于房屋单价分析起来比较方便，简单的使用总价/面积就可得到，所以增加一个新的特征 PerPrice（只用于分析，不是预测特征）。另外，特征的顺序也被调整了一下，看起来比较舒服。 数据可视化分析Region特征分析对于区域特征，我们可以分析不同区域房价和数量的对比。 # 对二手房区域分组对比二手房数量和每平米房价 df_house_count = df.groupby(&#39;Region&#39;)[&#39;Price&#39;].count().sort_values(ascending=False).to_frame().reset_index() df_house_mean = df.groupby(&#39;Region&#39;)[&#39;PerPrice&#39;].mean().sort_values(ascending=False).to_frame().reset_index() f, [ax1,ax2,ax3] = plt.subplots(3,1,figsize=(20,15)) sns.barplot(x=&#39;Region&#39;, y=&#39;PerPrice&#39;, palette=&quot;Blues_d&quot;, data=df_house_mean, ax=ax1) ax1.set_title(&#39;北京各大区二手房每平米单价对比&#39;,fontsize=15) ax1.set_xlabel(&#39;区域&#39;) ax1.set_ylabel(&#39;每平米单价&#39;) sns.barplot(x=&#39;Region&#39;, y=&#39;Price&#39;, palette=&quot;Greens_d&quot;, data=df_house_count, ax=ax2) ax2.set_title(&#39;北京各大区二手房数量对比&#39;,fontsize=15) ax2.set_xlabel(&#39;区域&#39;) ax2.set_ylabel(&#39;数量&#39;) sns.boxplot(x=&#39;Region&#39;, y=&#39;Price&#39;, data=df, ax=ax3) ax3.set_title(&#39;北京各大区二手房房屋总价&#39;,fontsize=15) ax3.set_xlabel(&#39;区域&#39;) ax3.set_ylabel(&#39;房屋总价&#39;) plt.show() 复制代码 使用了pandas的网络透视功能groupby分组排序。区域特征可视化直接采用 seaborn完成，颜色使用调色板palette 参数，颜色渐变，越浅说明越少，反之越多。 可以观察到： 二手房均价：西城区的房价最贵均价大约11万/平，因为西城在二环以里，且是热门学区房的聚集地。其次是东城大约10万/平，然后是海淀大约8.5万/平，其它均低于8万/平。 二手房房数量：从数量统计上来看，目前二手房市场上比较火热的区域。海淀区和朝阳区二手房数量最多，差不多都接近3000套，毕竟大区，需求量也大。然后是丰台区，近几年正在改造建设，有赶超之势。 二手房总价：通过箱型图看到，各大区域房屋总价中位数都都在1000万以下，且房屋总价离散值较高，西城最高达到了6000万，说明房屋价格特征不是理想的正太分布。 Size特征分析f, [ax1,ax2] = plt.subplots(1, 2, figsize=(15, 5)) # 建房时间的分布情况 sns.distplot(df[&#39;Size&#39;], bins=20, ax=ax1, color=&#39;r&#39;) sns.kdeplot(df[&#39;Size&#39;], shade=True, ax=ax1) # 建房时间和出售价格的关系 sns.regplot(x=&#39;Size&#39;, y=&#39;Price&#39;, data=df, ax=ax2) plt.show() 复制代码 Size 分布： 通过 distplot 和 kdeplot 绘制柱状图观察 Size 特征的分布情况，属于长尾类型的分布，这说明了有很多面积很大且超出正常范围的二手房。 Size 与 Price 的关系： 通过 regplot 绘制了 Size 和 Price 之间的散点图，发现 Size 特征基本与Price呈现线性关系，符合基本常识，面积越大，价格越高。但是有两组明显的异常点：1. 面积不到10平米，但是价格超出10000万；2. 一个点面积超过了1000平米，价格很低，需要查看是什么情况。 df.loc[df[&#39;Size&#39;]&lt; 10] 复制代码 经过查看发现这组数据是别墅，出现异常的原因是由于别墅结构比较特殊（无朝向无电梯），字段定义与二手商品房不太一样导致爬虫爬取数据错位。也因别墅类型二手房不在我们的考虑范围之内，故将其移除再次观察Size分布和Price关系。 df.loc[df[&#39;Size&#39;]&gt;1000] 复制代码 经观察这个异常点不是普通的民用二手房，很可能是商用房，所以才有1房间0厅确有如此大超过1000平米的面积，这里选择移除。 df = df[(df[&#39;Layout&#39;]!=&#39;叠拼别墅&#39;)&amp;(df[&#39;Size&#39;]&lt;1000)] 复制代码 重新进行可视化发现就没有明显的异常点了。 Layout特征分析f, ax1= plt.subplots(figsize=(20,20)) sns.countplot(y=&#39;Layout&#39;, data=df, ax=ax1) ax1.set_title(&#39;房屋户型&#39;,fontsize=15) ax1.set_xlabel(&#39;数量&#39;) ax1.set_ylabel(&#39;户型&#39;) plt.show() 复制代码 这个特征真是不看不知道，各种厅室组合搭配，竟然还有9室3厅，4室0厅等奇怪的结构。其中，2室一厅占绝大部分，其次是3室一厅，2室2厅，3室两厅。但是仔细观察特征分类下有很多不规则的命名，比如2室一厅与2房间1卫，还有别墅，没有统一的叫法。这样的特征肯定是不能作为机器学习模型的数据输入的，需要使用特征工程进行相应的处理。 Renovation 特征分析df[&#39;Renovation&#39;].value_counts() 复制代码精装 11345 简装 8497 其他 3239 毛坯 576 南北` `20Name: Renovation, dtype: int64 发现Renovation装修特征中竟然有南北，它属于朝向的类型，可能是因为爬虫过程中一些信息位置为空，导致“Direction”朝向特征出现在这里，所以需要清除或替换掉。 # 去掉错误数据“南北”，因为爬虫过程中一些信息位置为空，导致“Direction”的特征出现在这里，需要清除或替换 df[&#39;Renovation&#39;] = df.loc[(df[&#39;Renovation&#39;] != &#39;南北&#39;), &#39;Renovation&#39;] # 画幅设置 f, [ax1,ax2,ax3] = plt.subplots(1, 3, figsize=(20, 5)) sns.countplot(df[&#39;Renovation&#39;], ax=ax1) sns.barplot(x=&#39;Renovation&#39;, y=&#39;Price&#39;, data=df, ax=ax2) sns.boxplot(x=&#39;Renovation&#39;, y=&#39;Price&#39;, data=df, ax=ax3) plt.show() 复制代码 观察到，精装修的二手房数量最多，简装其次，也是我们平日常见的。而对于价格来说，毛坯类型却是最高，其次是精装修。 Elevator 特征分析初探数据的时候，我们发现 Elevator 特征是有大量缺失值的，这对于我们是十分不利的，首先我们先看看有多少缺失值： misn = len(df.loc[(df[&#39;Elevator&#39;].isnull()), &#39;Elevator&#39;]) print(&#39;Elevator缺失值数量为：&#39;+ str(misn)) 复制代码Elevator 缺失值数量为：8237 这么多的缺失值怎么办呢？这个需要根据实际情况考虑，常用的方法有平均值/中位数填补法，直接移除，或者根据其他特征建模预测等。 这里我们考虑填补法，但是有无电梯不是数值，不存在平均值和中位数，怎么填补呢？这里给大家提供一种思路：就是根据楼层 Floor 来判断有无电梯，一般的楼层大于6的都有电梯，而小于等于6层的一般都没有电梯。有了这个标准，那么剩下的就简单了。 # 由于存在个别类型错误，如简装和精装，特征值错位，故需要移除 df[&#39;Elevator&#39;] = df.loc[(df[&#39;Elevator&#39;] == &#39;有电梯&#39;)|(df[&#39;Elevator&#39;] == &#39;无电梯&#39;), &#39;Elevator&#39;] # 填补Elevator缺失值 df.loc[(df[&#39;Floor&#39;]&gt;6)&amp;(df[&#39;Elevator&#39;].isnull()), &#39;Elevator&#39;] = &#39;有电梯&#39; df.loc[(df[&#39;Floor&#39;]&lt;=6)&amp;(df[&#39;Elevator&#39;].isnull()), &#39;Elevator&#39;] = &#39;无电梯&#39; f, [ax1,ax2] = plt.subplots(1, 2, figsize=(20, 10)) sns.countplot(df[&#39;Elevator&#39;], ax=ax1) ax1.set_title(&#39;有无电梯数量对比&#39;,fontsize=15) ax1.set_xlabel(&#39;是否有电梯&#39;) ax1.set_ylabel(&#39;数量&#39;) sns.barplot(x=&#39;Elevator&#39;, y=&#39;Price&#39;, data=df, ax=ax2) ax2.set_title(&#39;有无电梯房价对比&#39;,fontsize=15) ax2.set_xlabel(&#39;是否有电梯&#39;) ax2.set_ylabel(&#39;总价&#39;) plt.show() 复制代码 结果观察到，有电梯的二手房数量居多一些，毕竟高层土地利用率比较高，适合北京庞大的人群需要，而高层就需要电梯。相应的，有电梯二手房房价较高，因为电梯前期装修费和后期维护费包含内了（但这个价格比较只是一个平均的概念，比如无电梯的6层豪华小区当然价格更高了）。 Year 特征分析grid = sns.FacetGrid(df, row=&#39;Elevator&#39;, col=&#39;Renovation&#39;, palette=&#39;seismic&#39;,size=4) grid.map(plt.scatter, &#39;Year&#39;, &#39;Price&#39;) grid.add_legend() 复制代码 在Renovation和Elevator的分类条件下，使用 FaceGrid 分析 Year 特征，观察结果如下： 整个二手房房价趋势是随着时间增长而增长的； 2000年以后建造的二手房房价相较于2000年以前有很明显的价格上涨； 1980年之前几乎不存在有电梯二手房数据，说明1980年之前还没有大面积安装电梯； 1980年之前无电梯二手房中，简装二手房占绝大多数，精装反而很少； Floor 特征分析f, ax1= plt.subplots(figsize=(20,5)) sns.countplot(x=&#39;Floor&#39;, data=df, ax=ax1) ax1.set_title(&#39;房屋户型&#39;,fontsize=15) ax1.set_xlabel(&#39;数量&#39;) ax1.set_ylabel(&#39;户型&#39;) plt.show() 复制代码 可以看到，6层二手房数量最多，但是单独的楼层特征没有什么意义，因为每个小区住房的总楼层数都不一样，我们需要知道楼层的相对意义。另外，楼层与文化也有很重要联系，比如中国文化七上八下，七层可能受欢迎，房价也贵，而一般也不会有4层或18层。当然，正常情况下中间楼层是比较受欢迎的，价格也高，底层和顶层受欢迎度较低，价格也相对较低。所以楼层是一个非常复杂的特征，对房价影响也比较大。 总结存在问题： 解决爬虫获取的数据源准确度问题； 需要爬取或者寻找更多好的售房特征； 需要做更多地特征工程工作，比如数据清洗，特征选择和筛选； 使用统计模型建立回归模型进行价格预测；","categories":[{"name":"大数据","slug":"大数据","permalink":"https://www.iamys.club/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.iamys.club/tags/python%E7%88%AC%E8%99%AB/"}]},{"title":"Ajax","slug":"Ajax","date":"2020-05-07T16:00:00.000Z","updated":"2020-05-08T04:37:40.558Z","comments":true,"path":"2020/05/08/Ajax/","link":"","permalink":"https://www.iamys.club/2020/05/08/Ajax/","excerpt":"","text":"Ajax的作用浏览器提供的一个方法，可以实现无刷新更新数据，提高用户浏览应用的体验。 Ajax的应用场景 页面上拉加载更多数据 列表数据无刷新分页 表单项离开焦点数据验证 搜索框提示文字下拉列表 Ajax运行原理及实现Ajax运行原理Ajax相当于浏览器发送请求与接收响应的代理人，以实现在不影响用户浏览页面的情况下，局部更新数据，从而提高用户体验。 Ajax的实现步骤 创建Ajax对象 var xhr = new XHLHttpRequest() 告诉Ajax请求地址以及请求方式 xhr.open(&#39;get&#39;,&#39;http://localhost:3000&#39;) 发送请求 xhr.send() 获取服务器端给客服端的响应数据 xhr.onload = function(){ console.log(xhr.responseText) }服务器端响应的数据格式服务器端大多数情况下会以JSON对象作为响应数据的格式，客户端拿到数据时要将JSON数据和HTML字符串进行拼接，再把拼接好的结果展示在页面 在http请求和响应的过程中，无论时请求参数还是请求参数还是响应内容，如果时对象类型，最终都会被转换为对象字符串进行传输。 JSON.parse() //将json字符串转换为json对象 JSON.stringify() // 将json对象转换为json字符串 在请求头中指定 Content-Type 属性的值是 application/json，告诉服务器端当前请求参数的格式是 json。 注意：get 请求是不能提交 json 对象数据格式的，传统网站的表单提交也是不支持 json 对象数据格式的。 请求参数传递 GET请求方式 xhr.open(&#39;get&#39;,&#39;http://www.example.com?name=zhangsan&amp;age=20&#39;) POST请求方式 xhr.setRequestHeader(&#39;Content-Type&#39;,&#39;application/x-www-form-urlencoded&#39;) xhr.send(&#39;name=zhangsan&amp;age=20&#39;)请求报文 在http请求和响应的过程中传递的数据块就叫做报文，，包括要传送的数据和一些附加信息，这些数据和信息要遵守规定好的格式。 请求参数的格式 application/x-www-form-urlencoded name=zhangsan&amp;age=20&amp;sex=男 application/json {name: &#39;zhangsan&#39;, age: &#39;20&#39;, sex: &#39;男&#39;} 获取服务器的响应Ajax状态码在创建ajax对象，配置ajax对象，发送请求，以及接收完服务器端响应数据，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码。 0：请求未初始化(还没有调用open()) 1：请求已经建立，但是还没有发送(还没有调用send()) 2：请求已经发送 3：请求正在处理中，通常响应中已经有部分数据可以用了 4：响应已经完成，可以获取并使用服务器的响应了 xhr.readyState // 获取Ajax状态码onreadystatechange事件当Ajax状态码发生变化时自动触发该事件 在事件处理函数中可以获取 Ajax 状态码并对其进行判断，当状态码为 4 时就可以通过 xhr.responseText 获取服务器端的响应数据了。 // 当Ajax状态码发生变化时 xhr.onreadystatechange = function () { // 判断当Ajax状态码为4时 if (xhr.readyState == 4) { // 获取服务器端的响应数据 console.log(xhr.responseText); } }Ajax错误处理 网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期结果。 ​ 可以判断服务器端返回的状态码，分别进行处理。xhr.status 获取http状态码 网络畅通，服务器端没有接收到请求，返回404状态码。 ​ 检查请求地址是否错误。 网络畅通，服务器端能接收到请求，服务器端返回500状态码。 ​ 服务器端错误，找后端程序员进行沟通。 网络中断，请求无法发送到服务器端。 ​ 会触发xhr对象下面的onerror事件，在onerror事件处理函数中对错误进行处理。 低版本ie浏览器的缓存问题解决方案：在请求地址的后面加请求参数，保证每一次请求中的请求参数的值不相同 xhr.open(&#39;get&#39;, &#39;http://www.example.com?t=&#39; + Math.random());Ajax异步编程 一个人一件事情做了一半，转而去做其他事情，当其他事情做完以后，再回过头来继续做之前未完成的事情。 落实到代码上，就是异步代码虽然需要花费时间去执行，但程序不会等待异步代码执行完成后再继续执行后续代码，而是直接执行后续代码，当后续代码执行完成后再回头看异步代码是否返回结果，如果已有返回结果，再调用事先准备好的回调函数处理异步代码执行的结果。 模板引擎使用步骤1.下载art-template模板引擎文件，并引入 &lt;script src=&quot;./js/template-web.js&quot;&gt;&lt;/script&gt;2.准备模板 &lt;script id=&quot;tpl&quot; type=&quot;text/html&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/script&gt; 3.告诉模板引擎将哪一个模板和哪个数据进行拼接 var html = template(&#39;tpl&#39;, {username: &#39;zhangsan&#39;, age: &#39;20&#39;});4.将拼接好的html字符串添加到页面中 document.getElementById(&#39;container&#39;).innerHTML = html; 通过模板语法告诉模板引擎，数据和html字符串要如何拼接 &lt;script id=&quot;tpl&quot; type=&quot;text/html&quot;&gt; &lt;div class=&quot;box&quot;&gt; {{ username }} &lt;/div&gt; &lt;/script&gt;FormData 对象的作用1.模拟HTML表单，相当于将HTML表单映射成表单对象，自动将表单对象中的数据拼接成请求参数的格式。 2.异步上传二进制文件 FormData 对象的使用 1.有一个HTML表单 2.将HTML表单转换为formData对象 var form = document.getElementById(&#39;form&#39;); var formData = new FormData(form);3.提交表单对象 xhr.send(formData)注意： Formdata 对象不能用于 get 请求，因为对象需要被传递到 send 方法中，而 get 请求方式的请求参数只能放在请求地址的后面。 服务器端 bodyParser 模块不能解析 formData 对象表单数据，我们需要使用 formidable 模块进行解析。 formData对象的实例方法 获取表单对象中的属性值 formData.get(&#39;key&#39;) 设置表单对象中的属性的值 formData.set(&#39;key&#39;,value) 删除表单对象中属性的值 formData.delete(&#39;key&#39;) 像表单对象中追加属性值 formData.append(&#39;key&#39;,&#39;value&#39;)注意：set 方法与 append 方法的区别是，在属性名已存在的情况下，set 会覆盖已有键名的值，append会保留两个值。 FormData二进制文件上传&lt;input type=&quot;file&quot; id=&quot;file&quot;/&gt; var file = document.getElementById(&#39;file&#39;) // 当用户选择文件的时候 file.onchange = function () { // 创建空表单对象 var formData = new FormData(); // 将用户选择的二进制文件追加到表单对象中 formData.append(&#39;attrName&#39;, this.files[0]); // 配置ajax对象，请求方式必须为post xhr.open(&#39;post&#39;, &#39;www.example.com&#39;); xhr.send(formData); }FormData文件上传进度展示 // 当用户选择文件的时候 file.onchange = function () { // 文件上传过程中持续触发onprogress事件 xhr.upload.onprogress = function (ev) { // 当前上传文件大小/文件总大小 再将结果转换为百分数 // 将结果赋值给进度条的宽度属性 bar.style.width = (ev.loaded / ev.total) * 100 + &#39;%&#39;; } }FormData文件上传图片即使预览 xhr.onload = function () { var result = JSON.parse(xhr.responseText); var img = document.createElement(&#39;img&#39;); img.src = result.src; img.onload = function () { document.body.appendChild(this); } }同源政策什么时同源：如果两个页面拥有相同的协议、域名和端口，那么这两个页面就属于同一个源，其中只要有一个不相同，就是不同源。 同源的目的：同源政策是为了保证用户信息的安全，防止恶意的网站窃取数据。最初的同源政策是指 A 网站在客户端设置的 Cookie，B网站是不能访问的。随着互联网的发展，同源政策也越来越严格，在不同源的情况下，其中有一项规定就是无法向非同源地址发送Ajax 请求，如果请求，浏览器就会报错。 使用JSONP解决同源限制问题 将不同源的服务器端请求地址写在 script 标签的 src 属性中 &lt;script src=“https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; 服务器端响应数据必须是一个函数的调用，真正要发送给客户端的数据需要作为函数调用的参数。 const data = &#39;fn({name: &quot;张三&quot;, age: &quot;20&quot;})&#39;; res.send(data); 在客户端全局作用域下定义函数 fn，并进行处理 function fn (data) { console.log(data); } JSONP代码优化1.客户端需要将函数名称传递到服务器端。 2.将 script 请求的发送变成动态请求。 3.封装 jsonp 函数，方便请求发送。 4.服务器端代码优化之 res.jsonp 方法。 CORS跨域资源共享CORS：全称为 Cross-origin resource sharing，即跨域资源共享，它允许浏览器向跨域服务器发送 Ajax 请求，克服了 Ajax 只能同源使用的限制。 浏览器端请求头 origin: http://localhost:3000服务器端响应头 Access-Control-Allow-Origin: &#39;http://localhost:3000&#39; Access-Control-Allow-Origin: &#39;*&#39; //Node服务器设置响应头实例 app.use((req, res, next) =&gt; { res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET, POST&#39;); next(); })jQuery与Ajax$.ajax() :发送Ajax请求 $.ajax({ type: &#39;get&#39;, url: &#39;http://www.example.com&#39;, data: { name: &#39;zhangsan&#39;, age: &#39;20&#39; }, contentType: &#39;application/x-www-form-urlencoded&#39;, beforeSend: function () { return false }, success: function (response) {}, error: function (xhr) {} });$.ajax: 发送jsonp请求$.ajax({ url: &#39;http://www.example.com&#39;, // 指定当前发送jsonp请求 dataType: &#39;jsonp&#39;, // 修改callback参数名称 jsonp: &#39;cb&#39;, // 指定函数名称 jsonCallback: &#39;fnName&#39;, success: function (response) {} })serialize方法：将表单中的数据自动拼接成字符串类型的参数，获取用户在表单中输入的值 var params = $(&#39;#form&#39;).serialize(); // name=zhangsan&amp;age=30$.get()和$.post()方法：$.get方法用于发送get请求，$.post方法用于发送post请求 全局事件只要页面有Ajax请求被发送，对应的全局事件就会触发 .ajaxStart() // 当请求开始发送时触发 .ajaxComplete() // 当请求完成时触发NProgress：进度条动画NProgress.start(); // 进度条开始运动 NProgress.done(); // 进度条结束运动RESTful API 一套关于请求风格的规范 GET： 获取数据 POST： 添加数据 PUT： 更新数据 DELETE： 删除数据","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://www.iamys.club/tags/Ajax/"}]},{"title":"Express框架","slug":"Express框架","date":"2020-04-19T16:00:00.000Z","updated":"2020-04-20T12:36:41.432Z","comments":true,"path":"2020/04/20/Express框架/","link":"","permalink":"https://www.iamys.club/2020/04/20/Express%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Express是一个基于Node平台的web应用开放框架，他提供了一系列的强大特性，帮助你创建各种web应用。我们可以使用npm install express 命令下载 Express框架特性 提供了方便简洁的路由定义方式 对获取HTTP请求参数进行了简化处理 对模板引擎支持程度高，方便渲染动态HTML页面 提供中间件机制有效控制HTTP请求 拥有大量中间件对功能进行扩展 // 引入express框架 const express = require(&#39;express&#39;); // 创建网站服务器 const app = express(); app.get(&#39;/&#39; , (req, res) =&gt; { // send() // 1. send方法内部会检测响应内容的类型 // 2. send方法会自动设置http状态码 // 3. send方法会帮我们自动设置响应的内容类型及编码 res.send(&#39;Hello. Express&#39;); }) // 监听端口 app.listen(3000);中间件中间件就是一堆方法，可以接受客户端放来的请求，可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。 中间件由两部分构成，中间件方法以及请求处理函数；中间件方法由Exprss提供，负责拦截请求，请求函数有开发人员提供，负责处理请求。 app.get(&#39;请求路径&#39;, &#39;处理函数&#39;) // 接收并处理get请求 app.post(&#39;请求路径&#39;, &#39;处理函数&#39;) // 接收并处理post请求可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。可以调用next方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。 app.get(&#39;/request&#39;, (req, res, next) =&gt; { req.name = &quot;张三&quot;; next(); }); app.get(&#39;/request&#39;, (req, res) =&gt; { res.send(req.name); });app.use中间件用法app.use 匹配所有请求方式，可以直接传入请求处理函数，代表接受所有请求。第一个参数可以省略表示通配。 app.use(&#39;/admin&#39;, (req, res, next) =&gt; { console.log(req.url); next(); });中间件的应用 路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。 网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。 自定义404页面 错误处理中间件在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。 app.use((err, req, res, next) =&gt; { res.status(500).send(&#39;服务器发生未知错误&#39;); })当程序出现错误时，调用next()方法，并且将错误信息通过参数的形式传递给next()方法，即可触发错误处理中间件 app.get(&quot;/&quot;, (req, res, next) =&gt; { fs.readFile(&quot;/file-does-not-exist&quot;, (err, data) =&gt; { if (err) { next(err); } }); });捕获错误在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。 异步函数执行如果发生错误可以通过 try catch 捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。 app.get(&quot;/&quot;, async (req, res, next) =&gt; { try { await User.find({name: &#39;张三&#39;}) }catch(ex) { next(ex); } });Express请求处理模块化路由const home = express.Router(); // 为路由对象匹配请求路径 app.use(&#39;/home&#39;, home); // 创建二级路由 home.get(&#39;/index&#39;, (req, res) =&gt; { res.send(&#39;欢迎来到博客首页页面&#39;) }) // admin.js const admin = express.Router(); admin.get(&#39;/index&#39;, () =&gt; { res.send(&#39;欢迎来到博客管理页面&#39;); }); module.exports = admin;const admin = require(&#39;./route/admin.js&#39;); app.use(&#39;/admin&#39;, admin);GET 参数的获取Express框架中使用req.query即可获取GET参数，框架内部会将GET参数转换为对象并返回。 // 接收地址栏中问号后面的参数 // 例如: http://localhost:3000/?name=zhangsan&amp;age=30 app.get(&#39;/&#39;, (req, res) =&gt; { console.log(req.query); // {&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;30&quot;} });POST参数的获取Express中接收post请求参数需要借助第三方包 body-parser。 // 引入body-parser模块 const bodyParser = require(&#39;body-parser&#39;); // 配置body-parser模块 // extended: false 方法内部使用querystring模块处理请求参数的格式 // extended: true 方法内部使用第三方模块qs处理请求参数的格式 app.use(bodyParser.urlencoded({ extended: false })); // 接收请求 app.post(&#39;/add&#39;, (req, res) =&gt; { // 接收请求参数 console.log(req.body); }) 路由参数 app.get(&#39;/find/:id&#39;, (req, res) =&gt; { console.log(req.params); // {id: 123} });访问的是localhost:3000/find/123 静态资源的处理通过Express内置的express.static可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。 app.use(express.static(&#39;public&#39;));这样public下的静态资源就可以访问了 Express-art-template模板引擎模板引擎 为了使art-template模板引擎能够更好的和Express框架配合，模板引擎官方在原art-template模板引擎的基础上封装了express-art-template。 使用npm install art-template express-art-template命令进行安装。 // 当渲染后缀为art的模板时 使用express-art-template app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;)); // 设置模板存放目录 app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;)); // 渲染模板时不写后缀 默认拼接art后缀 app.set(&#39;view engine&#39;, &#39;art&#39;); app.get(&#39;/&#39;, (req, res) =&gt; { // 渲染模板 res.render(&#39;index&#39;); }); app.locals对象将变量设置到app.locals对象下面，这个数据在所有的模板中都可以获取到。 app.locals.users = [{ name: &#39;张三&#39;, age: 20 },{ name: &#39;李四&#39;, age: 20 }]","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"Express框架","slug":"Express框架","permalink":"https://www.iamys.club/tags/Express%E6%A1%86%E6%9E%B6/"}]},{"title":"mongoDB数据库","slug":"mongoDB接数据库","date":"2020-04-16T16:00:00.000Z","updated":"2020-04-20T12:38:47.286Z","comments":true,"path":"2020/04/17/mongoDB接数据库/","link":"","permalink":"https://www.iamys.club/2020/04/17/mongoDB%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"术语 解释说明 database 数据库，可建立多个 collection 集合，一组数据，相当于js里的数组 document 文档，一条具体的数据，相当于js里的对象 filed 字段，文档中的属性名称，相当与js中的对象属性 如何连mongoDB接数据库 下载mongoos第三方模块npm install mongoose 启动 ner start mongoDB 引入mongoose第三方模块，用来操作数据库 用connect方法来连接数据库，参数为mongodb://localhost/playground，最后一个是数据库名写上就会自动创建 分别用.then和.catch对数据库连接成功或失败一个反馈 const mongoose = require(&#39;mongoose&#39;) mongoose.connect(&#39;mongoose://localhost/playground&#39;) .then(() =&gt; console.log(&#39;数据库连接成功&#39;)) .catch(() =&gt; console.log(&#39;数据库连接失败&#39;))如何创建一个集合以及向集合插入文档 创建集合规则，用new实例化mongoose，用Schema方法添加规则，规则为字段名和类型 创建集合，model方法第一个参数是集合名第二个参数是集合规则 创建文档，用new实例化集合，参数为一个对象每一项是具体的字段和值 将文档保存到数据库，文档名.save() const personSchema = new mongoose.Schema({ name: String, age: Number, hobbies: [String] }) const Person = mongoose.model(&#39;Person&#39;, personSchema) const person = new Person({ name: &#39;zhangsan&#39;, age: 12, hobbies: [&#39;sing&#39;, &#39;read&#39;] }) person.save()集合插入文档的另一种方式之前我们插入文档是用new实例化集合，还有一个方式是用集合.create方法参数是一个对象，里面是具体的字段和值，可以用.then查看结果。 Person.create({ name: &#39;zhangsan&#39;, age: 12, hobbies: [&#39;sing&#39;, &#39;read&#39;] }) .then(result =&gt; {console.log(result);})文档查询文档查询之前可以先建立一个用户信息文件如user.json { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f1e5aeb04b22f8460965&quot; }, &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;hobbies&quot;: [&quot;足球&quot;, &quot;篮球&quot;, &quot;橄榄球&quot;], &quot;email&quot;: &quot;zhangsan@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f236aeb04b22f8460967&quot; }, &quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 10, &quot;hobbies&quot;: [&quot;足球&quot;, &quot;篮球&quot;], &quot;email&quot;: &quot;lisi@itcast.cn&quot;, &quot;password&quot;: &quot;654321&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f267aeb04b22f8460968&quot; }, &quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;hobbies&quot;: [&quot;敲代码&quot;], &quot;email&quot;: &quot;wangwu@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f294aeb04b22f8460969&quot; }, &quot;name&quot;: &quot;赵六&quot;, &quot;age&quot;: 50, &quot;hobbies&quot;: [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;], &quot;email&quot;: &quot;zhaoliu@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f2b6aeb04b22f846096a&quot; }, &quot;name&quot;: &quot;王二麻子&quot;, &quot;age&quot;: 32, &quot;hobbies&quot;: [&quot;吃饭&quot;], &quot;email&quot;: &quot;wangermazi@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f2d9aeb04b22f846096b&quot; }, &quot;name&quot;: &quot;狗蛋&quot;, &quot;age&quot;: 14, &quot;hobbies&quot;: [&quot;打豆豆&quot;], &quot;email&quot;: &quot;goudan@163.com&quot;, &quot;password&quot;: &quot;123456&quot; }创建好集合之后用导入数据：mongoimport -d 数据库名 -c 集合名 --file 要导入文件的路径 然后再找到mongodb数据库的安装目录，将安装目录下的bin目录放置在环境变量中。 find()查询指定集合的所有文档 Person.find().then(result =&gt; console.log(result))find({条件})查询指定集合中满足条件的文档 Person.find({name:&#39;李四&#39;}).then(result=&gt;console.log(result))find({字段:{$gt:开始范围 , $lt: 结束范围}})查询字段位于之间的文档 &amp;lt小于 &amp;gt大于 Person.find({age:{$gt:20,$lt40}}).then(result=&gt;console.log(result))find({字段:{$in:包含项}}) Person.find({hobbies:{$in:[&#39;sing&#39;]}}).then(result=&gt;console.log(result))find().select(&#39;字段1，字段2..&#39;)查询指定字段，字段前加-，可以去除字段 Person.find().select(&#39;name,age,-id&#39;).then(result=&gt;console.log(result))find().sort(&#39;排序字段&#39;)默认按升序排序，加-按降序排序 Person.find().sort(&#39;-age&#39;).then(result=&gt;console.log(result))find().skip(跳过的条数).limit(限制显示结果的条数) Person.find.skip(2).limit(3).then(result=&gt;console.log(result))findOne()返回指定集合第一个文档 Person.findOne().then(result=&gt;console.log(result))findOne({条件})返回指定集合满足条件的第一个文档 Person.findOne({age:14}).then(result=&gt;console.log(result))删除文档查找一条文档并且删除，返回的是删除的文档，匹配多个文档会删除第一条 Person.findOneAndDelete({name:&#39;张三&#39;}).then(result =&gt; console.log(result))删除多个文档，不加条件会删除全部文档 Person.deleteMany({}).then(result =&gt; console.log(result))更新文档更新一条文档 Person.updateOne({ name: &#39;李四&#39; }, { name: &#39;李小四&#39;, age: 18 }).then(result =&gt; console.log(result))更新全部文档 Person.updateMany({}, { age: 0 }).then(result =&gt; console.log(result))mongoose验证在集合规则中有很多验证规则 required必填项，typt字段类型，minlength最小长度，maxlength最大长度，min最小值，max最大值，trim:true去掉首尾空格，default默认值，enum:{values:[]}枚举，validate:{validator:v=&gt;{return v&amp;&amp;v.length&gt;4}}自定义验证程序 message错误提示的获得，在向集合插入文档时的错误信息定义成如下 .catch(error =&gt; { // 获取错误信息对象 const err = error.errors; // 循环错误信息对象 for (var attr in err) { // 将错误信息打印到控制台中 console.log(err[attr][&#39;message&#39;]); } })集合关联通常不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联。 使用id对集合进行关联 使用populate方法进行关联集合查询 const userSchema = new mongoose.Schema({ name: { type: String, required: true } }); const postSchema = new mongoose.Schema({ title: String, author: { //类型为id，固定写法 type: mongoose.Schema.Types.ObjectId, //关联集合user ref: &#39;User&#39; } }) const Post = mongoose.model(&#39;Post&#39;, postSchema); const User = mongoose.model(&#39;User&#39;, userSchema) Post.create({ title: &#39;123&#39;, author: &#39;5c0caae2c4e4081c28439791&#39; }).then(result =&gt; console.log(result)); User.create({ name: &#39;李四&#39; }).then(result =&gt; console.log(result)) //populate()关联集合查询 Post.find().populate(&#39;author&#39;).then(result =&gt; console.log(result))","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"mongoDB数据库","slug":"mongoDB数据库","permalink":"https://www.iamys.club/tags/mongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"node.js","slug":"node.js","date":"2020-04-15T16:00:00.000Z","updated":"2020-04-20T12:40:02.383Z","comments":true,"path":"2020/04/16/node.js/","link":"","permalink":"https://www.iamys.club/2020/04/16/node.js/","excerpt":"","text":"node概念node是基于Chrome V8引擎的JavaScript代码运行环境，全局对象是globle，在node环境下使用node命令执行后缀为.js的文件即可 CommonJScommonJS是为js的表现制定规范，因为js没有模块化系统，标准库较少，缺乏包管理工具，CommonJS应运而生，它希望js可以在任何地方运行而不只是浏览器中，从而达到一些后端语言具有开发大型应用的能力。 commonJS与Node.js的关系：CommonJS时模块化的标准，Node.js是CommonJS（模块化）的实现 应用 服务器端js的应用程序Node.js 命令行工具 桌面图形应用程序 node组成ECMAScript和node环境提供的附加API 模块化开发javasript使用存在文件依赖和命名冲突的问题，因而要使用模块化开发，模块化开发的含义是一个功能就是一个模块多个模块可以组成完整的应用，抽离一个模块不会影响其他模块的运行。node.js规定一个JavaScript就是一个模块，模块内部定义的变量和函数外部无法得到，需要使用exports对象进行成员导出，require方法导入其他模块。 模块的导入导出 导出 exports module.exports 两者之间的关系 module.exports 是真正的接口exports是一个辅助工具如果module.exports为空，那么所有的exports属性和方法都赋值module.exports如果module.exports具有任何方法和属性，则exports会被忽略 导入 require 模块 核心模块 node自带的模块加载速度快 http模块 // 引用系统模块 const http = require(&#39;http&#39;); // 创建web服务器 const app = http.createServer(); // 当客户端发送请求的时候 app.on(&#39;request&#39;, (req, res) =&gt; { // 响应 res.end(&#39;&lt;h1&gt;hi, user&lt;/h1&gt;&#39;); }); // 监听3000端口 app.listen(3000); console.log(&#39;服务器已启动，监听3000端口，请访问 localhost:3000&#39;) 请求方式 get 请求数据 数据处理 参数放在地址栏中 参数获取需要借助系统模块url 客户端请求途径：浏览器地址栏 link标签的href属性 script标签的src属性 img标签的src属性 const http = require(&#39;http&#39;); // 导入url系统模块 用于处理url地址 const url = require(&#39;url&#39;); const app = http.createServer(); app.on(&#39;request&#39;, (req, res) =&gt; { // 将url路径的各个部分解析出来并返回对象 // true 代表将参数解析为对象格式 let {query} = url.parse(req.url, true); console.log(query); }); app.listen(3000);​ post 发送数据 实现某种功能 参数再请求体中 获取需要data和end事件 使用querystringstring系统模块将参数转为对象 ​ 客户端请求途径：Form表单提交 // 导入系统模块querystring 用于将HTTP参数转换为对象格式 const querystring = require(&#39;querystring&#39;); app.on(&#39;request&#39;, (req, res) =&gt; { let postData = &#39;&#39;; // 监听参数传输事件 req.on(&#39;data&#39;, (chunk) =&gt; postData += chunk;); // 监听参数传输完毕事件 req.on(&#39;end&#39;, () =&gt; { console.log(querystring.parse(postData)); }); });请求地址 app.on(&#39;request&#39;, (req, res) =&gt; { req.headers // 获取请求报文 req.url // 获取请求地址 req.method // 获取请求方法 });http状态码 200 请求成功 404 请求的资源没有被找到 500 服务器端错误 400 客户端请求有语法错误 url模块 parse 获取地址信息 resolve 追加或替换地址 formal 根据地址信息获得原url信息 fs文件管理 fs.stats 检测是文件还是文档 isDirctory() 是否文档 isFile() 是否文件 fs.mkdir 创建文档 fs.writeFile 创建写入文件 fs.appendFile 追加文件 fs.readdFile 读取文件 fs.readdir 读取文档 fs.rename 重命名或者剪切 fs.rmdir 删除文档 fs.unlink 删除文件 fs.createReadStream 读取流 on读取 fs.createWriteStream 写入流 write写入 end写完 on完成 path模块 path join() 拼接模块 __dirname 当前文件的绝对路径 文件模块用户自己编写的模块，动态加载运行速度相对较慢 模块的加载机制1.require方法根据模块路径查找模块，如果是完整路径，直接引入模块。2.如果模块后缀省略，先找同名JS文件再找同名JS文件夹3.如果找到了同名文件夹，找文件夹中的index.js4.如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件5.如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到 常用的第三方包第三方模块：别人已经写好的，具有特定功能的，我们可以下载直接使用的模块，通常是有多个文件组合在一起放置自在一个文件夹中，又名包。有两种存在形式，以js文件的形式存在，提供项目具体的api接口。以命令行工具存在，辅助项目开发。npmjs.com第三方模块存储和分发厂库 npm：node的第三方模块管理工具下载：npm install/i 模块名卸载：npm uninstall package 模块名命令行工具：全局安装-g 可在计算机任何一个地方使用它库文件：本地安装 nodemon：命令行工具辅助项目开发下载：npm install -g nodemon命令行工具用nodemon命令替代node命令执行文件自动监听文件是否更新，如果更新就自动执行。 nrm ：下载地址切换工具下载：npm install nrm -g查询下载地址：nrm ls切换下载地址：nrm use 下载地址名 一般都是用淘宝镜像来安装 npm install -g cnpm --registry=https://registry.npm.taobao.orgGlup ：基于node的前端构建工具作用：将机械化的操作编写成任务，想要执行这些任务时，可以用一个命令任务就自动执行了，提高开发效率。 具体应用：项目上线，HTML CSS JS文件的压缩合并。 语法转换es6 less之类的 公共文件抽离 修改文件浏览器自动刷新 使用：npm install gulp下载gulp库文件，在项目根目录下建立gulpfile.js文件，用``src目录放置源文件，dist目录放置构建后文件，在gulpfile.js文件中编写任务，在命令行工具执行gulp任务 const gulp = require(&#39;gulp&#39;); // 复制文件夹 gulp.task(&#39;copy&#39;, () =&gt; { gulp.src(&#39;./src/images/*&#39;) .pipe(gulp.dest(&#39;dist/images&#39;)); gulp.src(&#39;./src/lib/*&#39;) .pipe(gulp.dest(&#39;dist/lib&#39;)) }); // 构建任务 gulp.task(&#39;default&#39;, [&#39;htmlmin&#39;, &#39;cssmin&#39;, &#39;jsmin&#39;, &#39;copy&#39;]); gulp中提供的方法 gulp.src():获取任务要处理的文件 gulp.dest() 输出文件 gulp.task() 建立gulp任务 gulp.watach() 监控文件的变化 .pope() 放置要处理的文件 gulp插件插件网址：www.npmjs.com 插件用法：下载 如：npm install gulp-htmlmin 引用：如：require gulp-htmlmin 调用 npm install gulp-cil -g 安装gulp的命令行工具 在文件名为.glupfile.js里面编写任务，相同路径下建立src文件夹存放源文件，在dist目录下存放修改后的文件 gulp-htmlmin html文件的压缩 const gulp = require(&#39;gulp&#39;); const htmlmin = require(&#39;gulp-htmlmin&#39;); const fileinclude = require(&#39;gulp-file-include&#39;); // html任务 // 1.html文件中代码的压缩操作 // 2.抽取html文件中的公共代码 gulp.task(&#39;htmlmin&#39;, () =&gt; { gulp.src(&#39;./src/*.html&#39;) .pipe(fileinclude()) // 压缩html文件中的代码 .pipe(htmlmin({ collapseWhitespace: true })) .pipe(gulp.dest(&#39;dist&#39;)); }); gulp-file-include 公共文件包含 先把公共部分提取到一个单独的文件里，再把需要引入公共部分的地方写上 @@include (‘公共文件的路径’) - gulp-csso 压缩css - gullp-less less语法转换 ``` const less = require(&#39;gulp-less&#39;); const csso = require(&#39;gulp-csso&#39;); // css任务 // 1.less语法转换 // 2.css代码压缩 gulp.task(&#39;cssmin&#39;, () =&gt; { // 选择css目录下的所有less文件以及css文件 gulp.src([&#39;./src/css/*.less&#39;, &#39;./src/css/*.css&#39;]) // 将less语法转换为css语法 .pipe(less()) // 将css代码进行压缩 .pipe(csso()) // 将处理的结果进行输出 .pipe(gulp.dest(&#39;dist/css&#39;)) }); ``` - gulp-bable js语法转换 - gulp-uglify 压缩混淆js ``` const babel = require(&#39;gulp-babel&#39;); const uglify = require(&#39;gulp-uglify&#39;); // js任务 // 1.es6代码转换 // 2.代码压缩 gulp.task(‘jsmin’, () =&gt; { gulp.src(‘./src/js/*.js’) .pipe(babel({ // 它可以判断当前代码的运行环境 将代码转换为当前运行环境所支持的代码 presets: [‘@babel/env’] })) .pipe(uglify()) .pipe(gulp.dest(‘dist/js’)) }); ``` - browsersync 浏览器实时同步package.json文件作用：项目描述文件，记录当前项目信息，可使用npm init -yes/y命令生成。 node_modules文件夹的问题Node规范将模块文件都放在node_modules这个目录 但是如果文件夹和文件过多过碎，我们要把整体文件夹拷贝给别人的时候传输速度会很慢。复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致以免运行报错。 项目依赖项目开发和运营上线都需要依赖的第三方包，使用npm install 包名下载的文件会默认添加到package.js文件的dependencies字段中 dependencies npm install 下载 开发依赖项目开发阶段需要的依赖，线上运营不需要的第三方包，称为开发依赖使用npm install 包名 --save-dev/-D命令将包添加到devDependencies字段中 devDependencies npm install –production 下载 package-lock.js文件的作用锁定包的版本，确保再次下载时不会因为包版本不同而产生问题加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作 Node.js异步编程同步API：只有当前API执行完成后，才能继续执行下一个API，可以从返回值拿到API的执行结果 异步API：当前API的执行不会阻塞后续代码的执行，使用回调函数(自己定义的函数别人调用)可以获取异步API的执行结果 Promise出现的目的是解决Node.js异步编程中回调地狱(也就是后面异步API依赖当前异步API的调用，造成一层层嵌套的关系)的问题。 异步函数异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。 async关键字 const fn = async () =&gt; {};async function fn () {} 普通函数定义前加async关键字 普通函数变成异步函数 异步函数默认返回promise对象 在异步函数内部使用return关键字进行结果返回 结果会被包裹的promise对象中 return关键字代替了resolve方法 在异步函数内部使用throw关键字抛出程序异常 调用异步函数再链式调用then方法获取异步函数执行结果 调用异步函数再链式调用catch方法获取异步函数执行的错误信息 await关键字 await关键字只能出现在异步函数中 await promise await后面只能写promise对象 写其他类型的API是不不可以的 await关键字可是暂停异步函数向下执行 直到promise返回结果","categories":[{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://www.iamys.club/tags/node-js/"}]},{"title":"初识jQuery","slug":"jQuery","date":"2020-04-09T16:00:00.000Z","updated":"2020-04-11T14:07:22.863Z","comments":true,"path":"2020/04/10/jQuery/","link":"","permalink":"https://www.iamys.club/2020/04/10/jQuery/","excerpt":"","text":"初始jQuery什么是jQueryjQuery是一个快速、简洁的javascript库，它里面封装了JavaScript常用大的功能代码，优化了DOM操作、事件处理、动画设计和Ajax交互，学习jQuery的本质就是学习调用这些函数（方法）； jQuery的优点 轻量级。核心文件才几十kb，不会影响页面大的加载速度 跨浏览器兼容。基本兼容了现在主流大的浏览器 链式编程，隐式迭代 ( 隐式迭代就是把匹配的所有元素内部进行遍历循环) 对事件、样式、动画支持，大大简化大的DOM操作 支持插件扩展开发。有着丰富大的第三方插件，如树形菜单、日期控件、轮播图等 免费、开源 简单的使用jQuery1.jQuery的入口函数 $(function() { $(&#39;div&#39;).hide();//此处是DOM加载完成的入口，相当与原生的DOMContentLoaded })2.jQuery的顶级对象$ ​ $是jQuery的别称，在代码中jQuery和$可以互换 ​ $是jQuery的顶级对象，相当于原生的的window，帮元素利用$包装成jQuery对象，就可以调用jQuery的方法。 DOM对象和jQuery对象的区别 用原生js获取来的对象就是DOM对象 var myDiv = document.querySelector(&#39;div&#39;); // myDiv 是DOM对象 jQuery方法获取的元素就是jQuery对象 $(&#39;div&#39;); // $(&#39;div&#39;)是一个jQuery 对象 jQuery对象的本质是：利用$对DOM对象大的包装后生产的对象（伪数组形式储存） DOM对象和jQuery对象之间是可以相互转换的 因为原生js比jQuery更大，原生的一些属性和方法jQuery没有给我们封装。要是想要这些属性和方法需要把和jQuery对象转换成DOM对象才能使用 DOM对象转换为jQuery对象 $(DOM对象) $(&#39;div&#39;) jQuery对象转换为DOM对象(两种方式) $(&#39;div&#39;)[index] //index是索引号$(&#39;div&#39;).get(index)jQuery的基本操作能写出常用的jQuery选择器基础选择器$(&quot;选择器&quot;) //直接写css选择器，但是一定要加双引号 用法 名称 描述 $(“#id”) Id选择器 获取指定ID元素 $(“*”) 全选选择器 匹配所有元素 $(“.class”) 类选择器 获取同一类元素 $(“div”) 标签选择器 获取同一类标签的所有元素 $(“div,p,li”) 并集选择器 选取多个元素 $(“li.current”) 交集选择器 交集元素 层级选择器 名称 用法 描述 子代选择器 $(“ul&gt;li”) 使用&gt;号，获取亲儿子层级的元素；注意不会获取到孙子层级的元素 后代选择器 $(“ul li”) 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子 筛选选择器 语法 用法 描述 :first $(“li:first”) 获取第一个li元素 :last $(“li:last”) 获取最后一个li元素 :ed(index) $(“li:ed(2)”) 获取li元素中，选择索引号为2的元素 :odd $(“li:odd”) 获取li元素中，选择索引号为奇数的元素 :even $(“li:even”) 获取li元素中,选择索引号为偶数的元素 筛选方法(重点) 语法 用法 说明 parent() $(“li”).parent(); 查找父级 children(selector) $(“ul”).children(“li”); 相当于$(“ul&gt;li”),最近一级(亲儿子) find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“.first”).siblings(“li”); 查找兄弟节点。不包括自己 nextAll([expr]) $(“.first”).nextAll() 查找当前元素之后所有的同辈元素 prevtAll([expr]) $(“.last”).pravAll() 查找当前元素之前所有的同辈元素 hasClass(class) $(“div”).hasClass(“protected”) 查找当前元素是否含有某个特定的类，如果有则返回true eq(index) $(“li”).eq(2) 相当于$(“li:eq(2)”),index从0开始 重点记住：parent() children() find() siblings() eq() 能够操作jQuery样式操作css方法jQuery可以使用css方法来修改简单元素样式；也可以操作类，修改多个样式。 1.参数只写属性名，则返回属性值 $(this).css(&quot;color&quot;);2.参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用单位和引号 $(this.css(&quot;color&quot;,&quot;red&quot;);3.参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不加引号 $(this).css(&quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;20px&quot;)设置类样式方法作用等同于以前的classList，可以操作类样式，注意操作类里面的参数不要加点 1.添加类 $(&quot;div&quot;).addClass(&quot;current&quot;);2.移除类 $(&quot;div&quot;).removeClass(&quot;current&quot;);3.切换类 $(&quot;div&quot;).toggleClass(&quot;current&quot;);类操作与ClassName区别原生js中的ClassName会覆盖原先里面的类名 jQuery里面的类操作只是对指定类进行操作，不会影响原先的类名。 能够写出常用的jQuery动画1.显示隐藏 show() hide() toggle()show([speed,[easing],[fn]]) //(1) 参数都可以省略，无动画直接显示 (2)speed：三种预定速度之一的字符串(&quot;slow&quot;,&quot;narmal&quot;,&quot;fast&quot;)或者表示动画时长的毫秒数值 (3)easing:(Optional)用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;. (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次 下面的相同2.滑动 sideDown() sideUp() sideToggle()3.淡入淡出 fadeIn() fadeOut() fadeToggle() fadeTo()fadeTo(speed,opacity,[easing],[fn]) //(1)opacity 透明度必须写，取值0-1之间 (2)speed 三种预定速度之一的字符串(&quot;slow&quot;,&quot;narmal&quot;,&quot;fast&quot;)或者表示动画时长的毫秒数值必须写4.自定义动画 animate()animate(params,[speed],[easing],[fn]) //params 想要更改的属性，以对象的形式传递，必须写，属性名可以不写引号，复合属性采用驼峰命名方式5.动画或效果队列及其停止排队方法动画或者效果一旦触发就会执行，如果多次触发，就会造成多个动画或者效果排队执行。 stop() //用于停止动画或者效果，一定要写到动画前面，相当于停止结束上一次的动画能够操作jQuery属性设置获取元素固有属性值prop()所谓元素固有属性就是元素本身自带的属性； 1.获取属性的语法prop(&quot;属性&quot;)2.设置属性语法prop(&quot;属性&quot;，&quot;属性值&quot;)设置或获取元素自定义属性attr()用户给元素添加大的属性； 1.获取属性语法attr(&quot;属性&quot;) //类似原生getAttribute2.设置属性语法attr(&quot;属性&quot;,&quot;属性值&quot;) //类似原生setAttribute数据缓存data()data() 方法可以在指定的元素上存取数据，并不会修改DOM元素结构。一旦页面刷新，之前存放的数据都会移除。 1.附加数据语法data(&quot;name&quot;,&quot;value&quot;) //向被选元素附加数据2.获取数据语法data(&quot;name&quot;) //向被选元素获取数据同时还可以读取HTML5自定义属性data-index，得到的是数字型 能够操作jQuery元素内容文本值主要针对元素的内容还有表单的值操作 1.普通元素内容html()(相当于原生inneHTML)html() //获取元素的内容html(&quot;内容&quot;) //设置元素的内容2.普通元素文本内容text() (相当与原生innerText)text() //获取元素文本内容text(&quot;文本内容&quot;) //设置元素文本内容3.表单的值val()(相当于原生value)遍历元素jQuery隐式迭代是对同一类元素作了同样的操作，如果想要给同一类做不同的操作，就要用到遍历 语法1$(&quot;div&quot;).each(function(index,domEle){xxx;})1.each()方法遍历匹配的每一个元素。主要用DOM处理。each每一个 2.里面大的回调函数有两个参数：index是每个元素的索引号；domEle是每隔DOM元素对象不是jQuery对象 3.所以想要使用jQuery方法，需要给这个dom元素转换为jQuery对象$(domEle) 语法2$.each(object,function(index,element){xxx;})1.$.each()方法可用于遍历任何对象，主要是数据处理。比如数组对象 2.里面的函数有2个参数：index是每个元素的索引号；element遍历内容 添加元素1.内部添加element.append(&quot;内容&quot;)把内容放入匹配元素内部最后面，类似原生appendChild element.prapend(&quot;内容&quot;)2.外部添加element.after(&quot;内容&quot;) //把内容放入目标元素后面element.before(&quot;内容&quot;) //把内容放入目标元素前面内部添加元素，生成之后，他们是父子关系 外部添加元素，生成之后，他们是兄弟关系 删除元素element.remove() //删除匹配的元素（本身）element.empty() //删除匹配的元素集合中的所有子节点element.html(&quot;&quot;) //清空匹配的元素内容事件处理事件处理on()绑定事件on()方法在匹配元素上绑定一个或多个事件处理函数 element.on(events,[selector],fn)1.events:一个或多个空格分隔的事件类型，如click或者keydown 2.selector：元素的子元素选择器 3.fn：回调函数，即绑定在元素身上的侦听函数 on()方法的优势1.可以绑定多个事件 多个事件处理程序$(&quot;div&quot;).on({ mouseover:function(){}, mouseout:function(){}, click:function(){} });如果事件处理程序相同 $(&quot;div&quot;).on(&quot;mouseover mouseout&quot;,function(){ $(this).toggleClass(&quot;current&quot;); });2.可以事件委派操作，事件委派的定义就是，把原来加给子元素事件绑定在父元素身上，就是把事件委派给父元素$(&#39;ul&#39;).on(&#39;click&#39;,&#39;li&#39;,function(){ alert(&#39;hello world!&#39;); });在此之前有bind(),live() delegate()等方法来处理事件绑定或者事件委派，最新版用on代替他们 3.动态创建的元素，click()没有办法绑定事件，on()可以给动态生成的元素绑定事件事件处理off()解绑事件off()方法可以移除通过on()方法添加的事件处理程序 $(&quot;p&quot;).off() //解绑p元素所有事件处理程序 $(&quot;p&quot;).off(&quot;click&quot;) //解绑p元素上面的点击事件 $(&quot;ul&quot;).off(&quot;click&quot;,&quot;li&quot;); //解绑事件委托如果事件只想触发一次，可以使用one()来绑定事件 自动触发事件trigger()有些时间希望自动触发，比如轮播图自动播放功能跟点击右侧按钮一致，可以利用定时器自动触发右侧按钮的点击事件，不必鼠标点击触发 element.click() //第一种简写方式element.trigger(&quot;type&quot;) //第二种自动触发模式$(&quot;p&quot;).on(&quot;click&quot;,function(){ alert(&quot;hi~&quot;); }); $(&quot;p&quot;).trigger(&quot;click&quot;); //此时自动触发点击事件，不需要鼠标点击jQuery事件对象事件被触发，就会有事件对象的产生。 element.on(events,[selector],function(event){})阻止默认行为：event.preventDefault() 或者 return false 阻止冒泡：event.stopPropagation jQuery对象拷贝如果想要把某个对象拷贝（合并）给另外一个对象使用，此时可以使用$.extend()方法 $.extend([deep],target,object,[objectN])1.deep:如果设为true为深拷贝，默认false为浅拷贝 2.target：要拷贝的目标对象 3.object1：代拷贝到第一个对象的对象 4.objectN：待拷贝到第N个对象的对象 5.浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象 6.深拷贝，前面加true，完全克隆（拷贝的对象，而不是地址），修改的目标对象不会影响被拷贝的对象。 jQuery多库共存jQuery使用$作为标识符随着jQuery的流行，其他js库也用这$作为标识符，这样一来就会引起冲突。需要一个解决方案，让jQuery和其他的js和其他的js库不存在冲突，可以同时存在。这就叫做多库共存。 解决方案1.把里面的$符号统一改为jQuery。比如jQuery(“div”) 2.jQuery变量规定新的名称：$.noConflict() 如： var xxx =$.noConflict(); jQuery插件1.jQuery插件库 http://www.jq22.com/ 2.jQuery之家http://www.htmleaf.com/ 使用步骤1.引入相关文件（jQuery文件和插件文件） 2.复制相关的html，css，js（调用插件） 常用插件1.瀑布流 2.图片懒加载(图片使用延迟加载在可提高网页下载速度，它也能帮助减轻服务器负载) 当我们页面滑动得到可视区域，在显示图片，使用插件库的EasyLazyload，注意此时引入的文件和js调用必须写在DOM元素（图片）最后面 3.全屏滚动（fullpage.js) GitHub：https://github.com/alvarotrigo/fullPage.js 中文翻译网：http://www.dowebok.com/demo/2014/77/ bootstrap中文文档https://v3.bootcss.com 能够操作jQuery元素尺寸、位置jQuery尺寸 语法 用法 width()/height() 取得匹配元素宽度和高度值 只算width/height innerWidth() /innerHeight() 取得匹配元素宽度和高度值 包含padding outerWidth()/outerheight() 取得匹配元素的宽度和高度值 包含padding、border outerWidth(ture)/outerHeight(ture) 取得匹配元素宽度和高度值 包含padding、border、margin 以上参数为空，则是获取相应值，返回的是 数字型 如果参数为数字，则是修改相应值 参数可以不必写单位 jQuery位置位置主要有三个：offset()、position()、scrollTop()/scrollLeft() 1.offset()设置或获取元素偏移offset()方法设置或返回被选中元素相当于文档的偏移坐标，跟父级没有关系 该方法有2个属性left、top、offset()、top 用于获取距离文档顶部的距离，offset().left用于获取距离文档左侧的距离。 可以设置元素的偏移：offset({top:10,left:30}); 2.position() 获取元素偏移position()方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准。这个方法只能获取不能设置偏移。 3.scrollTop() /scrollLeft()设置或获取元素被卷去的头不和左侧srcollTop()方法设置或返回被选元素被卷去的头部","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.iamys.club/tags/jQuery/"}]},{"title":"JavaScript进阶","slug":"js高级","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-10T06:50:46.219Z","comments":true,"path":"2020/04/06/js高级/","link":"","permalink":"https://www.iamys.club/2020/04/06/js%E9%AB%98%E7%BA%A7/","excerpt":"","text":"1.面向对象和类的继承什么是面向对象面向对象是把事务分解成一个一个对象，以对象来划分问题，然后对象之间分工与合作。 面向对象的程序思维中，每一个对象都是功能中心，具有明确的分工。 面向对象编程具有灵活，代码可复用、容易维护和开发大的优点，适合多人合作的大型软件项目 面向对象的特性：封装性、继承性、多态性 面向对象的思维特点：1.抽取（抽象）对象公用的属性和行为组织（封装）成一个类（模板） 2.对类进行实例化，获取类的对象 面向对象编程我们考虑的是有哪些对象，按照面向对象的思维特点不断的创建对象，使用对象，指挥对象做事情 类和对象的关系对象对象是一个具体的事务，在javascript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象。 对象是由属性和方法组成的 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 类class在ES6中添加了类的概念，可以使用class关键字声明一个类，之后这个类来实例化对象。 类抽象了对象的公共部分，它泛指某一大类（class） 对象特指某一个，通过类实例化的一个具体的对象 使用class创建自定义类语法：class name{ //class body }创建实例：var xx = new name;注意：类必须使用new实例化对象 类的constructor构造函数constructor()方法是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有显示定义，类内部会自动给我们创建一个constructor() 类添加方法语法： class Person{ constructor(name,age){ this.name=name; this.age=age; } say(){ console.log(this.name+&#39;你好&#39;)； } }什么是继承子类可以继承父类的一些属性和方法。 语法：class Father{ } class Son extends Father{ }super关键字super关键字用于访问和调用父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数 调用构造函数语法：class Person { //父类 constructor(surname){ this.surname = surname; } } class Student extends Person { //子类继承父类 constructor(surname,firstname){ super(surname); //调用父类的constructor(surname) this.firstname = firstname; //定义子类独有的属性 } }注意：子类在构造函数中使用super，必须放在this前面（必须先调用父类的构造方法在使用子类构造方法） 调用普通函数语法：class Father{ say(){ return &#39;我是爸爸&#39;; } } class Son extends Father { say(){ //super.say() super调用父类方法 return super.say()+&#39;的儿子&#39;; } } var damo = new Son(); console.log(damo.say());注意：在继承中的属性和方法查找原则是就近原则，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就执行子类的，如果没有就在父类中找有没有这个方法，如果有就执行父类的这个方法。 四个注意点1.在ES6中类没有变量提升，所以先定义类，再实例化对象 2.类里面的共用属性和方法一定要加this使用 3.类里面的this指向问题 4.constructor里面的 this指向实例化对象，方法里面的this指向这个方法的调用者 2.构造函数和原型使用构造函数创建对象概述在ES6之前没有引入类的概念，所以对象不是基于类创建的，而是 一种称为构造函数的特殊函数来定义对象和他们的特征 创建对象可以通过以下三种方式： 1，对象字面量 2，new Object() 3,自定义构造函数 构造函数构造函数是一种特殊的函数 ，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用，我们可以把对象中的共有属性和方法抽取出来，然后封装到这个函数里面 在js中使用构造函数要注意以下两点： 1.构造函数用于创建一类对象，其首字母要大写 2.构造函数要和new一起使用才有意义 new在执行时会做四件事情：1.在内存中创建一个新的空对象 2.让this指向这个新的对象 3.执行构造函数的代码，给这个新对象添加属性和方法 4.返回这个新对象（所以构造函数里面不需要return） 成员分类JavaScript的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this上添加。通过这两种方法添加的成员，就分别称为静态成员和实例成员 静态成员：在构造函数本身上添加的成员为静态成员，只能由构造函数 本身来访问 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问 构造函数的问题构造函数的方法虽然很好用，但是存在浪费内存的问题，因为如果构造函数里面添加了方法这种复杂数据类型，我们每实例化一个对象就会开辟新的空间存放这种复杂数据类型，这样是很没有必要的，所以就有了构造函数的原型prototype 原型的作用构造函数原型prototype构造函数通过分配的函数是所有对象所共享的。 JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype就是一个对象，这个对象的所有属性和方法都会被构造函数所拥有。 function Star(uname, age) { this.uname = uname; this.age = age; // this.sing = function() { // console.log(&#39;我会唱歌&#39;); // } } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); console.log(ldh.sing === zxy.sing); ldh.sing(); zxy.sing(); // 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上我们可以把一些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。 问答 1.原型是什么？ 一个对象，我们也称为原型对象 2.原型的作用是什么？ 共享方法 对象原型 proto对象都有一个属性proto指向构造函数的原型对象prototype，之所以我们对象可以使用构造函数prototype原型对象的方法和属性，就是因为对象有proto原型存在。 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); ldh.sing(); console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype console.log(ldh.__proto__ === Star.prototype); // 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing // 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法 对象原型proto和原型对象prototype是等价的 proto对象原型大的意义在于为对象的查找机制提供了一个方向，或者说是一条路线，但是它是一个非标准属性，因此在实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype constructor构造函数对象原型__proto __和构造函数原型对象prototype里面都有一个属性constructor属性，constructor我们称为构造函数，因为它指回构造函数本身。 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype = { // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数 constructor: Star, sing: function() { console.log(&#39;我会唱歌&#39;); }, movie: function() { console.log(&#39;我会演电影&#39;); } } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); console.log(Star.prototype); console.log(ldh.__proto__); console.log(Star.prototype.constructor); console.log(ldh.__proto__.constructor);constructor主要用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数 构造函数、实例、原型对象三者之间的关系原型链 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); // 1. 只要是对象就有__proto__ 原型, 指向原型对象 console.log(Star.prototype); console.log(Star.prototype.__proto__ === Object.prototype); // 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototype console.log(Object.prototype.__proto__); // 3. 我们Object.prototype原型对象里面的__proto__原型 指向为 null 扩展内置对象可以通过原型对象，对原来内置对象进行扩展自定义的方法，比如给数组增加自定义求偶数和的功能。 注意：数组和字符内置对象不能给原型对象覆盖操作Array.prototype = {},只能是Array.prototype.xxx = function(){}的方式 Array.prototype.sum = function() { var sum = 0; for (var i = 0; i &lt; this.length; i++) { sum += this[i]; } return sum; }; var arr = [1, 2, 3]; console.log(arr.sum()); console.log(Array.prototype); var arr1 = new Array(11, 22, 33); console.log(arr1.sum());访问对象成员的规则JavaScript成员查找机制 1.当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 2.如果没有就查找它的原型（也就是proto指向的prototype原型对象） 3.如果还没有就查找原型对象的原型（Object的原型对象） 4.依次类推一直到找到Object为止（null） 5.proto对象原型的意义在于为对象成员查找机制提供了一个方向，或者说是一条线路 继承ES6之前并没有给我们提供extends继承，我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承 call()调用这个函数，并且修改函数运行时的this指向 fun.call(thisArg,arg1,arg2,……)thisArg：当前调用函数this的指向函数 arg1，arg2：传递的其他参数 function fn(x, y) { console.log(&#39;我想喝手磨咖啡&#39;); console.log(this); console.log(x + y); } var o = { name: &#39;andy&#39; }; // 1. call() 可以调用函数 fn.call(); // 2. call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象 fn.call(o, 1, 2); function Father(uname, age) { // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; } function Son(uname, age, score) { // this 指向子构造函数的对象实例 Father.call(this, uname, age);// 借用父构造函数继承属性 this.score = score; } Son.prototype = new Father(); //借用原型对象继承方法 // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数 Son.prototype.constructor = Son; // 这个是子构造函数专门的方法 Son.prototype.exam = function() { console.log(&#39;孩子要考试&#39;); } var son = new Son(&#39;刘德华&#39;, 18, 100); console.log(son);ES5新增的一些方法数组方法 迭代（遍历）方法：forEach()、map()、filter()、some()、every() array.forEach(function(currenValue,index,arr))currentValue:相当于当前项的值 index：数组当前项的索引 arr：数组对象本身 // forEach 迭代(遍历) 数组 var arr = [1, 2, 3]; var sum = 0; arr.forEach(function(value, index, array) { console.log(&#39;每个数组元素&#39; + value); console.log(&#39;每个数组元素的索引号&#39; + index); console.log(&#39;数组本身&#39; + array); sum += value; }) console.log(sum);array.filter(function(currenValue,index,arr))filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组，它直接返回一个新的数组。 // filter 筛选数组 var arr = [12, 66, 4, 88, 3, 7]; var newArr = arr.filter(function(value, index) { // return value &gt;= 20; return value % 2 === 0; }); console.log(newArr);array.some(function(currenValue,index,arr))some()方法用于检测数组中的元素是否满足指定条件，就是查找数组中是否有满足条件大的元素，它返回值是布尔值，如果查找这个元素就返回true，找不到就返回false var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;]; // 如果查询数组中唯一的元素, 用some方法更合适, arr.some(function(value) { if (value == &#39;green&#39;) { console.log(&#39;找到了该元素&#39;); return true; // 在some 里面 遇到 return true 就是终止遍历 迭代效率更高 } console.log(11); });字符串方法 trim()方法会从一个字符串的两端删除空白字符 str.trim()trim()方法并不影响原字符串本身，它返回的是一个新的字符串。 对象方法 Object.keys()用于获取对象自身的所有属性 Object.keys(obj)效果类似for…in 返回一个由属性名组成的数组 // 用于获取对象自身所有的属性 var obj = { id: 1, pname: &#39;小米&#39;, price: 1999, num: 2000 }; var arr = Object.keys(obj); console.log(arr); arr.forEach(function(value) { console.log(value); })Object.defineProperty()定义新属性或修改原有的属性 Object.defineProperty(obj,prop,descriptor)Object.defineProperty()第三个参数descriptor说明：以对象形式{}书写 value：设置属性的值 默认为undefined writable：值是否可以重写。true|false 默认为false enumerable：目标属性是否可以被枚举。true|false 默认false configurable：目标属性是否可以被删除或是否可以再次修改特性true|false 默认是false 3.函数进阶说出函数的多种定义和调用方式函数的定义方式1.函数声明方式function关键字（命名函数） function fn(){};2.函数表达式（匿名函数) var fun = function(){};3.new Function() var fn = new Function(&#39;参数1&#39;，&#39;参数2&#39;……,&#39;函数体&#39;) Function里面的参数必须是字符串格式 这种方式执行效率低，也不方便使用，因此使用较少 所有的函数都是Function的实例（对象） 函数也属于对象 函数的调用方式1.普通函数 function fn() { console.log(&#39;这是一个普通函数&#39;); } fn(); fn.call();2.对象的方法 var o = { sayHi: function() { console.log(&#39;这是对象的方法&#39;); } } o.sayHi();3.构造函数 function Star() { console.log(&#39;这是一个大写的构造函数&#39;); } new Star();4.绑定事件函数 var btn = document.querySelector(&#39;button&#39;); btn.onclick = function() { console.log(&#39;这是一个绑定事件函数&#39;); }5.定时器函数 setTimeout(function() { console.log(&#39;这是定时器函数&#39;) }, 1000);6.立即执行函数 (function() { console.log(&#39;这是一个立即执行函数&#39;); })()说出和改变函数内部this的指向函数内的this指向this的指向是当我们调用函数时确定的，调用的方式不同决定了this的指向不同，一般指向调用者。 调用方式 this指向 普通函数调用 window 构造函数调用 实例对象，原型对象里的方法也指向实例对象 对象的方法对象 该方法所属的对象 事件绑定方法 绑定的事件对象 定时器函数 window 立即执行函数 window 改变函数内部的this指向JavaScript提供了函数和方法帮助我们改变函数内部this的指向，常用的有bind() call() apply() call() var o = { name: &#39;andy&#39; } function fn(a, b) { console.log(this); console.log(a + b); } fn.call(o, 1, 23) //可以调用函数，可以改变this指向，可以传递普通参数 //主要应用于继承 function Father(uname, age, sex) { this.uname = uname; this.age = age; this.sex = sex; } function Son(uname, age, sex) { Father.call(this, uname, age, sex); } var son = new Son(&#39;刘德华&#39;, 12, &#39;男&#39;) console.log(son);apply() var o = { uname: &#39;andy &#39; } function fn(arr) { console.log(this); console.log(arr); } fn.apply(o, [&#39;hello&#39;]);//可以调用函数，可以改变this指向，但是第二个参数必须是数组 //apply主要应用于用数学内置函数求数组最大最小值 var arr = [12, 33, 77, 1, 0] var max = Math.max.apply(Math, arr) var min = Math.min.apply(Math, arr) console.log(max, min);bind() var o = { name: &#39;andy&#39; }; function fn(a, b) { console.log(this); console.log(a + b); }; var f = fn.bind(o, 1, 2); //不会调用函数 ，可以改变this的指向，返回的时改变后的新函数 f();// bind()的主要应用：函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind // 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮 var btn = document.querySelectorAll(&#39;button&#39;); for (var i = 0; i &lt; btn.length; i++) { btn[i].onclick = function() { this.disabled = true; setTimeout(function() { this.disabled = false; }.bind(this), 2000) } }说出严格模式的特点严格模式（strict modes）JavaScript变体的一种方式，即在严格的条件下运行js代码，它对正常的js语义做了一些更改： 消除了JavaScript语法的一些不合理，不谨慎之处，减少了一些怪异行为 消除了代码运行的不安全之处，保证了代码运行的安全 提高编译器效率，增加运行速度 禁用了ECMAScript的未来版本中可能会定义的一些语法，为未来的JavaScript做好了铺垫。 开启严格模式严格模式可以应用到整个脚本或个别函数中，因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。 为脚本开启严格模式&lt;scprit&gt; &#39;use strict&#39;; console,log(&quot;这是严格模式&quot;); &lt;/scprit&gt; //不常用，影响文件合成为函数开启严格模式 &lt;script&gt; (function() { &#39;use strict&#39;; })(); &lt;/script&gt;严格模式中的变化变量的变化 在正常模式下如果一个变量未声明就赋值默认是全局变量，在严格模式下禁止这样使用变量必须先用var声明再使用。 严禁删除已声明的变量 严格模式下this的指向问题 以前全局作用域函数this指向window，严格模式下全局作用域的函数this指向undefined 以前构造函数不加new调用当成普通函数调用且this指向window，严格模式下会报错 new实例化的构造函数还是指向创建的对象实例 定时器this还是指向window 事件、对象还是指向调用者 函数的变化 函数不能有重名的参数 函数必须声明在顶层，不能声明在for if 之类的里面 把函数作为参数和返回值传递高阶函数高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出 function fn(a, b, callback) { console.log(a + b); callback &amp;&amp; callback(); } fn(1, 2, function() { console.log(&#39;我是最后调用的&#39;); });function fn(){ return function() {}; } fn();说出闭包的的作用什么是闭包闭包是指有权访问另一个函数作用域中的变量的函数。简单说就是一个作用域可以访问另一个函数内部的局部变量。 闭包的作用闭包的主要作用：延伸了变量的作用范围 闭包案例循环注册点击事件 var lis = document.querySelectorAll(&#39;li&#39;); for (var i = 0; i &lt; lis.length; i++) { (function(i) { lis[i].onclick = function() { console.log(i); } })(i); }循环中的setTimeout() //3秒钟后打印所有的li var lis = document.querySelector(&#39;.nav&#39;).querySelectorAll(&#39;li&#39;); for (var i = 0; i &lt; lis.length; i++) { (function(i) { setTimeout(function() { console.log(lis[i].innerHTML); }, 3000) })(i) }计算打车价格 说出递归的两个条件什么是递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数，简单的说就是一个函数自己调用自己就是递归函数。递归函数的作用和循环时一样的。由于递归函数很容易发生“栈溢出”错误（stack overflow），所以必须加退出条件return。 递归的两个条件：一自身调用，二退出条件 //利用递归求1-n的阶乘 function fn(n) { if (n == 1) { return 1; } return n * fn(n - 1); } console.log(fn(4));//利用递归求斐波拉及数 function fun(i) { if (i == 1 || i == 2) { return 1; } return fun(i - 1) + fun(i - 2); } console.log(fun(4));说出深拷贝和浅拷贝的区别1.浅拷贝只拷贝一层，更深层次对象级别的只拷贝引用 Object.assign(target,…sources) es6新增的方法可以实现浅拷贝 var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 } }; var o = {}; for (var k in obj) { //k是属性名，obg[k]是属性值 o[k] = obj[k]; } console.log(o); o.msg.age = 20;//这种复杂数据类型拷贝的是地址额，当一个改变原来的也会改变 console.log(obj); Object.assign(o, obj);2.深拷贝拷贝多层，每一次的数据都会拷贝 var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 }, color: [&#39;pink&#39;, &#39;red&#39;] }; var o = {}; //封装函数 function deepCopy(newobj, oldobj) { for (k in oldobj) { var item = oldobj[k]; //判断数据类型 if (item instanceof Array) { newobj[k] = []; deepCopy(newobj[k], item); } else if (item instanceof Object) { newobj[k] = {}; deepCopy(newobj, item); } else { newobj[k] = item; } } } deepCopy(o, obj); o.msg.age = 90;//修改拷贝过的对象里的方法，原对象不会有影响 console.log(o); console.log(obj);4.正则表达式说出正则表达式的作用什么是正则表达式正则表达式是用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象 正则表达式的作用正则表达式通常用检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名，表单只能输入英文字母，数字或下划线，昵称可以输入中文（匹配）；此外，正则表达式还常用于过滤页面中内容的一些敏感词（替换）；或从字符串中提取我们想要的特定部分（提取）。 正则表达式的特点 灵活性、逻辑性和功能性非常强 可以迅速的用极为简单的方法达对字符串的复杂控制 对于刚接触的人可能比较晦涩难懂 实际开发一般都是直接复制写好的正则表达式，但是要求我们能看懂并且根据需求修改 写出简单的正则表达式创建正则表达式1.通过RegExp对象的构造寒素创建 var 变量名 = new RegExp(/表达式/)2.通过字面量创建 var 变量名 = /表达式/;测试正则表达式texttext()正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，其参数式测试字符串 regexobj.text(str) regexobj是写的正则表达式 str是我们要测试的文本 作用是检测str文本是否符合我们写的正则表达式 正则表达式的组成一个正则表达式可以由简答的字符组成，比如/abc/，也可以是简单和特殊字符的组合，比如/ab*c/，其中特殊字符也被称为原字符，在正则表达式中具有特殊意义的符号，如^,$,+等。 边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要由两个字符， 边界符 说明 ^ 表示匹配行首大的文本（从谁开始） $ 表示匹配行尾的文本（以谁结束） 字符类字符类有一系列的字符可供选择，只要匹配其中一个就可以了，所有可供选择的字符都放在方括号中就可以了。[a-z]表示从a到z。方括号里面可以使用字符组合如：[a-zA-Z0-9]；方括号中的^是取反符[^]。 量词符量词符用来设定某个模式出现的次数 量词 说明 * 重复零次或更多次 + 重复一次或更多次 ？ 重复一次或零次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 括号总结 大括号 量词符 里面重复的次数 中括号 字符集合 匹配方括号中的任意字符 小括号 表示优先级 预定义类预定义类表示的是常见模式的简写方式 预定类 说明 \\d 匹配0-9之间的任意一个数字，相当于[0-9] \\D 匹配所有0-9之外的字符，相当于 [ ^ 0-9 ] \\w 匹配任意字母数字下划线，相当于[a-zA-Z0-9_] \\W 匹配所有字母数字下划线以外的字符，相当于[ ^a-zA-Z0-9_] \\s 匹配空格 换行符制表符空格符等 \\S 匹配非空格字符 使用正则表达式对表单进行验证使用正则表达式替换内容raplace()raplace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式 stringObject.replace(regexp/substr,replacement) 第一个参数：被替换的字符串或者正则表达式 第二个参数：替换为大的字符串 返回值十一和替换完毕的新字符串 正则表达式参数/表达式/[switch]switch（也称为修饰符）按照什么样的模式匹配，有三种值 g：全局匹配 i：忽略大小写 gi：全局匹配+忽略大小写 5.ES6ES6概述什么是ES6ES的全ECMAScript，它是由ECMA国际标准化组织制度的一项脚本语言的标准化规范，2015年的版本叫做ES2015，2016年的版本叫做ES2016……所以ES6实际上是泛指ES2015及后续的版本。 为什么要使用ES6每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript本身有一些让人不满意的地方。比如变量的提升特性增加了程序运行的不可预测性，语法过于松散，实现相同的功能不同的人可能写出不同的代码…… 变量letES6中新增的声明变量的关键字 let的特点特点1：let声明的变量只在处于块级有效（大括号中定义的，只在大括号中有效） if(true){ let a =10; } console.log(a); //a is not defined注意：let声明的变量只在块级作用域下有效，但是var声明的变量不具有块级作用域的特性。 特点2：不存在变量提升（不能先用再声明） console.log(a); //a is not defined let a = 10 ;特点3：暂时性死区 var num = 10 if (true) { console.log(num); //因为在块级作用域有let关键字，所以var定义的全局不起作用，let在后面定义前面打印就会出错。 let num = 20; }let的经典面试题 var arr = []; for (var i = 0; i &lt; 2; i++) { arr[i] = function() { console.log(i); } } arr[0](); //2 arr[1](); //2 //关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值 let arr = []; for (let i = 0; i &lt; 2; i++) { arr[i] = function() { console.log(i); } } arr[0](); //0 arr[1](); //1 //关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上 一级（循环每次产生的块级作用域）作用域下的i值常量const作用：声明常量，常量就是值（内存地址）不会发生变化的量 特点1：具有块级作用域 if(true) { const a=10; } console.log(a); //a is not defined特点2：声明常量必须赋值 conts PI; //错误，PI没有赋初值特点3：常量赋值后，值不能修改 const PI = 3.14; PI = 100; //错误：Assignment to constant variable. const ary = [100, 200]; ary[0] = &#39;a&#39;; ary[1] = &#39;b&#39;; console.log(ary); //[&#39;a&#39; ,&#39;b&#39;] ary = [&#39;a&#39;, &#39;b&#39;]; // 错误 Assignment to constant variable.let、const、var的区别 var let const 函数级作用域 块级作用域 块级作用域 变量提升 不存在变量提升 不存在变量提升 值可更改 值可更改 值不可更改 解构赋值ES6中允许从数组中提取值，按照对应的位置对变量赋值，对象也可以实现解构。 数据解构数组解构允许我们按照一一对应的关系从数组中提取值然后将值赋给变量。 let [a, b, c] = [1, 2, 3]; console.log(a); //1 console.log(b); //2 console.log(c); //3当数组中的值和变量不是一一对应关系，变量的值就是undefined let [foot] = []; let [foo, bar] = [11]; console.log(foot, foo, bar); //undefined 11 undefined对象结构let person = { name: &#39;张三&#39;, age: 20 }; let {name,age} = person console.log(name); //张三 console.log(age); //20 let {name: myName} = person; //也可以使用别名获取 console.log(myName);箭头函数ES中新增的定义函数的方式 () =&gt; {} //如下 const fn = () =&gt; { console.log(123); } fn(); //如果函数体中只有一句代码并且代码的执行结果就是函数的返回值，函数体大括号可以省略 const sum = (n1, n2) =&gt; { return n1 + n2; } //可简写为： const sum = (n1, n2) =&gt; n1 + n2; console.log(sum(1, 2)); //如果形参只有一个参数可省略小括号 const fun = (v) =&gt; { alert(v); } //可简写为 const fun = v =&gt; { alert(v) } fun(7);箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this 剩余参数剩余函数允许我们将不定数量的参数表示为一个数组 function sum(first, ...args) { console.log(first); //10 console.log(args); //[20,30,40] } sum(10, 20, 30, 40);剩余参数配合解构使用 let ary = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; let [s1, ...s2] = ary; console.log(s1); //&#39;a&#39; console.log(s2); //[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]Array的扩展方法扩展运算符（展开语法）1.扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。 let ary = [1, 2, 3]; console.log(...ary); //1 2 3 注意这里逗号被当成了log的分隔符2.扩展运算符可以应用于合并数组 let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; console.log(ary3); //[1,2,3,4,5,6] ary1.push(...ary2); console.log(ary1); //[1,2,3,4,5,6]3.扩展运算符可以将类数组或可遍历的对象转换为真正的数组，以便调用数组的方法 let divs = document.querySelectorAll(&#39;div&#39;); let oDivs = [...divs]; oDivs.push(&#39;abc&#39;) console.log(oDivs); //[div, div, div, div, div, &quot;abc&quot;]构造函数的方法：Array.from()1.将类数组或可遍历的数组转换为真正的数组 let arrLike = { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, length: 3 }; let arr = Array.from(arrLike); console.log(arr); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]2.这个方法还可以接受第二个参数，作用类似于数组map方法，用于对每个元素进行处理，将处理后的值放入数组。 let arrLike = { &#39;0&#39;: &#39;2&#39;, &#39;1&#39;: &#39;3&#39;, &#39;2&#39;: &#39;4&#39;, length: 3 }; let arr = Array.from(arrLike, item =&gt; item * 2); console.log(arr); //[4, 6, 8]实例方法:find()用于找出第一个符合条件的数组成员，如果没有找回就返回undefined let ary = [{ id: 2, name: &quot;张三&quot; }, { id: 2, name: &quot;李四&quot; }]; let target = ary.find(item =&gt; item.id == 2); console.log(target); //{id: 2, name: &quot;张三&quot;}实例方法:findIndex()用于找到第一个符合条件的数组成员的位置，如果没有找到返回-1 let ary = [1, 5, 10, 15]; let index = ary.findIndex(value =&gt; value &gt; 9); console.log(index); //2实例方法:includes()表示某个数组是否包含给定值，返回的是布尔值 [1,2,3].includes(2) //trueString的扩展方法模板字符串ES6新增的创建字符串的方式，使用反引号定义 let name = `zhangsan`;模板字符串可以解析变量 let name = `zhangsan`; let sayHello = `hello my name is ${name}`; console.log(sayHello);模板字符串可以换行 let res = { name: &#39;张三&#39;, age: 12 } let html = ` &lt;div&gt; &lt;span&gt;${res.name}&lt;/span&gt; &lt;span&gt;${res.age}&lt;/span&gt; &lt;/div&gt;`; console.log(html);模板字符串可以调用函数 const fn = () =&gt; &#39;我是fn函数&#39; let html = `我是模板字符串 ${fn()}`; console.log(html)实例方法：starsWith()和endsWith() starsWith():表示参数字符串是否在原字符串的头部，返回布尔值 endsWith():表示参数字符串是否在原字符串的尾部，返回布尔值 let str = &#39;Hello ECMAScript 2015&#39;; let r1 = str.startsWith(&#39;Hello&#39;); //true console.log(r1); let r2 = str.endsWith(&#39;2016&#39;); //false console.log(r2)实例方法：repeat()表示将原字符重复n次返回一个新字符串 console.log(&quot;y&quot;.repeat(5)) //yyyyyset数据结构ES6提供了新的数据结构Set，它类似于数组，但成员的值都是唯一的，没有重复的。 Set本身是一个构造函数，用来生成Set数据结构。 const s = new Set();Set 函数可以接受一个数组作为参数，用来初始化。 const set = new Set([1,2,3,4,4]);实例方法 add(Value):添加某个值，返回Set结构本身 delete(value):删除一个值，返回一个布尔值，表示删除是否成功。 has(value):返回一个布尔值，表示该值是否为Set的成员 clear():清除所有成员，没有返回值 const s = new Set(); s.add(1).add(2); //向set结构中添加值 s.delete(2); //删除set结构中的2值 s.has(1) //表示set结构中是否有这个值，返回布尔值 s.clear() //清除s中的所有值遍历Set结构的实例与数组一样，也有forEach方法，用于对每个成员执行某种操作，没有返回值 s.forEach(value =&gt; console.log(value))","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.iamys.club/tags/JavaScript/"},{"name":"EC6","slug":"EC6","permalink":"https://www.iamys.club/tags/EC6/"}]}],"categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"前端面试","slug":"前端面试","permalink":"https://www.iamys.club/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"},{"name":"大数据","slug":"大数据","permalink":"https://www.iamys.club/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"前后端交互","slug":"前后端交互","permalink":"https://www.iamys.club/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.iamys.club/tags/vue/"},{"name":"面试题","slug":"面试题","permalink":"https://www.iamys.club/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"ES6","slug":"ES6","permalink":"https://www.iamys.club/tags/ES6/"},{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"https://www.iamys.club/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"},{"name":"git","slug":"git","permalink":"https://www.iamys.club/tags/git/"},{"name":"python爬虫","slug":"python爬虫","permalink":"https://www.iamys.club/tags/python%E7%88%AC%E8%99%AB/"},{"name":"Ajax","slug":"Ajax","permalink":"https://www.iamys.club/tags/Ajax/"},{"name":"Express框架","slug":"Express框架","permalink":"https://www.iamys.club/tags/Express%E6%A1%86%E6%9E%B6/"},{"name":"mongoDB数据库","slug":"mongoDB数据库","permalink":"https://www.iamys.club/tags/mongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"node.js","slug":"node-js","permalink":"https://www.iamys.club/tags/node-js/"},{"name":"jQuery","slug":"jQuery","permalink":"https://www.iamys.club/tags/jQuery/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.iamys.club/tags/JavaScript/"},{"name":"EC6","slug":"EC6","permalink":"https://www.iamys.club/tags/EC6/"}]}